C*********************************************************************          
C  GLOBAL SAVE BLOCK
C  DIMENSION SIZE INCREASED SEPT 1990 FOR UNICOS VERSION GENPRO (-CC)
C  X1 version setup for HaRP Project (ISPACE=900000)
C  THIS IS SETUP TO PROCESS - 600 VARIABLES
C                           - TOTAL OF UP TO 30 OPERATIONS
C                           - UP TO 5 INPUT OPERATIONS
C  
.OPTION OC=1 UC=0
.REPL /$VERS/X1/                                                                
.REPL /$INOP/5/                                                                 
.REPL /$IOP/30/                                                                 
.REPL /$NVAR/600/                                                               
.REPL /$NFILE/500/                                                              
.REPL /$ISPACE/900000/                                                          
.REPL /$LENSP/875000/                                                           
.REPL /$LENTR/25000/  
.REPL /$MAXCA/30000/                                                            
.REPL /$BITCHR/8/                                                               
.REPL /$NCPNSU/8/                                                               
.REPL /$IVDIM/3/                                                                
.AC   A                                                                         
.DE   G                                                                         
.DE   U                                                                         
.DE   V                                                                         
.DE   M                                                                         
.AC   H                                                                         
.AC   T                                                                         
.DE   R                                                                         
.DE   K                                                                         
.DE   Y                                                                         
.SAVE TYPVAR                                                                    
C  ALL WRONG TYPE VARIABLES IN  BLANK,CYCVAR,OP,INPUT, AND IOUNIT               
      INTEGER  FLUSHP, BITCHR, BITNSU, OVRLAP, THISOP                           
      INTEGER  EXDATE, EXTIME, PRDATE, PRTIME                                   
.END                                                                            
.SAVE TBLANK                                                                    
C  BLANK                                                                        
      INTEGER IBUF, ICON, IDATA, ISAV, ISCR, LENBUF, LENCA, LENDAT,             
     1 LENSAV, LENSCR, LENSP, LOCBUF, LOCCA, LOCDAT, LOCSAV, LOCSCR             
      REAL SPACE, BUF, CON, DATA, SAV, SCR, OVRFLO                              
.END                                                                            
.SAVE TCYCVAR                                                                   
C  CYCVAR                                                                       
      INTEGER IVDIM, LABIV, LENPER, FLUSHP, BITCHR, BITNSU, MXCHR               
      INTEGER  EXDATE, EXTIME, PRDATE, PRTIME, MACHIN, JOBIDS, NSUIDS           
      REAL BEGIV, ENDIV, DELIV, SCALIV, BEGPER, ENDPER, BITIV                   
.END                                                                            
.SAVE TERROR                                                                    
      INTEGER IABORT, NSTAGE, IERR, NUMERR                                      
.END                                                                            
.SAVE TFLOW                                                                     
      INTEGER INOP1,ITYPOP,JOBS,JOBSTP,KORD,LENFIX,LENTOT,LINDCY,MINCY,         
      INTEGER NCASE,NCYEND,NCYOLD,NUMOPT,NUMREM,NUMOPS,NXTTOP,                  
      INTEGER SNPBRK,TOTOPS                                                     
.END                                                                            
.SAVE TINPUT                                                                    
C  INPUT                                                                        
      INTEGER INNUM, INTOT, ISTATE, NAMFIL, NAMREC, NAMVOL, NUNIT               
      REAL BEGTAP, ENDTAP                                                       
.END                                                                            
.SAVE TIOUNIT                                                                   
C  IOUNIT                                                                       
      INTEGER KCHECK, KDUMP, KERR, KFICHE, KFILM, KPROC, KPRINT                 
.END                                                                            
.SAVE TOP                                                                       
C  OP                                                                           
      INTEGER INDCYC, THISOP, LASTOP, LENCYC, NAMEOP, NCDO, NCYNOW,             
     1 NUMCAL, NUMCYC, OVRLAP                                                   
      REAL GAPFLG, GAPVAL, VALIV                                                
.END                                                                            
.SAVE TSNAP                                                                     
      INTEGER LENSNP,LOCBEG,LOCEND,NUMGRP                                       
      REAL BEGSNP,ENDSNP                                                        
.END                                                                            
.SAVE BLANK                                                                     
C                                                                               
C  THIS COMMON BLOCK CONTAINS ALL LARGE STORAGE PARTITIONS USED BY ALL          
C  OPERATIONS, AS WELL AS POINTERS AND LENGTHS FOR THOSE PARTITIONS             
C                                                                               
      COMMON SPACE($ISPACE), OVRFLO, LENSP,                                     
     1 LENBUF($IOP),LENCA($IOP),LENDAT($IOP),LENSAV($IOP),LENSCR,               
     2 LOCBUF($IOP),LOCCA($IOP),LOCDAT($IOP),LOCSAV($IOP),LOCSCR                
      DIMENSION  CON($ISPACE), SAV($ISPACE), BUF($ISPACE)                       
     -, DATA($ISPACE), SCR($ISPACE)                                             
      DIMENSION ICON($ISPACE),ISAV($ISPACE),IBUF($ISPACE)                       
     -,IDATA($ISPACE),ISCR($ISPACE)                                             
      EQUIVALENCE (SPACE(1), CON(1), SAV(1), BUF(1), DATA(1), SCR(1))           
      EQUIVALENCE (SPACE(1),ICON(1),ISAV(1),IBUF(1),IDATA(1),ISCR(1))           
.END                                                                            
.SAVE CYCVAR                                                                    
C  THIS COMMON BLOCK CONTAINS THE INDEPENDENT VARIABLE RUN PERIOD,              
C  THE INDEPENDENT VARIABLE CYCLE INCREMENT, UNITS OF THE INDEPENDENT           
C  VARIABLE, THE BITS PER CHARACTER AND BITS PER NSU OF THE                     
C  COMPUTER BEING USED, THE SNAPSHOT DISPLAY PERIODS, AND THE PROJECT           
C  AND EXECUTION DATES, TIMES, AND JOB IDS                                      
C                                                                               
      COMMON /CYCVAR/ BEGIV, ENDIV, DELIV, IVDIM, LABIV(6), SCALIV(6),          
     1 BEGPER(7), ENDPER(7), LENPER, FLUSHP, BITCHR, BITNSU,BITIV,MXCHR         
     2,EXDATE(3),EXTIME(3),PRDATE(3),PRTIME(3),MACHIN,JOBIDS(10),NSUIDS         
.END                                                                            
.SAVE OP                                                                        
C  THIS COMMON BLOCK CONTAINS ITEMS RELATED TO THE DATA CYCLE NUMBER            
C  AND SIZE, THE OPERATION CALL, AND THE NEEDED HOOKS INTO THE DATA             
C                                                                               
      COMMON /OP/ GAPFLG, GAPVAL, INDCYC($IOP), THISOP, LASTOP,                 
     1 LENCYC($IOP),NAMEOP($IOP), NCDO, NCYNOW($IOP), NUMCAL($IOP),             
     2 NUMCYC($IOP),OVRLAP($IOP), VALIV($IOP)                                   
.END                                                                            
.SAVE ERROR                                                                     
C                                                                               
C  THIS COMMON BLOCK PROVIDES ERROR COMMUNICATIONS BETWEEN THE DRIVER           
C  AND THE OPS AT VARIOUS STAGES OF JOB EXECUTION.  IERR IS 0 WHEN AN           
C  OP IS CALLLED.  THE OP SUMS ALL FATAL ERRORS AT THE STAGE OF EXECU-          
C  TION NSTAGE AND RETURNS THIS VALUE IN IERR.                                  
C                                                                               
      COMMON /ERROR/ IABORT, NSTAGE, IERR, NUMERR($IOP)                         
.END                                                                            
.SAVE INPUT                                                                     
      COMMON /INPUT1/ BEGTAP($INOP), ENDTAP($INOP), INNUM, INTOT,               
     1 ISTATE($INOP), NAMFIL($INOP),NAMREC($INOP),NAMVOL($INOP),                
     2 NUNIT($INOP)                                                             
.END                                                                            
.SAVE IOUNIT                                                                    
C THIS COMMON BLOCK CONTAINS GENERIC OUTPUT UNIT NUMBERS                        
      COMMON /IOUNIT/ KCHECK, KDUMP, KERR, KFICHE, KFILM, KPROC, KPRINT         
.END                                                                            
.SAVE CASINT                                                                    
      COMMON /CASINT/ IVINTS,IVINT                                              
.END                                                                            
.SAVE INDEX                                                                     
C                                                                               
C  CONTROL ARRAY INDICES FOR OPERATION THISOP                                   
C  SEE SAVE BLOCK INDEXC FOR A DEFINITION OF ALL VARIABLES                      
C                                                                               
      INDADD = LOCCA(THISOP) - 1                                                
      IF(INDST.LT.1.OR.INDST.GT.3) INDST = 2                                    
      INDCON = ICON(INDST*2+INDADD) + INDADD                                    
      NUMVEC = ICON(INDCON + 2)                                                 
      NUMCON = ICON(INDCON + 4)                                                 
      LENCON = ICON(INDCON + 6)                                                 
      INDOFF = INDCON + 7                                                       
      INDGRP = INDOFF + 1*(NUMCON + 1)                                          
      INDELM = INDOFF + 2*(NUMCON + 1)                                          
      INDTYP = INDOFF + 3*(NUMCON + 1)                                          
      INDNAM = INDOFF + 4*(NUMCON + 1)                                          
      INDVAL = INDOFF + 5*(NUMCON + 1)                                          
.END                                                                            
.SAVE INDEXS                                                                    
C               A SHORT FORM OF SAVE BLOCK INDEX                                
C          CONTROL ARRAY INDICES FOR OPERATION THISOP                           
C    SEE SAVE BLOCK INDEXC FOR A DEFINITION OF ALL VARIABLES                    
C                                                                               
      INDADD = LOCCA(THISOP) - 1                                                
      IF(INDST.LT.1.OR.INDST.GT.3) INDST = 2                                    
      INDCON = ICON(INDST*2+INDADD) + INDADD                                    
      NUMVEC = ICON(INDCON + 2)                                                 
      NUMCON = ICON(INDCON + 4)                                                 
      LENCON = ICON(INDCON + 6)                                                 
      INDOFF = INDCON + 7                                                       
      INDELM = INDOFF + 2*(NUMCON + 1)                                          
      INDVAL = INDOFF + 5*(NUMCON + 1)                                          
.END                                                                            
.SAVE FLOW                                                                      
C  THIS COMMON BLOCK CONTAINS ITEMS NEEDED BY THE DRIVER TO REGULATE            
C  THE DATA FLOW                                                                
C                                                                               
      INTEGER SNPBRK, TOTOPS                                                    
      COMMON /FLOW/ INOP1,ITYPOP($IOP),JOBS,JOBSTP,KORD($IOP), LENFIX,          
     1 LENTOT($IOP), LINDCY($IOP), MINCY($IOP), NCASE,   NCYEND($IOP),          
     2 NCYOLD($IOP),NUMOPT, NUMREM($IOP), NUMOPS, NXTTOP($IOP),SNPBRK,          
     3 TOTOPS                                                                   
.END                                                                            
.SAVE GETPUT                                                                    
C  THE CONTROL NO. OF VARIABLE CONTROLS INDGET, INRATE, INDPUT, AND RATE        
C                                                                               
      COMMON /GETPUT/NDXGET($IOP),NDXINR($IOP),NDXPUT($IOP),NDXRTE($IOP)        
.END                                                                            
.SAVE SNAP                                                                      
C THE START AND END PERIODS FOR SNAPSHOT OUTPUT OR DISPLAY                      
      COMMON /SNAP/ BEGSNP($IOP), ENDSNP($IOP), LENSNP($IOP),                   
     1 LOCBEG($IOP), LOCEND($IOP), NUMGRP($IOP)                                 
.END                                                                            
.SAVE TIMER                                                                     
C                                                                               
C  THIS COMMON BLOCK IS USED TO TIME THE OPERATIONS                             
      COMMON/TIMER/ TIM($IOP),TIMTR,TIMDR                                       
.END                                                                            
.SAVE MSGPR                                                                     
C  THIS COMMON IS USED TO GENERATE ERROR MESSAGES                               
      COMMON /MSGPR/ LEVPRT,KINFO,KWARN,KFATAL,KCAT,KBLNK,MSGVAL(10)            
.END                                                                            
.SAVE OUTCIO                                                                    
C  THIS COMMON IS USED TO CONTROL DATA FLOW                                     
      COMMON /OUTCIO/ ISTOP,NCRM,NCFL,LSVOP,LSVLST,LOCLST($IOP),                
     1 MVFLAG($IOP)                                                             
.END                                                                            
.SAVE DRPRNT                                                                    
      COMMON/DRPRNT/IPR(9),NUMDMP,LENDMP,IDUMP(80),IYES,INO                     
.END                                                                            
.SAVE INCOM                                                                     
      INTEGER SNPBRK, TOTOPS , OVRLAP, THISOP , BITCHR , BITNSU                 
      INTEGER EXDATE, EXTIME, PRDATE, PRTIME                                    
      COMMON SPACE($ISPACE), OVRFLO, LENSP,                                     
     1 LENBUF($IOP),LENCA($IOP),LENDAT($IOP),LENSAV($IOP),LENSCR,               
     2 LOCBUF($IOP),LOCCA($IOP),LOCDAT($IOP),LOCSAV($IOP),LOCSCR                
      DIMENSION  CON($ISPACE), SAV($ISPACE), BUF($ISPACE)                       
     -, DATA($ISPACE), SCR($ISPACE)                                             
      DIMENSION ICON($ISPACE),ISAV($ISPACE),IBUF($ISPACE)                       
     -,IDATA($ISPACE),ISCR($ISPACE)                                             
      EQUIVALENCE (SPACE(1), CON(1), SAV(1), BUF(1), DATA(1), SCR(1))           
      EQUIVALENCE (SPACE(1),ICON(1),ISAV(1),IBUF(1),IDATA(1),ISCR(1))           
      COMMON /OP/ GAPFLG, GAPVAL, INDCYC($IOP), THISOP, LASTOP,                 
     1 LENCYC($IOP),NAMEOP($IOP), NCDO, NCYNOW($IOP), NUMCAL($IOP),             
     2 NUMCYC($IOP),OVRLAP($IOP), VALIV($IOP)                                   
      COMMON /ERROR/ IABORT, NSTAGE, IERR, NUMERR($IOP)                         
      COMMON /IOUNIT/ KCHECK, KDUMP, KERR, KFICHE, KFILM, KPROC, KPRINT         
      COMMON /CYCVAR/ BEGIV, ENDIV, DELIV, IVDIM, LABIV(6), SCALIV(6),          
     1 BEGPER(7), ENDPER(7), LENPER, FLUSHP, BITCHR, BITNSU,BITIV,MXCHR         
     2,EXDATE(3),EXTIME(3),PRDATE(3),PRTIME(3),MACHIN,JOBIDS(10),NSUIDS         
      COMMON /MSGPR/ LEVPRT,KINFO,KWARN,KFATAL,KCAT,KBLNK,MSGVAL(10)            
      COMMON /GETPUT/NDXGET($IOP),NDXINR($IOP),NDXPUT($IOP),NDXRTE($IOP)        
      COMMON /FLOW/ INOP1,ITYPOP($IOP),JOBS,JOBSTP,KORD($IOP), LENFIX,          
     1 LENTOT($IOP), LINDCY($IOP), MINCY($IOP), NCASE,   NCYEND($IOP),          
     2 NCYOLD($IOP),NUMOPT, NUMREM($IOP), NUMOPS, NXTTOP($IOP),SNPBRK,          
     3 TOTOPS                                                                   
      COMMON /OUTCIO/ ISTOP,NCRM,NCFL,LSVOP,LSVLST,LOCLST($IOP),                
     1 MVFLAG($IOP)                                                             
      COMMON/INPUT2/INSV($IOP)                                                  
      COMMON/DRPRNT/IPR(9),NUMDMP,LENDMP,IDUMP(80),IYES,INO                     
      COMMON /VECLEN/ LENCA1,LENOF5,LENVEC($IOP),NSUSAV                         
.END                                                                            
.SAVE RATAB                                                                     
      COMMON /RATAB/ LRATE($IOP,$NVAR),LISV($NVAR),NTYPE($IOP),LSTLEN           
.END                                                                            
.SAVE RANDOM                                                                    
V     COMMON/RNDM/KFF,KFILE,IPOS($NFILE,3),LENREC                               
H     COMMON/RNDM/NAMEF,KFILE,IPOS($NFILE,2)                                    
M     COMMON/RNDM/KFF,KFILE,IPOS($NFILE,3),LENREC                               
G     COMMON/RNDM/NAMEF,KFILE,IPOS($NFILE,2)                                    
.END                                                                            
C **********************************************************************        
C                                                                               
C UNICOS MODS: PWRT CALLS REPLACED  (7/90 -CC)
C
.SAVE CALCOM                                                                    
      INTEGER CONSN                                                             
      COMMON/CAL/NAMVAR,IPSOU(9),LDO,INDPUT,INDGET,LRATE,LRTSOU(9),             
     1           CONS1,CONSN,CONVERT                                            
.END                                                                            
.SAVE LINPR                                                                     
       NLIN=50                                                                  
       IY= IY - 15                                                              
       IXK = IXK + 1                                                            
       IF(IXK.EQ.NLIN)                                                          
        CALL FRAME                                                              
        IY= 1000                                                                
        IXK=0                                                                   
       END IF                                                                   
.END                                                                            
.SAVE D99999                                                                    
        INDPUT=INDPUT -1                                                        
        DO(I=1,LDO)                                                             
          DATA(INDPUT+I)= 99999.                                                
        END DO                                                                  
.END                                                                            
.SAVE FTFHERR                                                                   
      COMMON/PWRITE/ARAY(20),IY,IXK                                             
C                                                                               
C TFHERR = FUNCTION TO COMPUTE DEICED ROSEMOUNT TOTAL TEMPERATURE               
C ERROR (C) AS A FUNCTION OF Z,WHERE Z IS MACH NUMBER ADJUSTED                  
C BY DENSITY RATIO (STP DRY AIR REFERENCE)                                      
C     TFHERR(Z) = ((-.382943*Z+23.603347)*Z-14.912448)*Z+2.454213               
C MODEL 102U SN 27581 SINGLE ELEMENT -- SABRELINER ONLY (7JUN1985)              
C                                                                               
C  THE FOLLOWING CORRECTION IS APPLICABLE ONLY TO SENSOR MODEL 102DBICB,        
C  SN 34260, DUAL ELEMENT.  THE VALUE OF THE FUNCTION BECOMES CONSTANT          
C  AT Z=0.275, ROUGHLY QUEEN AIR MAXIMUM Z VALUES.  FUNCTION DERIVED            
C  FROM MEAN DATA FOUND ON PAGES 17-18 OF ROESMOUNT TOTAL TEMPERATURE           
C  SENSORS TECHNICAL REPORT 5755 BY STICKNEY, SHEDLOV AND THOMPSON, MAY         
C  1975.                                                                        
C  THIS IS A DUAL ELEMENT SENSOR.                                               
C  THE FOLLOWING TEST IS GOOD FOR BOTH QUEEN AIR AND KING AIR AS PER            
C  KEITH GRIFFITH AND DICK FRIESEN OF RAF, ATD, NCAR ON FEB. 21, 1984           
C  NEW CORRECTION - 5JUN1985 K. GRIFFITH MEMO                                   
C     IF(Z.GE. 0.3) TFHERR(Z)=0.3                                               
C                                                                               
E     TFHERR(Z) = 10.0**(-1.7841*(ALOG10(Z))-1.4025)                            
F     TFHERR(Z) = 10.0**(-1.7841*(ALOG10(Z))-1.4025)                            
Q     TFHERR(Z) = 10.0**(-1.7841*(ALOG10(Z))-1.4025)                            
S     TFHERR(Z) = 10.0**(-1.7244*(ALOG10(Z))-1.5989)                            
.END                                                                            
.SAVE ZLOG                                                                      
        IF(ZEE .LT. 0.1) ZEE = 0.99                                             
        ZFUN = TFHERR(ZEE)                                                      
.END                                                                            
.SAVE WTFHERR                                                                   
      IF(NSTAGE.EQ.4)                                                           
        WRITE(KPROC,203) NAMVAR                                                 
        WRITE(KPRINT,203) NAMVAR                                                
  203   FORMAT(' CALIB: ',A8,' USES TFHERR FUNCTION -- ',                       
E    1' TFHERR(Z) = 10.0**(-1.7841*(ALOG10(Z))-1.4025)    ')                    
F    1' TFHERR(Z) = 10.0**(-1.7841*(ALOG10(Z))-1.4025)    ')                    
Q    1' TFHERR(Z) = 10.0**(-1.7841*(ALOG10(Z))-1.4025)    ')                    
S    1' TFHERR(Z) =  10.0**(-1.7244*(ALOG10(Z))-1.5989)   07MAY1985 ')          
        ENCODE(102,203,ARAY) NAMVAR                                             
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1)                           
        IY = IY -15                                                             
        IXK = IXK + 1                                                           
        IF(IXK.EQ.NLIN)                                                         
         CALL FRAME                                                             
         IY= 1000                                                               
         IXK=0                                                                  
        END IF                                                                  
      END IF                                                                    
.END                                                                            
.SAVE FRECFRN                                                                   
      COMMON/PWRITE/ARAY(20),IY,IXK                                             
C   RECFRN = RECOVERY FACTOR FOR NEW REVERSE FLOW TEMP - 1982 (BY KEITH G.)     
C     RECFRN(Q) = 0.8571395945 -.004064675726 *Q                                
C** RECOVERY FACTORS RECOMPUTED FOR REVERSE FLOW PROBE MOUNTED ON L.H.          
C   PYLON - FROM 12/17/86 TOWER FLY-BY - ED BROWN (FEB 24,1987)                 
      RECFRN(Q) = 0.8744 - .002003*Q                                            
.END                                                                            
.SAVE WRECFRN                                                                   
      IF(NSTAGE.EQ.4 .AND. IX.EQ.1)                                             
        WRITE(KPROC,203) NAMVAR                                                 
  203 FORMAT(' CALIB: ',A8,' USES RECOVERY FACTOR FUNCTION -- ',                
     1' RECFRN(Q)=.8744-.002003*Q           24FEB1987 ')                        
C    1' RECFRN(Q) = .8571395945 - .004064675726 * Q   ')                        
        ENCODE(97,203,ARAY) NAMVAR                                              
        IY = IY-5                                                               
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,97,0,0,-1)                           
         IY= IY - 15                                                            
         IXK = IXK + 1                                                          
         IF(IXK.EQ.NLIN)                                                        
          CALL FRAME                                                            
          IY= 1000                                                              
          IXK=0                                                                 
         END IF                                                                 
      END IF                                                                    
.END                                                                            
.SAVE FHSSATK                                                                   
      COMMON/PWRITE/ARAY(20),IY,IXK                                             
C** HSSATK = FIXED VANE CALIBRATION FUNCTION IN DEGREES, WHERE F IS             
C   IN GRAMS AND Q IS IN MILLIBARS.                                             
C** HSSATK(F,Q) = DEICED VANE CALIB FCN -- F=GM, Q=MB 23JAN 79                  
      HSSATK(F,Q) = F/Q*(0.342263 - 0.000080*(F/Q)**2)                          
.END                                                                            
.SAVE WHSSATK                                                                   
      IF(NSTAGE.EQ.4)                                                           
       WRITE(KPROC,203) NAMVAR                                                  
  203 FORMAT(' CALIB: ',A8,' USES HSSATK FUNCTION--',                           
     1' HSSATK(F,Q) = F/Q*(0.342263 - 0.000080*(F/Q)**2)              ')        
       ENCODE(102,203,ARAY) NAMVAR                                              
       IY = IY-5                                                                
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1)                           
       NLIN=55                                                                  
       IY= IY - 15                                                              
       IXK = IXK + 1                                                            
       IF(IXK.EQ.NLIN)                                                          
        CALL FRAME                                                              
        IY= 1000                                                                
        IXK=0                                                                   
       END IF                                                                   
      END IF                                                                    
.END                                                                            
.SAVE FRECFKN                                                                   
      COMMON/PWRITE/ARAY(20),IY,IXK                                             
C** RECOVERY FACTORS RECOMPUTED FOR K PROBE ON BOOM TIP                         
C   FROM 12/17/86 TOWER FLY-BY - ED BROWN (FEB 24,1987)                         
      RECFKN(Q) = 1.0670 - .001586*Q                                            
.END                                                                            
.SAVE WRECFKN                                                                   
      IF(NSTAGE.EQ.4 .AND. IX.EQ.1)                                             
        WRITE(KPROC,203) NAMVAR                                                 
  203 FORMAT(' CALIB: ',A8,' USES RECOVERY FACTOR FUNCTION -- ',                
     1' RECFRN(Q)=1.067-.001586*Q           24FEB1987 ')                        
        ENCODE(97,203,ARAY) NAMVAR                                              
        IY = IY-5                                                               
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,97,0,0,-1)                           
         IY= IY - 15                                                            
         IXK = IXK + 1                                                          
         IF(IXK.EQ.NLIN)                                                        
          CALL FRAME                                                            
          IY= 1000                                                              
          IXK=0                                                                 
         END IF                                                                 
      END IF                                                                    
.END                                                                            
.SAVE FESUBT                                                                    
      COMMON/PWRITE/ARAY(20),IY,IXK                                             
C ESUBT FUNCTION IMPLEMENTS VAPOR PRESR EQN COMPUTED BY METHOD OF               
C PAUL R. LOWE (JOURNAL OF APPLIED METEOROLOGY, VOL 16,                         
C PP 100-103, 1977)                                                             
      ESUBT(T)=6.107799961+T*(0.4436518521+T*(0.01428945805+T*(2.6506484        
     X71E-4+T*(3.031240396E-6+T*(2.034080948E-8+T*6.136820929E-11)))))          
.END                                                                            
.SAVE WESUBT                                                                    
      IF(NSTAGE.EQ.4)                                                           
        WRITE(KPROC,203) NAMVAR                                                 
        WRITE(KPROC,204)                                                        
  203 FORMAT(' CALIB: ',A8,' USES ESUBT FUNCTION --',                           
     1' ESUBT(T)=6.107799961+T*(.4436518521+T*(.01428945805+T*        ')        
  204 FORMAT(' (2.650648471E-4+T*(3.031240396E-6+T*',                           
     2' (2.034080948E-8+T*6.136820929E-11)))))                        ')        
        ENCODE(102,203,ARAY) NAMVAR                                             
        IY = IY-5                                                               
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1)                           
        IY= IY - 15                                                             
        IXK= IXK+1                                                              
        ENCODE(111,204,ARAY)                                                    
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,111,0,0,-1)                           
       NLIN=55                                                                  
       IY= IY - 15                                                              
       IXK = IXK + 1                                                            
       IF(IXK.EQ.NLIN)                                                          
        CALL FRAME                                                              
        IY= 1000                                                                
        IXK=0                                                                   
       END IF                                                                   
      END IF                                                                    
.END                                                                            
C *********************************************************************
.AC   A
.DE   B
.AC   E
.DE   F
.DE   Q
.DE   R
.DE   S
.AC   T
.DE   W
.AC   Z
C
C INCLUDE FOLLOWING 2 TO SATISFY COMPILER PROCESS IN SR SATKSLP, CALSUBG
C FOR KINGAIR 312 PROJECTS, GR=0.079
.SAVE FXGR
      COMMON/PWRITE/ARAY(20),IY,IXK
.END
.SAVE WXGR
      IF(NSTAGE.EQ.4)
        WRITE(KPROC,203) NAMVAR
        WRITE(KPRINT,203) NAMVAR
  203 FORMAT(' CALIB: ',A8,' USES GR = 0.079       ')
        ENCODE(39,203,ARAY) NAMVAR
        IY = IY-5
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,39,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
.SAVE FPCOR
      COMMON/PWRITE/ARAY(20),IY,IXK
C PCOR  = STATIC CORRECTION FOR BOOM (MB)             ELECTRA  05JUN85
      PCORB(QCX08)= -0.736  - 0.127 *QCX08
 
C PCORG = STATIC CORRECTION FUNCTION FOR GUST PROBE (MB)
C** ACT.'W' FOR ROSEMOUNT 858 DIFFERENTIAL PRESSURE PROBE USED **
W     PCORG(QCX12)=(-.0907)*QCX12 - 0.19
C** ACT. 'Z' FOR FIXED VANE GUST PROBE
Z     PCORG(QCX08)= -0.736  - 0.127 *QCX08
 
C PCORD = STATIC CORRECTION FOR DIGITAL (MB)       ELECTRA    13FEB86
      PCORD(QCX08)= .366    - 0.0182 * QCX08
c      PCORD(QCX08)= -0.155  - 0.01485*QCX08
C
C PCORW = STATIC CORRECTION FOR WING (MB)            ELECTRA   05JUN85
      PCORW(QCX08)= 0.517   - 0.0202 *QCX08
.END
C
.SAVE WPCOR
      IF(NSTAGE.EQ.4)
       IF(NAMVAR.EQ.NPSBC .OR. NAMVAR.EQ.NQCBC)
 2034   FORMAT(' CALIB: ',A8,' USES PCORB FUNCTION-- ',
     E' PCORB (QCX08)=-0.736-0.127*QCX08            ELECTRA   05JUN85')
        ENCODE(102,2034,ARAY) NAMVAR
        WRITE(KPROC,2034) NAMVAR
        WRITE(KPRINT,2034) NAMVAR
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1) 
       OR IF(NAMVAR.EQ.NQCGC)
 2031   FORMAT(' CALIB: ',A8,' USES PCORG FUNCTION --',
W    W' PCORG(QCX12)= (-.0907)*QCX12 - 0.19                    29NOV83')
Z    Z' PCORG(QCX08)= -0.736  - 0.127 *QCX08                          ')
        ENCODE(102,2031,ARAY) NAMVAR
        WRITE(KPROC,2031) NAMVAR
        WRITE(KPRINT,2031) NAMVAR
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1) 
       OR IF(NAMVAR.EQ.NPSFDC)
 2032   FORMAT(' CALIB: ',A8,' USES PCORD FUNCTION-- ',
     E' PCORD(QCX08)= .366 -0.0182 * QCX08          ELECTRA   17JUN88')
c     E' PCORD(QCX08)=-0.155-0.01485*QCX08           ELECTRA   13FEB86')
        ENCODE(102,2032,ARAY) NAMVAR
        WRITE(KPROC,2032) NAMVAR
        WRITE(KPRINT,2032) NAMVAR
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1)   
       OR IF(NAMVAR.EQ.NPSFC.OR.NAMVAR.EQ.NPSWC.OR.NAMVAR.EQ.NQCWC.OR.
     1    NAMVAR.EQ.NQCFC )
 2033   FORMAT(' CALIB: ',A8,' USES PCORW FUNCTION-- ',
     E' PCORW(QCX08)=0.517 -0.0202*QCX08            ELECTRA   05JUN85')
        ENCODE(102,2033,ARAY) NAMVAR
        WRITE(KPROC,2033) NAMVAR
        WRITE(KPRINT,2033) NAMVAR
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1)
       END IF
         IY= IY - 15
         IXK = IXK + 1
         IF(IXK.EQ.50)
          CALL FRAME
          IY= 1000
          IXK=0
         END IF
      END IF
.END
.SAVE FPCORR
C     COMMON/PWRITE/ARAY(20),IY,IXK
C
C ERIK MILLER MEMO OF 10JUN1988
      PCORR(QCX) = .366 - .0182*QCX
.END
C
.SAVE WPCORR
      IF(NSTAGE.EQ.4)
  302 FORMAT(' CALIB: ',A8,' USES PCORR FUNCTION --',
     1' PCORR(QCX)= .366 - .0182 * QCX              ELECTRA   17JUN88')
        ENCODE(102,302,ARAY) NAMVAR
        WRITE(KPROC,302) NAMVAR
        WRITE(KPRINT,302) NAMVAR
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,102,0,0,-1)
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
C
.SAVE FXGRRK
      COMMON/PWRITE/ARAY(20),IY,IXK
C FOR 308 ELECTRA RADOME PROJECTS USES CONSTANT AKRAL IN SUB SAKRD      XGR 7
.END
.SAVE WXGRRK
C ERIK MILLER MEMO OF 10JUN1988
      AKRAL = 0.07155
      BIAS  = .4095
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,203) NAMVAR,AKRAL,BIAS
        WRITE(KPRINT,203) NAMVAR,AKRAL,BIAS
  203 FORMAT(' CALIB: ',A8,' USES AKRAL= ',F9.4,' BIAS= ',F9.4)
        ENCODE(54,203,ARAY) NAMVAR,AKRAL,BIAS
        IY = IY-5
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,54,0,0,-1) 
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
.SAVE FXGRRS
      COMMON/PWRITE/ARAY(20),IY,IXK
C FOR 308 ELECTRA RADOME PROJECTS USES CONSTANT BKRAL IN SUB SSSRD XGR 7
.END
.SAVE WXGRRS
C ERIK MILLER MEMO OF 10JUN1988
      BKRAL = 0.06577
      BIAS  = .0375
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,203) NAMVAR,BKRAL,BIAS
        WRITE(KPRINT,203) NAMVAR,BKRAL,BIAS
  203 FORMAT(' CALIB: ',A8,' USES BKRAL= ',F9.4,' BIAS= ',F9.4)
        ENCODE(54,203,ARAY) NAMVAR,BKRAL,BIAS
        IY = IY-5
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,54,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
.SAVE FXGRRAB
      COMMON/PWRITE/ARAY(20),IY,IXK
C FOR 308 RADOME PROJECTS USE CONSTANT AKRAL FOR ATK3/BETA3 IN SQCRCXGR 7
.END
.SAVE WXGRRA
C ERIK MILLER MEMO OF 10JUN1988
      AKRAL = 0.0715
      ABIAS = .4095
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,303) NAMVAR,AKRAL,ABIAS
        WRITE(KPRINT,303) NAMVAR,AKRAL,ABIAS
  303 FORMAT(' CALIB: ',A8,' ATK3 AKRAL= ',F9.4,', ATK3 BIAS= ',F9.4)
        ENCODE(60,303,ARAY) NAMVAR,AKRAL,ABIAS
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,60,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
.SAVE WXGRRB
C ERIK MILLER MEMO OF 10JUN1988
      BKRAL = 0.06577
      BBIAS = .0375
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,204) NAMVAR,BKRAL,BBIAS
        WRITE(KPRINT,204) NAMVAR,BKRAL,BBIAS
  204 FORMAT(' CALIB: ',A8,' BETA3 BKRAL=',F9.4,', BETA3 BIAS= ',F9.4)
        ENCODE(61,204,ARAY) NAMVAR,BKRAL
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,61,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
C*********************************************************************
C MODS TO SQCRC PUT IN ON 11/13/89 (A. SCHANOT'S MEMO)
C*********************************************************************
C-----------------------------------------------------------------------
C  THIS FILE CONTAINS THE FOLLOWING ELECTRA 308 RADOME CALIBRATION SUBS:
C--------------------------------------------------------------------------
C SUB NAME| REQUIRED VARIABLES    -NO|CONSTANT| DERIVED VARIABLES
C--------------------------------------------------------------------------
C SAKRD   |ADIFR;QCRC               2|        |AKRD
C--------------------------------------------------------------------------
C SATK3   |ADIFR;QCR                2|        |ATK3
C--------------------------------------------------------------------------
C SBETA3  |BDIFR;QCR                2|        |BETA3
C--------------------------------------------------------------------------
C SPSXC   |PSX;QCR                  2|        |PSFDC
C--------------------------------------------------------------------------
C SQCR    |PTR;PSXC                 2|        |QCR
C--------------------------------------------------------------------------
C SQCRC   |QCR;ADIFR;BDIFR          3|        |QCRC
C--------------------------------------------------------------------------
C SQCFC   |QCF                      3|        |QCFC
C--------------------------------------------------------------------------
C SSSRD   |BDIFR;QCRC               2|        |SSRD
C--------------------------------------------------------------------------
C SSSRD1  |BDIFR;BREFR;BREFL        2|        |SSRD1
C--------------------------------------------------------------------------
      SUBROUTINE SAKRD
C***********************************************************  SAKRD
C** RADOME ATTACK ANGLES (DEG) -- ELECTRA 308
C** REQUIRES:1-ADIFR;2-QCRC
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
.USE  FXGRRK
.USE  WXGRRK
      IRQC1 = LRTQC1/LRATE
      IPADIFR =IPSOU(1 ) -1
      IPQCRC  =IPSOU(2 ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       IQC1= (IX-1)*IRQC1
       QC1 = DATA(IPQC1+IQC1)
       ADIFR = DATA(IPADIFR +IX)
       QCRC = DATA(IPQCRC +IX)
       IF(ADIFR.EQ.99999. .OR. QCRC.EQ.99999.)
        DATA(INDPUT+IX) =99999.
        GO TO 99
       END IF
C PER E. MILLER'S MEMO OF JUN. 10,1988
       ATKR = ((ADIFR/QCRC)+BIAS) / AKRAL
       IF(CONS1.NE.99999.) ATKR = ATKR + CONS1
       IF(QC1.LE.10.) ATKR = 0.0
       DATA(INDPUT+IX) = ATKR
   99  CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SATK3
C***********************************************************  SATK3
C** ATTACK(3)  (RADOME)
C** REQUIRES:1-ADIFR;2-QCR
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRAB
.USE  WXGRRA
      IPDR =IPSOU(1  ) -1
      IPQR =IPSOU(2  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       ADIFR = DATA(IPDR +IX)
       QCR = DATA(IPQR +IX)
       IF(ADIFR.EQ.99999. .OR. QCR.EQ.99999. )
        DATA(INDPUT+IX) =99999.
        GO TO 99
       END IF
C  ERIK MILLER'S MEMO OF 10JUN1988
C the following calculation also appears in SR SQCRC and SR SQCFC
       ATK3 = ABS ((ADIFR/QCR) + ABIAS)/ AKRAL
       DATA(INDPUT+IX) = ATK3
   99  CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SBETA3
C**********************************************************  SBETA3
C** SIDESLIP(3)  (RADOME)   (MB)
C** REQUIRES:1-BDIFR;2-QCR
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRAB
.USE  WXGRRB
      IPBR =IPSOU(1  ) -1
      IPQR =IPSOU(2  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       BDIFR = DATA(IPBR +IX)
       QCR = DATA(IPQR +IX)
       IF(BDIFR.EQ.99999. .OR. QCR.EQ.99999. )
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
C  ERIK MILLER'S MEMO OF 10JUN1988
C the following calculation also appears in SR SQCRC and SR SQCFC
        BETA3 = ABS (( BDIFR/QCR) + BBIAS)/ BKRAL
        DATA(INDPUT+IX) = BETA3
   99   CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SQCRC
C***********************************************************  SQCRC
C** CORRECTED RADOME DYNAMIC PRESSURE (MB) -- ELECTRA 308
C** REQUIRES:1-QCR;2-ADIFR;3-BDIFR
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRAB
.USE  FPCORR
.USE  WPCORR
.USE  WXGRRA
.USE  WXGRRB
      RAD = 0.01745329
      IPQCR =IPSOU(1  ) -1
      IPAR =IPSOU(2  ) -1
      IPBR =IPSOU(3  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       QCR = DATA(IPQCR +IX)
       ADIFR= DATA(IPAR +IX)
       BDIFR = DATA(IPBR +IX)
       IF(QCR.EQ.99999. .OR. ADIFR.EQ.99999. .OR. BDIFR.EQ.99999.)
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
       IF(QCR.LE.10.) QCR = 10.0
C the following 2 calculations also appear in SR SATK3, SBETA3
       ATK3 = ABS(( ADIFR/QCR ) + ABIAS) / AKRAL
       BETA3= ABS(( BDIFR/QCR ) + BBIAS) / BKRAL
C
       SATK3=SIN(ATK3*RAD)
       SBETA3=SIN(BETA3*RAD)
C  ERIK MILLER'S MEMO OF 10JUN1988
       BQCRC=(1.-2.25*SATK3**2)*(1.-2.25*SBETA3**2)
C      IF(BQCRC.EQ.0.0) BQCRC=0.0001
C      QCRC= QCR/BQCRC
C 11/13/89 Mods requested by Allen Schanot (memo of 11/13/89)
C
       QCRC= (QCR*(1.02633-0.00819*ATK3))/BQCRC
C 08APR1986 - AL SCHANOT
       QCRC = QCRC - PCORR(QCR)
       IF(QCRC.LT.10.) QCRC = 10.0
       IF(CONS1.NE.99999.) QCRC=QCRC+CONS1
       DATA(INDPUT+IX) = QCRC
   99  CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SQCFC
C***********************************************************  SQCFC
C** PROJECT 8-850 PROTOTYPE
C** CORRECTED RADOME DYNAMIC PRESSURE (FUSELAGE: MB) -- ELECTRA 308
C** REQUIRES:1-QCF
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE FXGRRAB
.USE  FPCORR
.USE  WPCORR
      IPQCF =IPSOU(1  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       QCF = DATA(IPQCF +IX)
       IF(QCF.EQ.99999.)
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
       IF(QCF.LE.10.) QCF = 10.0
C
C  ERIK MILLER'S MEMO OF 10JUN1988
       QCFC = QCF - PCORR(QCF)
       IF(QCFC.LT.10.) QCFC = 10.0
       IF(CONS1.NE.99999.) QCFC=QCFC+CONS1
       DATA(INDPUT+IX) = QCFC
   99  CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SSSRD1
C***********************************************************  SSRD1
C** PROJECT 8-850 PROTOTYPE
C** RADOME SIDESLIP ANGLE (DEG) --  ELECTRA 308
C** REQUIRES:1-BDIFR;2-BREFR;3-BREFL
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRS
.USE  WXGRRS
      IPBD = IPSOU(1) -1
      IPBR = IPSOU(2) -1
      IPBL = IPSOU(3) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       BDIFR = DATA(IPBD +IX)
       BREFR = DATA(IPBR+IX)
       BREFL = DATA(IPBL+IX)
        IF(BDIFR.EQ.99999. .OR. BREFR.EQ.99999. .OR. BREFL.EQ.99999.)
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
C SSRD1 comes out in radians; convert to degrees after calibration
       SSLPR=0.5*ATAN(0.5543 * (BDIFR/(BREFR+BREFL)))
       SSLPR=SSLPR*180.0/3.141592654
       IF(CONS1.NE.99999.) SSLPR = SSLPR + CONS1
       DATA(INDPUT+IX) = SSLPR
   99  CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SPSFDC
C***********************************************************  SPSFDC
C** CORRECTED STATIC PRESSURE (FUSELAGE,FUSELAGE DIGITAL,WING) (MB)
C** REQUIRES:1-PSX;2-QCX
C
C Modified to use new Pressure Correction for PSFDC only, Proj. 8-850
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
      DATA NPSFDC/8HPSFDC   /
.USE FXGRRAB
.USE  FPCORR
.USE  WPCORR
      IPPSX =IPSOU(1  ) -1
      IPQCX  =IPSOU(2  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       PSX   = DATA(IPPSX   +IX)
       QCX   = DATA(IPQCX   +IX)
       IF(PSX.EQ.99999. .OR. QCX.EQ.99999. )
        DATA(INDPUT+IX) =99999.
        GO TO 99
       END IF
       PSXC= PSX + PCORR(QCX)
       IF( QCX .LT. 10.)PSXC=PSX
       IF (PSXC .LT.50.)PSXC = 50.
       DATA(INDPUT+IX)=PSXC
   99 CONTINUE
      END DO
      RETURN
      END
C  This template file can be used as a reference when setting up a new
C   project which requires customization by adding new derived variables
C   There are sections for each derivation level.  Generally you cannot go
C   wrong by placing new variables in level 8.
C
C  The order of some calculations was changed in 1991 when the cryogenic
C   hygrometer was used as a reference for moisture variables.  (There is
C   no reason to change it, at present.)
C
C  Originally this caladd file came from 1990-876 HaRP project and was
C  modified by RLR for 1991-739 Smith/Kok project (to change the CALIB1
C  subroutine order of calculations)
C
C-------------------------------------------------------------------------------
C  Existing CALIB1 levels of derivation and the variables derived in each level
C-------------------------------------------------------------------------------
C Variable names:                                 Derivation subroutine:
C -------------------------------------- Level 1 -------------------------------
C DPC DPBC DPTC DPGEC DPCVC                       SDPC
C GSF                                             SGSF
C IRBC IRTC TPYGC2                                SIRTBC
C POSDF                                           SPOSDF
C PSFC PSBC PSWC PSFDC PSFDC20                    SPSXC
C QCWC QCGC QCFC QCBC QCDC QCFC20                 SQCXC
C QCFC (ELECTRA PROJECT ONLY 308)                 SQCFC
C QCRC                                            SQCRC
C ATOPH                                           SATOPH
C TEPC                                            STEPC
C -------------------------------------- Level 2 -------------------------------
C AKFXL AKFXR SSFXB SSFXT                         SABFIX
C AKDF SSDF                                       SATKSLP
C ATRF                                            SATRF
C ATB ATF ATKP ATW ATRW ATFR                      SATX
C ATB1 ATR3 ATR6 ATRE ATKPR ATF20                 SATX
C ATBH ATFH ATWH                                  SATXH
C IAS                                             SIAS
C PALT PALT20                                     SPALT
C PALTF                                           SPALTF
C TASB TASF TASG TASW TASR TASD                   STASX
C BMACH FMACH RMACH GMACH WMACH                   SXMACH
C BMACH2 FMACH2 RMACH2 GMACH2 WMACH2              SXMACH2
C -------------------------------------- Level 3 -------------------------------
C CONC2C                                          SCONC2C
C CONC2P                                          SCONC2P
C DO3C                                            SDO3C
C COC                                             SCOC
C SCLWC                                           SSCLWC
C DVALU                                           SDIF
C CRYOC                                           SCRYOC
C RHORF                                           SRHORF
C CNC                                             SCNC
C DMEC                                            SDMEC
C GUSTO                                           SGUST
C LWCC CLWC                                       SLWCC
C PLWCC                                           SPLWCC
C PSURF                                           SPSURF
C RHODT RHODB GERHOTD RHODGE RHOCR                SRHOTD
C RHOCD                                           SRHOTD
C THETA THETAK                                    STHETA
C TEO3C                                           STEO3C
C -------------------------------------- Level 4 -------------------------------
C MR                                              SMR
C SPHUM                                           SSPHUM
C RHUM                                            SRHUM
C AKRD                                            SAKRD
C DLA1                                            SDLA
C SSRD                                            SSSRD
C -------------------------------------- Level 5 -------------------------------
C THETAE                                          STHETAE
C THETAV                                          STHETAV
C PLCL                                            SPLCL
C TLCL                                            STLCL
C TVIR                                            STVIR
C GUSTR GUSTD                                     SGUST
C CVI                                             SCVI
C -------------------------------------- Level 6 -------------------------------
C DIF                                             SDIF
C NETT                                            SSUM2
C NETV                                            SDIF
C NETI                                            SDIF
C SUM                                             SSUM2
C RATIO                                           SRATIO
C TRKI                                            STRKI
C ASAS                                            SASAS
C FSSP                                            SFSSP
C X200                                            SX200
C X260                                            SX260
C Y200                                            SY200
C -------------------------------------- Level 7 -------------------------------
C DA                                              SDA
C LWCCF                                           SLWCCF
C PLWCCF                                          SPLWCCF
C ---------------------------------- ----------- -------------------------------
.SAVE  ADDNVAR
C ---------------------------------- ----------- -------------------------------
C ** NEW VARIABLE NAMES TO BE ADDED HERE
C     DATA NXSO2C/8HXSO2C   /, NCNCC/8HCNCC    /
C    Project ASTEX/MAGE new derived variables:   (4 September 1992 Ron Ruth)
      DATA NXO3FSC/8HXO3FSC  /, NTOWAT /8HTOWAT   /, NMRLA  /8HMRLA    /
      DATA NXATO  /8HXATO    /
      DATA NXCVDPC/8HXCVDPC  /, NRHOCV /8HRHOCV   /
.END
.SAVE  ADDV1
C ---------------------------------- ----------- -------------------------------
C ** NEW LEVEL 1 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C      OR IF (NAMVAR.EQ.NXXXXXX)
C       CALL SXXXXXX
C ** NEW LEVEL 1 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C
C------------------------------------------------------------------- XCVDPC
C ** CVI SAMPLE CORRECTED DEW POINT TEMPERATURE (C)    
       OR IF (NAMVAR.EQ.NXCVDPC)
        CALL SDPC
C------------------------------------------------------------------- XATO
C** OPHIR-III AMBIENT TEMPERATURE (C)
       OR IF (NAMVAR.EQ.NXATO)
        CALL SXATO
.END
.SAVE  ADDV2
C ---------------------------------- ----------- -------------------------------
C ** NEW LEVEL 2 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C      OR IF (NAMVAR.EQ.NXXXXXX)
C       CALL SXXXXXX
C ---------------------------------- ----------- -------------------------------
C **  XSO2C
C     OR IF (NAMVAR.EQ.NXSO2C )
C      CALL SXSO2C
C **  CNCC
C     OR IF (NAMVAR.EQ.NCNCC )
C      CALL SCNCC
.END
.SAVE  ADDV3
C ---------------------------------- ----------- -------------------------------
C ** NEW LEVEL 3 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C      OR IF (NAMVAR.EQ.NXXXXXX)
C       CALL SXXXXXX
.END
.SAVE  ADDV4
C-----------------------------------------------------------------------
C ** NEW LEVEL 4 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C      OR IF (NAMVAR.EQ.NXXXXXX)
C       CALL SXXXXXX
.END
.SAVE  ADDV5
C ---------------------------------- ----------- -------------------------------
C ** NEW LEVEL 5 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C     OR IF (NAMVAR.EQ.NXXXXXX)
C      CALL SXXXXXX
      OR IF (NAMVAR.EQ.NRHOCV)
       CALL SRHOTD
.END
.SAVE  ADDV6
C ---------------------------------- ----------- -------------------------------
C ** NEW LEVEL 6 DERIVATION VARIABLE NAMES TO BE ADDED HERE
      OR IF (NAMVAR.EQ.NXXXXXX)
       CALL SXXXXXX
.END
.SAVE  ADDV7
C ---------------------------------- ----------- -------------------------------
C ** NEW LEVEL 7 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C------------------------------------------------ TPL
C** TEMPERATURE PROBE - Paul Lawson
C   Example:  HaRP project  Sept. 1990   -cc
C
C     OR IF(NAMVAR.EQ.NTPL)
C      CALL  STPL
.END
.SAVE  ADDV8
C-----------------------------------------------------------------------
C ** NEW LEVEL 8 DERIVATION VARIABLE NAMES TO BE ADDED HERE
C**NEW LEVEL**NEW LEVEL**NEW LEVEL**NEW LEVEL**NEW LEVEL**NEW LEVEL**
C***************************************************************************
C****************       LEVEL EIGHT DERIVATION      ************************
C***************************************************************************
      IF(KT7.GT.0)
      DO (KT=1,KT7)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR   =ICON(IND +IOFF01)
       INDGET   = ICON(IND+IOFF02)
       INDPUT   = ICON(IND+IOFF04)
       LRATE    = ICON(IND+IOFF05)
       CONS1   = CON(IND+IOFF08)
       LDO= LRATE * NCDO
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       NUMSOU = ICON(IND+IOFF11)
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------------ XXXXXX
C  **********  Use following calls as examples
C** TITLE FOR VARIABLE NAME XXXXXX
      IF(NAMVAR.EQ.NXXXXXX)
       CALL  SXXXXXX
C------------------------------------------------ YYYYY
C** TITLE FOR VARIABLE NAME YYYYY
      OR IF(NAMVAR.EQ.NYYYYY    )
        CALL SYYYYY
C------------------------------------------------------------------- XO3FSC
C** CORRECTED NCAR FAST OZONE CONCENTRATION (PPB)
      OR IF(NAMVAR.EQ.NXO3FSC    )
        CALL SXO3FSC
C------------------------------------------------------------------- TOWAT
C** SIRO TOTAL LIQUID WATER CONTENT (G/M3)
      OR IF(NAMVAR.EQ.NTOWAT    )
        CALL STOWAT
C------------------------------------------------------------------- MRLA
C** MIXING RATIO FROM LYMAN ALPHA ABSOLUTE HUMIDITY (G/M3)
      OR IF(NAMVAR.EQ.NMRLA    )
        CALL SMRHO
C-----------------------------------------------------------------------
      ELSE
       KT8= KT8+1
       KTSV(KT8)= K
      END IF
      END DO
      END IF
      KTEND=KT8
.END
       SUBROUTINE SXXXXXX
       RETURN
       END
       SUBROUTINE SYYYYY
       RETURN
       END
.DE   K
.NOLIST
C
C  Temporary modification to work around CFT77 5.0 compiler bug:
C     Add a CDIR to avoid vectorizing a loop which bombs the compiler.
C     Fix appears as line number 2035 in this version.
C   Modified by Ron Ruth on 30 July 1992
C
C UNICOS MODS: COMMENT OUT RELEASE AND ACQUIRE IN INIT2,NWVL,DCODE
C  (JUL90 - CC)
C
C  UNICOS MODS FOR MULTIPLE INPUT DATASETS
C  AUG. 1990   -CC
C
C  THIS INPUT MODULE CONTAINS THE LATEST MODS AS OF MARCH 89
C  THE FOLLOWING NEW CONKEYS ADDED:
C  CONKEY=8 - WYOMING KINGAIR ARCHIVE TAPE FORMAT I. V. DECODING
C  CONKEY=9 - HP REAL NUMBER DECODING
C  CONKEY=10 - 2UW FLAG WORD DECODING
C  CONKEY=11 - IEEE REAL NUMBER DECODING
C
.SAVE COMINA
C
      COMMON/MISC/NEOT,IEOT,IPDY,VIND,VINDT,NSTATE,LENCNV,IVOL,ITPOS
     -          ,IFLG,NMCONG,NMCONV,LENIVN,NUMJ,LENNVL,LKPOS,VINDO
     -          ,LKIN
C
      COMMON/POINTG/CONV,FRTIM,IVTYPE,IVNAM,JCL,KIN,KMODE,KPOS
     -              ,KTYPE,LOGBIT,DATLOG,BITKEY,DATSIZ,MEDIA,DATOPT
     -              ,NPHY,NSEC,NAMKEY,NWVOL,NUMV,NEWV,NOLDV,NTOT,I
     -              ,KSTOP,NUMLOG,IVPR,DATBIT,OFFSET,MAXIV,KEOF,KOUNT
     -              ,IKOUNT
C
      COMMON/POINTV/NAMEDP,NII,NRI,NIO,NRO,BITS,FSTBIT,SKIP,SAMP,
     -              CONKEY,SCLKEY,TERM,FACTOR,NUMVEC,LENCON
C
C
      INTEGER CONV,FRTIM,DATLOG,DATSIZ,DATOPT,DATBIT,OFFSET
      INTEGER BITS,FSTBIT,SKIP,SAMP,CONKEY,TERM,FACTOR
      INTEGER SCLKEY,BITKEY
C
.END
.SAVE COMENT
C     ----------------------------------------------------------------
C
C     A COMMON DESCRIPTION
C
C     /POINTG/ - POINTERS TO THE GENERAL CONTROLS
C     /POINTV/ - POINTERS TO THE VARIABLE CONTROLS
C     /MISC/   - POINTERS TO SOME DERIVED VALUES/POINTERS
C
C     ----------------------------------------------------------------
C
C     A BRIEF DESCRIPTION OF SOME OF THE VARIABLES /MISC/
C
C
C     NEOT  - AN EOT ENCOUNTERED
C     IPDY - A PARITY ERROR ENCOUNTERED ON LAST READ
C     VIND - THE INDEPENDENT VARIABLE
C     IEOT - COUNTS EOT'S
C     IFLG - FLAG FOR THE TPOS ROUTINE
C     VINDT - CURRENT IV VALUE
C     NSTATE - STATUS OF THE LAST TAPE READ
C     IVOL - FLAG INDICATING WHEN A NEW VOLUME HAS BEEN ACCESSED
C
C     ----------------------------------------------------------------
C
C               /POINTG/   GENERAL CONTROL POINTERS
C
C  BITKEY - THE VALUE OF THE FLAG WORD
C  CONV   - CALIBRATION COEFFICIENT(S) FOR I.V.
C  DATBIT - NUMBER OF BITS OF DATA IN A PHYSICAL RECORD
C  DATLOG - NUMBER OF LOGICAL RECORDS PER NPHY (HEADER)
C  DATOPT - (AUTO,NOSPAN) DATA RECORD OPTION.
C  DATSIZ - THE LENGTH OF THE PHYSICAL RECORD IN BITS.
C  FRTIM  - THE IV SPAN OF A FRAME OF DATA (HEADER)
C  IVTYPE - FLAG FOR THE IV TYPE
C           0 - THE INDEPENDENT VARIABLE
C  IVNAM  - THE INDEPENDENT VARIABLE NAME(S)
C  JCL    - A FLAG INDICATING USER SUPPLIED JCL FOR INPUT VOLUME ACQUIRE
C           AND UNIT ASSIGNMENT.  "YES" -> USER SUPPLIED JCL, "NO" -> GENPRO
C           WILL DO A DEFAULT CALL ACQUIRE
C  KIN    - LOGICAL UNIT NUMBER(S) FOR THE INPUT VOLUME(S)
C  KMODE  - MODE OF THE INPUT TAPE
C  KPOS   - AN ORDERED PAIR (FILE,RECORD) INDICATING PRE-
C           LIMINARY VOLUME POSITIONING
C  KTYPE  - TYPE OF INPUT VOLUME
C  LOGBIT - NUMBER OF BITS PER LOGICAL RECORD (HEADER)
C  MEDIA  - MEDIA NUMBER
C  NAMKEY - THE NAME OF THE FLAG WORD (TAPE NAME)
C  NPHY   - THE NUMBER OF PHYSICAL RECORDS PER LOGICAL RECORD.
C  NSEC   - NUMBER OF CONSECUTIVE IV-S REQUIRED BEFORE PROCESSING
C  NWVOL - VOLUME NAMES FOR NEWVOL CALLS
C  NEWV  - NUMBER OF NEW VOLUMES TO BE READ (PROCESSOR TIME DERIVED)
C  NUMV  - LENGTH OF THE VOLUME CARD (PROCESSOR TIME DERIVED
C  NOLDV - NUMBER OF OLD VOLUMES
C  NTOT - BIT NUMBER OF THE FIRST BIT OF THIS LOGICAL RECORD M
C  I - LOGICAL RECORD NUMBER WITHIN THIS PHYSICAL RECORD
C  KEOF - 0    AN EOF DOES NOT TERMINATE VOLUME PROCESSING
C         1    AN EOF TERMINATES VOLUME PROCESSING
C  KOUNT - 1    COUNT THE NUMBER OF PARITY ERRORS ENCOUNTERED & PRINT
C               VALUE ON TERMINATION
C               PRINT WARNING MSG AS PARITY ERRORS ARE ENCOUNTERED
C          0    COUNT THE NUMBER OF PARITY ERRORS ENCOUNTERED ON THE
C               INPUT VOLUME & PRINT THIS VALUE UPON TERMINATION
C  IKOUNT - 0   A RUNNING COUNT OF PARITY ERRORS ON THE INPUT DATA VOLUME
C               (DERIVED)
C  KSTOP - AN EOT ENCOUNTERED
C             1 - NO NEW VOLUME SPECIFIED
C             0 - AN EOT ENCOUNTERED
C  MAXIV - MAXIMUM VALUE OF THE INPUT/PROCESSOR IV
C  NUMLOG - THE LOGICAL RECORD NUMBER
C  IVPR - A FLAG WHICH TURNS ON/OFF THE PRINTING OF IV INFORMATION
C             0 - NO PRINT
C             1 - PRINT IV/DATA INFO
C             2 - PRINT ONLY THE SPACE ARRAY AFTER DATA IS STORED
C OFFSET - OFFSET VALUE ADDED TO THE VALUE OF THE INPUT IND. VAR.
C  ------------------------------------------------------------------
C
C               /POINTV/  VARIABLE CONTROL POINTERS
C
C  NAME  - VARIABLE NAME
C  RATE - OUTPUT RATE OF THIS DEPENDENT VARIABLE
C  BITS - NUMBER OF BITS PER VALUE
C  FSTBIT - FIRST BIT IN THE DATA RECORD OF THE BIT STRING REPRESENTING
C           THE DATA VALUE
C  SKIP - THE NUMBER OF BITS TO SKIP BEFORE DECODING THE NEXT VALUE
C  SAMP - THE RATE AT WHICH TO PICK UP THIS PARAMETER
C  CONKEY - A DECODE KEY
C  SCLKEY - KEY USED TO SCALE THE INPUT DATA
C  TERM   - A SCALING TERM
C  FACTOR - A SCALING FACTOR
C
C     ----------------------------------------------------------------
.END
.SAVE GBYTE
      CALL GBYTES(ISAV(N1),N2,N3,N4,0,1)
.END
.SAVE GBYTES
      CALL GBYTES(ISAV(N1),ISAV(N2),N3,N6,ISAV(N4),ISAV(N5))
.END
.EJECT
      SUBROUTINE INPUT
C
C     THIS ROUTINE DRIVES THE INPUT MODULE
C     MODIFIED MARCH 84
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
.USE  COMINA
      DATA NAMSUB /4HINPU  ,2HT /
.USE  COMENT
C
C  --------------------------------------------------------
C  THE FOLLOWING CALL GATHERS USAGE STATS ON THE NCAR CRAY1
C
.REPL
H     CALL Q8QST4(6HOPRL$VERS,6HGENPRO,5HINPUT,10HVERSION $VERS)
.NOREP
C
K 700 FORMAT(' AM IN THE INPUT DRIVER')
K     WRITE(KCHECK,700)
C
C     INITIALIAZE COUNTERS/POINTERS FOR THIS CALL
C
      CALL INIT1
C
C     PROCESS THE DATA
C
      IF(NSTAGE.GT.3)
C
      CALL DCODE
C
      END IF
C
      RETURN
      END
.EJECT
      SUBROUTINE INIT1
C
C     THIS ROUTINE SETS UP POINTERS TO ALL CONTROLS
C
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
.USE  COMINA
.USE  CASINT
      INTEGER YES
      DATA NAMSUB,YES /4HINIT  ,2H1 ,3HYES/
C
C     ---------- 1.0 ----------
C
C     GENERAL CONTROLS
C
K 725 FORMAT(' I AM IN INIT1 ')
K     WRITE(KCHECK,725)
C
      INDST=1
.USE  INDEXS
      NMCONG = INDOFF + 4*(NUMCON + 1)
C
C     THE GENERAL CONTROLS
C
      ITYPOP = ISAV(INDOFF+5)+INDVAL
C
      CONV   = ISAV(INDOFF+7)+INDVAL
      LENCNV = ISAV(INDOFF+8)-ISAV(INDOFF+7)
C
      FRTIM  = ISAV(INDOFF+8)+INDVAL
C
      IVTYPE = ISAV(INDOFF+ 9)+INDVAL
C
      IVNAM  = ISAV(INDOFF+10)+INDVAL
      LENIVN = ISAV(INDOFF+11)-ISAV(INDOFF+10)
C
      JCL    = ISAV(INDOFF+11)+INDVAL
C
      KIN    = ISAV(INDOFF+12)+INDVAL
      LKIN   = ISAV(INDOFF+13)-ISAV(INDOFF+12)
C
      KMODE  = ISAV(INDOFF+13)+INDVAL
C
      KPOS   = ISAV(INDOFF+14)+INDVAL
      LKPOS  = ISAV(INDOFF+15)-ISAV(INDOFF+14)
C
      KTYPE  = ISAV(INDOFF+15)+INDVAL
C
      LOGBIT = ISAV(INDOFF+16)+INDVAL
C
      DATLOG = ISAV(INDOFF+17)+INDVAL
C
      BITKEY   = ISAV(INDOFF+18)+INDVAL
C
      DATSIZ = ISAV(INDOFF+19)+INDVAL
C
      MEDIA  = ISAV(INDOFF+20)+INDVAL
C
      DATOPT = ISAV(INDOFF+21)+INDVAL
C
      NPHY   = ISAV(INDOFF+22)+INDVAL
C
      NSEC   = ISAV(INDOFF+23)+INDVAL
C
      NAMKEY = ISAV(INDOFF+24)+INDVAL
C
      NWVOL  = ISAV(INDOFF+25)+INDVAL
      LENNVL = ISAV(INDOFF+26)-ISAV(INDOFF+25)
K     WRITE(KCHECK,800)LENNVL
      LENNVL = LENNVL/ISAV(INDELM+25)
K 800 FORMAT(' LENNVL = ',I5)
K     WRITE(KCHECK,800)LENNVL
C
      NUMV   = ISAV(INDOFF+26)+INDVAL
C
      NEWV   = ISAV(INDOFF+27)+INDVAL
C
      NOLDV  = ISAV(INDOFF+28)+INDVAL
C
      NTOT   = ISAV(INDOFF+29)+INDVAL
C
      I      = ISAV(INDOFF+30)+INDVAL
C
      KSTOP  = ISAV(INDOFF+31)+INDVAL
C
      NUMLOG = ISAV(INDOFF+32)+INDVAL
C
      IVPR   = ISAV(INDOFF+33)+INDVAL
C
      DATBIT = ISAV(INDOFF+34)+INDVAL
C
      OFFSET = ISAV(INDOFF+35)+INDVAL
C
      MAXIV  = ISAV(INDOFF+36)+INDVAL
C
      KEOF   = ISAV(INDOFF+37)+INDVAL
C
      KOUNT  = ISAV(INDOFF+38)+INDVAL
C
      IKOUNT = ISAV(INDOFF+39)+INDVAL
C
      NWVOL  = NWVOL + ICON(NOLDV)
      KPOS=KPOS+ISAV(NOLDV)*2
      IF(ICON(JCL).EQ.YES)
      KIN=KIN+ISAV(NOLDV)
      LKIN=LKIN-ISAV(NOLDV)
      END IF
C
C     ---------- 1.1 ----------
C
C     REWIND ALL INPUTS BEFORE THE 1ST INTERVAL OF A NEW CASE
C
      IF(NSTAGE.EQ.2.AND.IVINT.LT.2)
      DO (KNL=1,LKIN)
      KPLUS=KIN+KNL-1
      KU=ICON(KPLUS)
K     WRITE(KCHECK,2500) KNL,LKIN,KU
K2500 FORMAT(/,' INPUT(INIT1): REWIND VOLUME',I3,' OF',I3,' ON UNIT',I4)
      CALL REWIND(KU)
      END DO
      END IF
C
K 701 FORMAT(' CONV,FRTIM,IVNAM,JCL,KIN =',5I4)
K 702 FORMAT(' KMODE,KPOS,KTYPE,LOGBIT,DATLOG =',5I4)
K 703 FORMAT(' NPHY,NSEC,NAMKEY,NWVOL =',4I4)
K 750 FORMAT(' IVTYPE,BITKEY,DATSIZ,MEDIA,DATOPT,NUMV,NEWV',7I5)
K 751 FORMAT(' NOLDV,NTOT,I,KSTOP,NUMLOG,IVPR,DATBIT',7I5)
K     WRITE(KCHECK,701)CONV,FRTIM,IVNAM,JCL,KIN
K     WRITE(KCHECK,702)KMODE,KPOS,KTYPE,LOGBIT,DATLOG
K     WRITE(KCHECK,703)NPHY,NSEC,NAMKEY,NWVOL
K     WRITE(KCHECK,750)IVTYPE,BITKEY,DATSIZ,MEDIA,DATOPT,NUMV,NEWV
K     WRITE(KCHECK,751)NOLDV,NTOT,I,KSTOP,NUMLOG,IVPR,DATBIT
C
C     ---------- 2.0 ----------
C
C     DEPENDENT VARIABLE CONTROLS
C
      INDST = 2
C
.USE  INDEXS
C
      NMCONV = INDOFF + 4*(NUMCON + 1)
C
C     NUMCON=NUMBER OF CONTROLS
C     NUMVEC=NUMBER OF ELEMENTS IN THE AREA VECTOR
C     LENCON=NUMBER OF NSU'S PER AREA VECTOR ELEMENT
C
C
      NAMEDP = ISAV(INDOFF+1)+INDVAL
C
      NII    = ISAV(INDOFF+2)+INDVAL
C
      NRI    = ISAV(INDOFF+3)+INDVAL
C
      NIO    = ISAV(INDOFF+4)+INDVAL
C
      NRO    = ISAV(INDOFF+5)+INDVAL
C
      BITS   = ISAV(INDOFF+6)+INDVAL
C
      FSTBIT = ISAV(INDOFF+7)+INDVAL
C
      SKIP   = ISAV(INDOFF+8)+INDVAL
C
      SAMP   = ISAV(INDOFF+9)+INDVAL
C
      CONKEY = ISAV(INDOFF+10)+INDVAL
C
      SCLKEY = ISAV(INDOFF+11)+INDVAL
C
      TERM = ISAV(INDOFF+12)+INDVAL
C
      FACTOR = ISAV(INDOFF+13)+INDVAL
C
C
K 704 FORMAT(' NAMEDP,NRI,NII,NRO,NIO  =',5I4)
K 705 FORMAT(' BITS,FSTBIT,SKIP,SAMP,CONKEY,TERM,NP=',7I4)
K     WRITE(KCHECK,704)NAMEDP,NRI,NII,NRO,NIO
K     WRITE(KCHECK,705)BITS,FSTBIT,SKIP,SAMP,CONKEY,TERM,FACTOR
C
C     ---------- 3.0 ----------
C
C     CHECK THE INTEGRITY OF SOME CONTROLS ON FIRST CALL  (NSTAGE=2)
C
      IF(NSTAGE.EQ.2)
C
      CALL INIT2
C
      OR IF(NSTAGE.EQ.3)
      VINDT=BEGIV
      IFLG=1
K 900 FORMAT(' IN INIT1 - CALL TPOS')
K     WRITE(KCHECK,900)
      CALL TPOS
      END IF
C
K     CALL CADUMP
K 899 FORMAT(' IN INIT1- KPOS, KIN, ISAV(KIN)= ',5I6)
K     WRITE(KCHECK,899)KPOS,ISAV(KPOS),ISAV(KPOS+1),KIN,ISAV(KIN)
K 784 FORMAT('IN INIT1- ISAV(I), ISAV(NTOT), LOCSAV(THISOP),',3I10)
K     WRITE(KCHECK,784)ISAV(I),ISAV(NTOT),LOCSAV(THISOP)
C
C     SOME FORMATS
C
 3051 FORMAT(24X,' IVNAM ',5I3)
 3052 FORMAT(24X,' CONV  ',5F12.3)
C
C
      RETURN
      END
.EJECT
      SUBROUTINE INIT2
C
C     THIS ROUTINE INITIALIZES AT NSTAGE = 2
C
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
.USE  MSGPR
C
.USE  COMINA
.NOREP
.USE  CASINT
      DIMENSION MTYP(10),NTYP(10),LTYP(10),JTYP(10)
      DIMENSION NAMSUB(2)
C
      EQUIVALENCE (KTEMP,RTEMP)
C
      INTEGER PLUSN,PTN,ZERO,SPAN,DLV,YES
      CHARACTER*80 STRING
      INTEGER IEXEC
C
      DATA PLUSN,PTN,ZERO/2H+N,2H.N,1H0/
      DATA MTYP /1HC,1HI,1HI,1HC,1HI,1HC,1HI,1HC,1HI,1HI/
      DATA JTYP /1HC,1HI,1HC,1HC,1HI,1HI,1HI,1HI,1HI,1HI/
      DATA NTYP /1HC,1HI,1HC,1HI,1HC,1HR,1HC,1HR,1HC,1HC/
      DATA LTYP /1HC,1HI,1HI,1HI,1HI,1HC,1HC,1HC,1HC,1HC/
T     DATA SPAN,NSPAN,DLV /4HSPAN,6HNOSPAN,5HDELIV/
R     DATA SPAN,NSPAN,DLV /4HSPAN,4HNOSP,4HDELI/
      DATA NAMSUB, YES /4HINIT  ,2H2 ,3HYES /
K 800 FORMAT(' I AM IN INIT2 ')
K     WRITE(KCHECK,800)
C
C     ---------- 1.0 ----------
C
C     CHECK THE INTEGRITY OF SOME CONTROLS ON FIRST CALL  (NSTAGE=2)
C
K     CALL CADUMP
C
C     ---------- 2.0 ----------
C
C     INITIALIZE I NTOT, AND KSTOP
C
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
      ISAV(KSTOP)=0
C
C     ---------- 3.0 ----------
C
C     CHECK THE INTEGRITY OF SOME GENERAL CONTROLS
C
C     DATBIT
      IF(ICON(DATBIT).LE.0)
      AT=3.1
      INDX=NMCONG+34
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(DATBIT)
      MSGVAL(3)=1
      MSGVAL(4)=PLUSN
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(1),MTYP(1),1,4,2)
      END IF
C     DATLOG
      IF(ICON(DATLOG).LE.0)
      AT=3.2
      INDX=NMCONG+17
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(DATLOG)
      MSGVAL(3)=1
      MSGVAL(4)=PLUSN
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(1),MTYP(1),1,4,2)
      END IF
C     DATSIZ
      IF(ICON(DATSIZ).LE.0)
      AT=3.3
      INDX=NMCONG+19
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(DATLOG)
      MSGVAL(3)=1
      MSGVAL(4)=PLUSN
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(1),MTYP(1),1,4,2)
      END IF
C     FRTIM
      IF(CON(FRTIM).LE.0.)
      AT=3.4
      INDX=NMCONG+8
      MSGVAL(1)=ICON(INDX)
      RTEMP=CON(FRTIM)
      MSGVAL(2)=KTEMP
      MSGVAL(3)=PTN
      MSGVAL(4)=PLUSN
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(4),NTYP(7),1,4,2)
      END IF
C     KIN
      LIN=KIN-1
      DO (III=1,LKIN)
      LIN=LIN+1
      IF(ICON(LIN).LT.11.OR.ICON(LIN).GT.20)
      AT=3.5
      INDX=NMCONG+12
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(LIN)
      MSGVAL(3)=11
      MSGVAL(4)=20
      MSGVAL(5)=15
      CALL COMERR(6,NAMSUB,AT,KWARN,MSGVAL(1),LTYP(1),1,5,2)
K     CALL CADUMP
      ICON(KIN)=15
      END IF
      END DO
C     KMODE
      IF(ICON(KMODE).LT.0.OR.ICON(KMODE).GT.2)
      AT=3.6
      INDX=NMCONG+13
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(KMODE)
      MSGVAL(3)=0
      MSGVAL(4)=2
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(7),LTYP(1),1,4,2)
      END IF
C     KTYPE
      IF(ICON(KTYPE).LT.0.OR.ICON(KTYPE).GT.2)
      AT=3.7
      INDX=NMCONG+15
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(KTYPE)
      MSGVAL(3)=0
      MSGVAL(4)=2
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(7),LTYP(1),1,4,2)
      END IF
C     LOGBIT
      IF(ICON(LOGBIT).LE.0)
      AT=3.8
      INDX=NMCONG+16
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(LOGBIT)
      MSGVAL(3)=1
      MSGVAL(4)=PLUSN
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(1),MTYP(1),1,4,2)
      END IF
C     NSEC
      IF(ICON(NSEC).LT.0)
      AT=3.9
      INDX=NMCONG+23
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(NSEC)
      MSGVAL(3)=0
      MSGVAL(4)=PLUSN
      CALL COMERR(7,NAMSUB,AT,KFATAL,MSGVAL(1),MTYP(1),1,4,2)
      END IF
C     KEOF
      IF(ICON(KEOF).LT.0.OR.ICON(KEOF).GT.1)
      AT=3.11
      INDX=NMCONG+37
      MSGVAL(1)=ICON(INDX)
      MSGVAL(2)=ICON(KEOF)
      MSGVAL(3)=0
      MSGVAL(4)=1
      MSGVAL(5)=1
      CALL COMERR(6,NAMSUB,AT,KWARN,MSGVAL(1),LTYP(1),1,5,2)
      ICON(KEOF)=0
      END IF
C     KOUNT
      IF(ICON(KOUNT).LT.0.OR.ICON(KOUNT).GT.1)
      AT=3.12
      INDX=NMCONG+38
      MSGVAL(1)=ICON(INDX)
C  Changed subscript from KONNT to KOUNT:  Ron Ruth 920615
      MSGVAL(2)=ICON(KOUNT)
      MSGVAL(3)=0
      MSGVAL(4)=1
      MSGVAL(5)=0
      CALL COMERR(6,NAMSUB,AT,KWARN,MSGVAL(1),LTYP(1),1,5,2)
      ICON(KOUNT)=0
      END IF
C
C     ---------- 4.0 ----------
C
C     CHECK THE INTEGRITY OF SOME DEPENDENT VARIABLE CONTROLS
C
      NAMCON=NAMEDP-NUMCON-1
C
C     BITS
      INDW=NRI-LENCON
      INDX=BITS-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+6
      NAMEC=ICON(INDZ)
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      ITEST=ICON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(ITEST.LE.0)
C
      AT=4.1
      MSGVAL(1)=NAMEC
      MSGVAL(2)=ITEST
      MSGVAL(3)=NAMEV
      MSGVAL(4)=1
      MSGVAL(5)=PLUSN
      CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,5,2)
C
      END IF
      END IF
C
      END DO
C
C     CONKEY
      INDW=NRI-LENCON
      INDX=CONKEY-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+10
      NAMEC=ICON(INDZ)
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      ITEST=ICON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(ITEST.LT.0)
C
      AT=4.2
      MSGVAL(1)=NAMEC
      MSGVAL(2)=ITEST
      MSGVAL(3)=NAMEV
      MSGVAL(4)=0
      MSGVAL(5)=PLUSN
      CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,5,2)
C
      END IF
      END IF
C
      END DO
C
C     FACTOR
      INDW=NRI-LENCON
      INDX=FACTOR-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+13
      NAMEC=ICON(INDZ)
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      TEST=CON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(TEST.EQ.0.0)
C
      AT=4.3
      MSGVAL(1)=NAMEC
      RTEMP=TEST
      MSGVAL(2)=KTEMP
      MSGVAL(3)=NAMEV
      MSGVAL(4)=1.0
      CALL COMERR(16,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(5),1,4,2)
C
      END IF
      END IF
C
      END DO
C
C     FSTBIT
      INDW=NRI-LENCON
      INDX=FSTBIT-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+7
      NAMEC=ICON(INDZ)
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      ITEST=ICON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(ITEST.LE.0)
C
      AT=4.4
      MSGVAL(1)=NAMEC
      MSGVAL(2)=ITEST
      MSGVAL(3)=NAMEV
      MSGVAL(4)=1
      MSGVAL(5)=PLUSN
      CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,5,2)
C
      END IF
      END IF
C
      END DO
C
C     RATE
      INDW=NRI-LENCON
      INDX=NRO-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+5
      INDZ1=NMCONV+3
      NAMEC=ICON(INDZ)
K 850 FORMAT('  NMCONV, INDZ, INDZ1, NAMEC, ICON(INDZ), ICON(INDZ1) =',
K    -          3I10,3A10)
K     WRITE(KCHECK,850)NMCONV,INDZ,INDZ1,NAMEC,ICON(INDZ),ICON(INDZ1)
K     CALL CADUMP
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      ITEST=ICON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(ITEST.LT.0)
C
      AT=4.5
      MSGVAL(1)=NAMEC
      MSGVAL(2)=ITEST
      MSGVAL(3)=NAMEV
      MSGVAL(4)=1
      MSGVAL(5)=PLUSN
      CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,5,2)
C
      END IF
      END IF
C
      IF(ICON(INDW).GT.0.AND.ICON(INDX).NE.ICON(INDW))
      AT=4.53
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=ICON(INDX)
      MSGVAL(3)=NAMEV
      MSGVAL(4)=ICON(INDZ1)
      MSGVAL(5)=ICON(INDW)
      MSGVAL(6)=ICON(INDW)
      CALL COMERR(18,NAMSUB,AT,KWARN,MSGVAL(1),JTYP(1),1,6,2)
      ICON(INDX)=ICON(INDW)
      END IF
C
      END DO
C
C     SAMPLE
      INDW=NRI-LENCON
      INDX=SAMP-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+9
      NAMEC=ICON(INDZ)
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      ITEST=ICON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(ITEST.LE.0)
C
      AT=4.6
      MSGVAL(1)=NAMEC
      MSGVAL(2)=ITEST
      MSGVAL(3)=NAMEV
      MSGVAL(4)=1
      MSGVAL(5)=PLUSN
      CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,5,2)
C
      END IF
      END IF
C
      END DO
C
C     SCLKEY
      INDW=NRI-LENCON
      INDX=SCLKEY-LENCON
      INDY=NAMEDP-LENCON
      INDZ=NMCONV+11
      NAMEC=ICON(INDZ)
C
      DO(KKK=1,NUMVEC)
C
      INDW=INDW+LENCON
      INDY=INDY+LENCON
      NAMEV=ICON(INDY)
      INDX=INDX+LENCON
      ITEST=ICON(INDX)
C
      IF(ICON(INDW).EQ.0)
      IF(ITEST.LT.1.OR.ITEST.GT.2)
C
      AT=4.7
      MSGVAL(1)=NAMEC
      MSGVAL(2)=ITEST
      MSGVAL(3)=NAMEV
      MSGVAL(4)=1
      MSGVAL(5)=2
      CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),MTYP(6),1,5,2)
C
      END IF
      END IF
C
      END DO
C
C     SKIP
C     INDX=SKIP-LENCON
C     INDY=NAMEDP-LENCON
C     INDZ=NMCONV+8
C     NAMEC=ICON(INDZ)
C
C     DO(KKK=1,NUMVEC)
C
C     INDY=INDY+LENCON
C     NAMEV=ICON(INDY)
C     INDX=INDX+LENCON
C     ITEST=ICON(INDX)
C
C     IF(ITEST.LT.0)
C
C     AT=4.8
C     MSGVAL(1)=NAMEC
C     MSGVAL(2)=ITEST
C     MSGVAL(3)=NAMEV
C     MSGVAL(4)=1
C     MSGVAL(5)=PLUSN
C     CALL COMERR(15,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,5,2)
C
C     END IF
C
C     END DO
C
C     ---------- 5.0 ----------
C
C     CHECK CONV AND IVNAM LENGTHS
C
K 706 FORMAT(' LENIVN, LENCNV =',2I5)
K     WRITE(KCHECK,706)LENIVN,LENCNV
      IF(ISAV(IVTYPE).EQ.1)
      IF(LENCNV.NE.LENIVN)
      AT=5.1
      INDZ=NMCONG+7
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=LENCNV
      INDZ=NMCONG+10
      MSGVAL(3)=ICON(INDZ)
      MSGVAL(4)=LENIVN
      CALL COMERR(1,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,4,2)
      END IF
      END IF
C
      IF(ISAV(IVPR).EQ.1)
      I1=IVNAM
      I2=I1+LENIVN-1
      K1=CONV
      K2=K1+LENCNV-1
      AT=5.2
      INDZ=NMCONG+9
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=ICON(IVTYPE)
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(231,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,2,1)
      WRITE(KCHECK,3051)(ISAV(III),III=I1,I2)
      WRITE(KCHECK,3052)(SAV(III),III=K1,K2)
      CALL COMERR(0,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,0,3)
      KERR=KSAV
      END IF
C
C     ---------- 6.0 ----------
C
C     CHECK IVTYPE
C
      IF(ISAV(IVTYPE).GT.1.OR.ISAV(IVTYPE).LT.0)
      AT=6.1
      INDZ=NMCONG+9
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=ICON(IVTYPE)
      MSGVAL(3)=0
      MSGVAL(4)=1
      MSGVAL(5)=0
      CALL COMERR(6,NAMSUB,AT,KWARN,MSGVAL(1),LTYP(1),1,5,2)
      ISAV(IVTYPE)=0
      END IF
C
C     CHECK IVTYPE WITH IVNAM
C
      IF(ISAV(IVTYPE).EQ.1)
      IJ=IVNAM-1
C
      DO(KKK=1,LENIVN)
      IJ=IJ+1
C
      IF(ISAV(IJ).LT.0)
      AT=6.2
      INDZ=NMCONG+9
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=ICON(IVTYPE)
      INDZ=NMCONG+10
      MSGVAL(3)=ICON(INDZ)
      MSGVAL(4)=ICON(IJ)
      CALL COMERR(9,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,4,2)
      END IF
C
      END DO
C
      END IF
 
C
C     ---------- 7.0 ----------
C
C     CHECK DATOPT(AUTO,SPAN/NOSPAN)
C
      IF(IVINT.LE.1)
      IF(ISAV(DATOPT+1).EQ.SPAN)
      ISAV(DATOPT)=1
      ISAV(DATOPT+1)=1
      OR IF(ISAV(DATOPT+1).EQ.NSPAN)
      ISAV(DATOPT)=0
      ISAV(DATOPT+1)=0
      ELSE
      AT=7.1
      INDZ=NMCONG+21
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=ICON(DATOPT+1)
      MSGVAL(3)=SPAN
      MSGVAL(4)=NSPAN
      MSGVAL(5)=NSPAN
      CALL COMERR(6,NAMSUB,AT,KWARN,MSGVAL(1),LTYP(6),1,5,2)
      END IF
      END IF
C
C     ---------- 8.0 ----------
C
C
C     ---------- 9.0 ----------
C
C     CHECK NAMKEY/BITKEY
C
      IF(ISAV(NAMKEY).LE.0)
      ISAV(BITKEY)=0
      END IF
C
C     ---------- 10.0 ----------
C
C     CHECK JCL
C
      IF(IVINT.LE.1)
C
C     ---------- 11.0 ----------
C
C     NWVOL
C
      ISAV(NEWV)=LENNVL
      ISAV(NEWV)=ISAV(NEWV)-1
C
C     ---------- 12.0 ----------
C
C     CHECK NWVOL LENGTH WITH KPOS LENGTH
C
      LKPOS=LKPOS/2
      IF(LENNVL.NE.LKPOS)
      AT=12.1
      INDZ=NMCONG+25
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=LENNVL
      INDZ=NMCONG+14
      MSGVAL(3)=ICON(INDZ)
      MSGVAL(4)=LKPOS
      CALL COMERR(1,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,4,2)
      END IF
C
C     ---------- 12.5 ----------
C
C     CHECK KIN LENGTH WITH KPOS LENGTH
C
      IF(ICON(JCL).EQ.YES)
      IF(LKIN.NE.LKPOS)
      AT=12.5
      INDZ=NMCONG+12
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=LKIN
      INDZ=NMCONG+14
      MSGVAL(3)=ICON(INDZ)
      MSGVAL(4)=LKPOS
      CALL COMERR(1,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(1),1,4,2)
      END IF
C
C     ---------- 13.0 ----------
C
C     ASSIGN THE INPUT VOLUME
C
K 770 FORMAT(' ISAV(NWVOL)',A8)
K     WRITE(KCHECK,770)ISAV(NWVOL)
C
      ELSE
H     ENCODE(7,1000,NAMEK)ISAV(KIN)
H1000 FORMAT('fort.',I2)
K1200 FORMAT(' IN INIT2 - NAMEK, ISAV(NWVOL), = ',2A10)
K     WRITE(KCHECK,1200)NAMEK,ISAV(NWVOL)
C H     CALL RELEASE(IER,'DN',NAMEK)
C H     CALL ACQUIRE(IER,'DN',NAMEK,'PDN',ISAV(NWVOL),'DF','76','MF','TB')
C    -             ,'TEXT','ONLINE')
C
C  UNICOS MODS FOR MULTIPLE INPUT DATASETS
C  AUG. 1990   -CC
C    CLOSE THE LOGICAL UNIT NUNIT;
C    IOSTAT= IOS: ERROR STATUS IS ASSIGNED TO IOS: 0 FOR NO ERROR,
C                                                  OR MESSAGE NUMBER
C    ERR=S: STATEMENT TRANSFERRED TO IF AN ERROR OCCURS
C
C      CLOSE(UNIT=ISAV(KIN),IOSTAT=IOS,ERR=829)
C      CLOSE(UNIT=ISAV(KIN),STATUS='DELETE',IOSTAT=IOS,ERR=829)
1201  FORMAT(' IN init2: first volume assigned-NAMEK,NWVOL=',2A10)
      WRITE(KCHECK,1201)NAMEK,ICON(NWVOL)
C      newf=icon(nwvol)
      write(string,1202)icon(nwvol),isav(kin)
1202  format('assign -a ',a4,' fort.',i2)
C      STRING='assign -a newf namek'
      ier=iexec(STRING)
C      open(unit=isav(kin),file=newf,status=old,iostat=ioso,err=929)
C
K     WRITE(KCHECK,1200)NAMEK,ISAV(NWVOL)
      END IF
      END IF
C
C     ---------- 14.0 ----------
C
C     CHECK CONSISTENCY OF DELIV AND SPACE(FRTIM)
C
      IF(ISAV(IVPR).EQ.1)
      AT=14.1
      MSGVAL(1)=DLV
      RTEMP=DELIV
      MSGVAL(2)=KTEMP
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(231,NAMSUB,AT,KINFO,MSGVAL(1),NTYP(7),1,2,1)
      INDZ=NMCONG+8
      MSGVAL(1)=ICON(INDZ)
      RTEMP=CON(FRTIM)
      MSGVAL(2)=KTEMP
      CALL COMERR(231,NAMSUB,AT,KINFO,MSGVAL(1),NTYP(7),1,2,3)
      KERR=KSAV
      END IF
C
      IF(DELIV.NE.SPACE(FRTIM))
      IF(DELIV.GT.SPACE(FRTIM))
      ITEST=DELIV/SPACE(FRTIM)
      TEST=ITEST*SPACE(FRTIM)
      IF(TEST.NE.DELIV)
      AT=14.2
      INDZ=NMCONG+8
      MSGVAL(1)=ICON(INDZ)
      RTEMP=CON(FRTIM)
      MSGVAL(2)=KTEMP
      MSGVAL(3)=DLV
      RTEMP=DELIV
      MSGVAL(4)=KTEMP
      CALL COMERR(9,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(5),1,4,2)
      END IF
      OR IF(DELIV.LT.SPACE(FRTIM))
      AT=14.3
      INDZ=NMCONG+8
      MSGVAL(1)=ICON(INDZ)
      RTEMP=CON(FRTIM)
      MSGVAL(2)=KTEMP
      MSGVAL(3)=DLV
      RTEMP=DELIV
      MSGVAL(4)=KTEMP
      CALL COMERR(9,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(5),1,4,2)
      END IF
      END IF
C
C     ---------- 15.0 ----------
C
C     CHECK ON RATEOUT AND DATA VOLUME RATE CONSISTENCY
C
      NPT=LENCON
      IXRI=NRI-NPT
      IX3=FSTBIT-NPT
      IX4=BITS-NPT
      IX2=SKIP-NPT
      IXS=SAMP-NPT
      IXRO=NRO-NPT
      IXV=NAMEDP-NPT
C
      DO(J=1,NUMVEC)
C
      IXRI=IXRI+NPT
      IX3=IX3+NPT
      IX4=IX4+NPT
      IX2=IX2+NPT
      IXS=IXS+NPT
      IXRO=IXRO+NPT
      IXV=IXV+NPT
      NAMEV=ISAV(IXV)
      ITEST=DELIV/SAV(FRTIM)*ISAV(IXS)
C
      IF(ISAV(IXRI).EQ.0)
C
      IF(ITEST.NE.ISAV(IXRO))
      AT=15.1
      INDZ=NMCONV+9
      MSGVAL(1)=ICON(INDZ)
      MSGVAL(2)=ICON(IXS)
      MSGVAL(3)=NAMEV
      INDZ=NMCONV+5
      MSGVAL(4)=ICON(INDZ)
      MSGVAL(5)=ICON(IXRO)
      MSGVAL(6)=ICON(IXS)
      CALL COMERR(18,NAMSUB,AT,KWARN,MSGVAL(1),JTYP(1),1,6,2)
C
      ISAV(IXRO)=ITEST
C
      END IF
C
      END IF
C
      END DO
C
C     ---------- 16.0 ----------
C
C     DETERMINE LENGTH OF SAVE SPACE
C
      IF(ISAV(DATOPT).EQ.0)
H     LENSCR        =(ISAV(DATLOG)*ISAV(LOGBIT)/BITNSU)+1
H     LENSAV(THISOP)=(ISAV(DATLOG)*ISAV(LOGBIT)/BITNSU)+1
M     LENSCR        =(ISAV(DATLOG)*ISAV(LOGBIT)/BITNSU)+1
M     LENSAV(THISOP)=(ISAV(DATLOG)*ISAV(LOGBIT)/BITNSU)+1
V     LENSCR        =ISAV(DATSIZ)/BITNSU+1
V     LENSAV(THISOP)=ISAV(DATSIZ)/BITNSU+1
      ISAV(NPHY)=1
      ELSE
      ISAV(NPHY)=ISAV(LOGBIT)/ISAV(DATSIZ)
      LENSCR        =ISAV(NPHY)*ISAV(DATSIZ)/BITNSU+1
      LENSAV(THISOP)=ISAV(NPHY)*ISAV(DATSIZ)/BITNSU+1
      END IF
C
K 715 FORMAT(' LENSAV, LENSCR =',I5)
K     WRITE(KCHECK,715)LENSAV(THISOP),LENSCR
C
C     ---------- 17.0 ----------
C
C     MORE INITIALIZATION
C
C
      NAMVOL(INNUM)=ISAV(NWVOL)
      NUNIT(INNUM)=ISAV(KIN)
      IT=ICON(KIN)
      ICON(NUMLOG)=0
C
K     WRITE(KCHECK,784)ISAV(I),ISAV(NTOT),LOCSAV(THISOP)
C
      IF(IVINT.LE.1)
C
      NAMFIL(INNUM)=1
      NAMREC(INNUM)=0
C
K 790 FORMAT(' ISAV(NUMV),ISAV(NOLDV),ISAV(NEWV),JCL,NWVOL,KPOS',6I6)
K     WRITE(KCHECK,790)ISAV(NUMV),ISAV(NOLDV),ISAV(NEWV),JCL,NWVOL,KPOS
C
C     ---------- 18.0 ----------
C
C     POSITION THE INPUT TAPE
C
      IT=ICON(KIN)
K     CALL CADUMP
      END IF
C
K 788 FORMAT(' KPOS, KIN, ICON(KPOS), ICON(KPOS+1), ICON(KIN),NOLDV ='
K    -        ,6I6)
K     WRITE(KCHECK,788)KPOS,KIN,ICON(KPOS),ICON(KPOS+1),ICON(KIN),
K    -                 NOLDV
K     CALL CADUMP
      IFLG=-1
K 900 FORMAT(' INIT2 -  CALL TPOS')
K     WRITE(KCHECK,900)
      CALL TPOS
C
C     SOME FORMATS
C
K 784 FORMAT(' ISAV(I), ISAV(NTOT), LOCSAV(THISOP) ',3I10)
3051  FORMAT(24X,'IVNAM ',5I3)
3052  FORMAT(24X,' CONV ',5F12.3)
C
C
      RETURN
  829 print 828,nunit
  929 print 928,nunit
  828 format(' init2: error occurs on nunit ',i5)
  928 format(' init2: error occurs on nunit ',i5)
      END
.EJECT
      SUBROUTINE TPOS
C
C     THIS ROUTINE POSITIONS THE INPUT TAPE
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
.USE  MSGPR
.USE  COMINA
.USE  CASINT
C
      COMMON/TEMP/IREC,MTOT,II,K,MLOG
C
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
      DATA NAMSUB /4HTPOS  ,2H  /
      DIMENSION NTYP(12),LTYP(10)
      DATA NTYP /1HC,1HI,1HC,1HI,1HC,1HR,1HC,1HR,1HC,1HC,1HR,1HI/
      DATA LTYP /1HC,1HI,1HI,1HI,1HI,1HC,1HI,1HC,1HC,1HC/
C
C     IFLG = -1       INITIAL CALL
C             0       NEW VOLUME
C             1       IV GAP
  799 FORMAT(' AM IN TPOS')
K     WRITE(KCHECK,799)
C
C     ---------- 1.0 ----------
C
C     TEST THE NATURE OF THE ENTRY
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  798 FORMAT(' IFLG, VINDT, BEGIV',I5,2F12.5)
C     WRITE(KCHECK,798)IFLG,VINDT,BEGIV
C     PRINT 799
      IF(IFLG.EQ.1)
      VSTRT=VINDT
      GO TO 150
      OR IF(IFLG.EQ.0)
      VSTRT=VINDT
      OR IF(IFLG.EQ.-1)
      VSTRT=BEGIV
      IF(IVINT.GT.1)  GO TO 101
      END IF
C
C     ---------- 2.0 ----------
C
   2  CONTINUE
C
C     SOME TAPE POSITIONING ON THE NEW VOLUME
C
K 797 FORMAT(' KPOS ',2I10)
K     WRITE(KCHECK,797)ISAV(KPOS),ISAV(KPOS+1)
C
      KFILE=ISAV(KPOS)
K 780 FORMAT(' IN TPOS - KPOS, KFILE = ',2I10)
K     WRITE(KCHECK,780)KPOS,KFILE
      IF(KFILE.GT.0)
      DO (J=1,KFILE)
      CALL SKIPFL
      END DO
      ISAV(KPOS)=0
      END IF
C
   50 CONTINUE
C
      KREC=ISAV(KPOS+1)
K 781 FORMAT(' IN TPOS - KPOS, KREC =',2I5)
K     WRITE(KCHECK,781)KPOS,KREC
      IF(KREC.GT.0)
      IVPRO=ISAV(IVPR)
      ISAV(IVPR)=0
      NPHYO=ISAV(NPHY)
      ISAV(NPHY)=1
      DO(J=1,KREC)
      CALL READT
      END DO
      ISAV(KPOS+1)=0
      ISAV(IVPR)=IVPRO
      ISAV(NPHY)=NPHYO
      END IF
      KREC=0
C
  101 CONTINUE
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
C
  100 CONTINUE
C
C     ---------- 3.0 ----------
C
C     READ A RECORD
C
      CALL READT
K 700 FORMAT(' RECORD NUMBER, STATUS OF READ ',2I5)
K     WRITE(KCHECK,700)NAMREC(INNUM),NSTATE
C
K 796 FORMAT(' ISAV(KSTOP) =',I5)
K     WRITE(KCHECK,796)ISAV(KSTOP)
C
C     ---------- 3.9 ----------
C
C     CHECK FOR EOT WITH A NEW VOLUME ACCESSED
C
      IF(IVOL.EQ.1)
      IVOL=0
      GO TO 2
      END IF
C
C     ---------- 4.0 ----------
C
C     CHECK FOR EOD
C
      IF(ISAV(KSTOP).GT.0)
      AT=4.1
      MSGVAL(1)=NAMREC(INNUM)
      MSGVAL(2)=ICON(KIN)
      MSGVAL(3)=NAMVOL(INNUM)
      CALL COMERR(105,NAMSUB,AT,KFATAL,MSGVAL(1),LTYP(4),1,3,2)
      IF(IFLG.EQ.-1)ENDTAP(INNUM)=BEGIV-DELIV
      IF(IFLG.EQ.0)ENDTAP(INNUM)=VINDT-DELIV
K 900 FORMAT(' IN TPOS AT 4.1 JUST BEFORE THE RETURN')
K     WRITE(KCHECK,900)
      RETURN
      END IF
K 901 FORMAT(' IN TPOS AT STATEMENT LABEL 150 ')
K     WRITE(KCHECK,901)
C
  150 CONTINUE
C
C     ---------- 5.0 ----------
C
C     IS BEGIV IN THIS RECORD
C
      LOOP
C
      ISAV(I)=ISAV(I)+1
      IF(ISAV(I).GT.ISAV(DATLOG))
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
      GO TO 100
      END IF
      ISAV(NTOT)=ISAV(NTOT)+ISAV(LOGBIT)
      ISAV(NUMLOG)=ISAV(NUMLOG)+1
C
C     ---------- 6.0 ----------
C
C     DECODE IND VAR AND SYNCH WORD
C
      IVOLO=IVOL
      IVOL=0
      CALL MINID
      IVOL=IVOLO
      IF(IPDY.EQ.1)
      ISAV(I)=ISAV(I)+1
      IF(ISAV(I).GT.ISAV(DATLOG))
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
      GO TO 100
      ELSE
      GO TO 150
      END IF
      END IF
C
  701 FORMAT(' IN TPOS - - IND VAR, BEGIV =',2F12.2/2O30)
C     WRITE(KCHECK,701)VIND,BEGIV,VIND,BEGIV
      IVIND = VIND+.001*DELIV
      VIND = IVIND
C
      EXIT IF(VIND.GE.BEGIV)
C
      END LOOP
C
  300 CONTINUE
C
C     ---------- 7.0 ----------
C
C     A START IND VAR HAS BEEN FOUND
C     CHECK FOR IND VAR CONSISTENCY
C
      TAPE1=VIND
C
      IF(NSTAGE.EQ.2)
      BEGTAP(INNUM)=VIND
      END IF
C
      AT=7.1
      RTEMP=VIND
      MSGVAL(1)=KTEMP
      MSGVAL(2)=NAMREC(INNUM)
      CALL COMERR(230,NAMSUB,AT,KINFO,MSGVAL(1),NTYP(11),1,2,2)
C
K 705 FORMAT(' FRAME NUMBER, RECORD NUMBER, WORD NUMBER, ',3I10)
K     WRITE(KCHECK,705)ISAV(I),NAMREC(INNUM),ISAV(NTOT)
C
      MLOG=ISAV(NUMLOG)-1
      MTOT=ISAV(NTOT)-ISAV(LOGBIT)
      II=ISAV(I)-1
      K=1
      IREC=0
      NO=0
K 707 FORMAT(' MTOT,II, ISAV(NSEC) ',3I10)
K     WRITE(KCHECK,707)MTOT,II,ISAV(NSEC)
C
      IF(ISAV(NSEC).NE.0.AND.ISAV(IVTYPE).NE.0)
C
      ITPOS=999
C
      LOOP
C
  350 CONTINUE
C
      ISAV(NUMLOG)=ISAV(NUMLOG)+1
      ISAV(I)=ISAV(I)+1
      ISAV(NTOT)=ISAV(NTOT)+ISAV(LOGBIT)
C
C     ---------- 8.0 ----------
C
C     READ A RECORD IF NECESSARY
C
K 706 FORMAT(' FRAME NUMBER, BIT NUMBER =',2I5)
K     WRITE(KCHECK,706)ISAV(I),ISAV(NTOT)
C
      IF(ISAV(I).GT.ISAV(DATLOG))
  310 CONTINUE
      IREC=IREC+1
      CALL READT
C
K     WRITE(KCHECK,700)NAMREC(INNUM),NSTATE
C
C     ---------- 9.0 ----------
C
C     CHECK FOR EOF
      IF(NEOT.EQ.1)
      ISAV(NSEC)=K-1
      IREC=IREC-1
      NEOT=0
      GO TO 311
      END IF
C
C     ---------- 10.0 ----------
C
C     RE-INITIALIZE
C
      ISAV(I)=1
      ISAV(NTOT)=0
C
      END IF
C
C     ---------- 11.0 ----------
C
C     DECODE THE IND VAR AND THE SYNCH WORD
C
      CALL MINID
      IF(IPDY.EQ.1)
      NO=1
      END IF
C
K     WRITE(KCHECK,701)VIND
C
C     ---------- 12.0 ----------
C
C     CHECK FOR VIND CONSISTENCY
C
      TEST=TAPE1+K*SAV(FRTIM)
      IF(TEST.EQ.VIND)
K 710 FORMAT(' CONSECUTIVE VINDS ENCOUNTERED',I5)
K     WRITE(KCHECK,710)K
      K=K+1
      ELSE
K 711 FORMAT(' NON-CONSECUTIVE VIND ENCOUNTERED',I5)
K     WRITE(KCHECK,711)K
      NO=1
      END IF
C
      EXIT IF(K.GT.ISAV(NSEC))
      EXIT IF(NO.EQ.1)
C
      END LOOP
C
  311 CONTINUE
C
      ITPOS=0
C
      IF(K.GT.ISAV(NSEC))
C
C     ---------- 13.0 ----------
C
      CALL BACKT
C
      ELSE
C
C     NON-CONSECUTIVE VIND ENCOUNTERED
C
K 716 FORMAT(' NON-CONSECUTIVE VIND ENCOUNTERED -- BEGIV, VIND ',
K    - 2F12.2)
K     WRITE(KCHECK,716)BEGIV,VIND
C
      IF(VIND.LT.VSTRT)
      GO TO 150
      OR IF(VIND.GE.VSTRT)
      GO TO 300
      END IF
      END IF
      ELSE
      ISAV(NUMLOG)=MLOG
      ISAV(NTOT)=MTOT
      ISAV(I)=II
      END IF
C
K     WRITE(KCHECK,707)MTOT,II,ISAV(NSEC)
C
      RETURN
      END
.EJECT
      SUBROUTINE BACKT
C
C     THIS ROUTINE BASKSPACES THE TAPE AFTER NSEC CONSECUTIVE IV'S
C     HAVE BEEN ENCOUNTERED
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
.USE  COMINA
      COMMON/TEMP/IREC,MTOT,II,K,MLOG
C
      DIMENSION MTYP(10),NAMSUB(2)
C
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
C
      DATA NAMSUB /4HBACK  ,2HT /
      DATA MTYP /1HC,1HI,1HI,1HC,1HI,1HC,1HI,1HC,1HI,1HI/
C
K 799 FORMAT(' AM IN BACKT')
K     WRITE(KCHECK,799)
C
C     ---------- 1.0 ----------
C
C     NSEC CONSECUTIVE IV'S HAVE BEEN ENCOUNTERED
C     BACKSPACE (KREC+1) RECORDS
C
      AT=1.1
      MSGVAL(1)=ICON(NSEC)
      CALL COMERR(232,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(2),1,1,2)
C
K 713 FORMAT(' THE REQUIRED NUMBER OF CONSECUTIVE IVS HAVE BEEN ENCOUNTE
K    -RED',I5)
K     WRITE(KCHECK,713)ISAV(NSEC)
K 714 FORMAT(' BACKSPACE THE TAPE',I5,'RECORDS')
K     WRITE(KCHECK,714)IREC
C
K 750 FORMAT(' IREC=',I10)
K     WRITE(KCHECK,750)IREC
      IT=ISAV(KIN)
      IF(IREC.GT.0)
      DO(J=1,IREC)
      BACKSPACE IT
      NAMREC(INNUM)=NAMREC(INNUM)-1
      END DO
      IT=ISAV(KIN)
      NAMREC(INNUM)=NAMREC(INNUM)-1
      BACKSPACE IT
      CALL READT
      END IF
C
      ISAV(NUMLOG)=MLOG
      ISAV(NTOT)=MTOT
      ISAV(I)=II
C
K 705 FORMAT(' FRAME NUMBER, RECORD NUMBER, WORD NUMBER,'3I5)
K     WRITE(KCHECK,705)ISAV(I),NAMREC(INNUM),ISAV(NTOT)
K 700 FORMAT(' RECORD NUMBER, STATUS OF READ ',2I5)
K     WRITE(KCHECK,700)NAMREC(INNUM),NSTATE
C
C
      RETURN
      END
.EJECT
      SUBROUTINE DCODE
C
C     THIS ROUTINE DECODES THE DATA
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
.NOREP
.USE  CASINT
.USE  COMINA
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
      DIMENSION NTYP(10)
T     DIMENSION MASK(63)
T     DATA MASK/2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
T    - 16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,
T    - 8388608,16777216,33554432,67108864,134217728,268435456,
T    - 536870912,1073741824,2147483648,4294967296,8589934592,
T    - 17179869184,34359738368,68719476736,137438953472,274877906944,
T    - 549755813888,1099511627776,2199023255552,4398046511104,
T    - 8796093022208,17592186044416,35184372088832,70368744177664,
T    - 140737488355328,281474976710656,562949953421312,
T    - 1125899906842624,2251799813685248,4503599627370496,
T    - 9007199254740992,18014398509481984,36028797018963968,
T    - 72057594037927936,144115188075855872,288230376151711744,
T    - 576460752303423488,1152921504606846976,2305843009213693952,
C    - 4611686018427387904,-9223372036854775808/
T    - 4611686018427387904,1000000000000000000000B/
C
R     DIMENSION MASK(31)
R     DATA MASK/2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
R    - 16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,
R    - 8388608,16777216,33554432,67108864,134217728,268435456,
R    - 536870912,1073741824,2147483648/
C
      INTEGER YES
      DATA NAMSUB,YES /4HDCOD  ,2HE ,3HYES/
      DATA MTYP /1HC,1HI,1HI,1HC,1HI,1HC,1HI,1HC,1HI,1HI/
      DATA NTYP /1HC,1HI,1HC,1HI,1HC,1HR,1HC,1HR,1HC,1HC/
C
K 760 FORMAT(' AM IN DECODE')
K     WRITE(KCHECK,760)
C
      KCDO=DELIV/SPACE(FRTIM)
C
      IF(KCDO.NE.1)
C
      CALL DCODE1
C
      ELSE
C
C     ---------- 1.0 ----------
C
C     SOME INITIALIZATION
C
      EPS=.01*DELIV
      VINDO=VALIV(LASTOP)-SPACE(FRTIM)
C
K 797 FORMAT(' VINDO ON ENTRY = ',F12.2)
K     WRITE(KCHECK,797)VINDO
      IF(ISAV(IVPR).EQ.1)
      AT=1.1
      MSGVAL(1)=VINDO
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(233,NAMSUB,AT,KINFO,MSGVAL(1),NTYP(6),1,1,2)
      KERR=KSAV
      END IF
C
C     ---------- 2.0 ----------
C
C     MAIN PROCESSING LOOP
C
      DO  (MCDO=1,NCDO)
K 730 FORMAT(' NCDO, MCDO = ',I5)
K     WRITE(KCHECK,730)NCDO,MCDO
C
C     IF THERE IS NO MORE DATA TO PROCESS
C
K 788 FORMAT(' ISAV(KSTOP) =',I5)
K     WRITE(KCHECK,788)ISAV(KSTOP)
      IF(ISAV(KSTOP).GT.0)
      TEST=0.0
      VINDN=VINDO
      GO TO 200
      END IF
C
  100 CONTINUE
C
C     ---------- 3.0 ----------
C
C     READ ANOTHER RECORD IF NECESSARY (FRAME COUNT .GE. NUMBER OF
C     FRAMES PER RECORD)
C
      IF(ISAV(I).GE.ISAV(DATLOG))
      CALL READT
      IF(IVOL.EQ.1)
      IFLG=0
      VINDT=VINDT+SPACE(FRTIM)
K 900 FORMAT(' CALL TPOS  - IN DCODE')
K     WRITE(KCHECK,900)
      CALL TPOS
      IVOL=0
      ELSE
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
      END IF
C
K     WRITE(KCHECK,788)ISAV(KSTOP)
      IF(ISAV(KSTOP).GT.0)
      TEST=0.0
      VINDN=VINDO
      GO TO 200
      END IF
C
      END IF
C
      ISAV(NUMLOG)=ISAV(NUMLOG)+1
      ISAV(NTOT)=ISAV(NTOT)+ISAV(LOGBIT)
      ISAV(I)=ISAV(I)+1
C
K 701 FORMAT(' NTOT, I =',2I10)
K     WRITE(KCHECK,701)ISAV(NTOT),ISAV(I)
C
C     ---------- 4.0 ----------
C
C     LOCATE THE INDEPENDENT VARIABLE(S) AND THE BITKEY
C
      CALL MINID
C
      VINDN=VIND
C
K 702 FORMAT(' VINDN = ',F12.2)
K     WRITE(KCHECK,702)VINDN
C
C     ---------- 5.0 ----------
C
C     CHECK FOR CONSISTENCY
C
      TEST=VINDO+SPACE(FRTIM)
      VINDT=TEST
      VINDO=TEST
C
K 703 FORMAT(' TEST =',F12.2)
K     WRITE(KCHECK,703)TEST
C
C     ---------- 6.0 ----------
C
C     SET UP SOME POINTERS
C
      NPT=LENCON
      IXC=SCLKEY-NPT
      IXK=CONKEY-NPT
      IXA=TERM-NPT
      IXP=FACTOR-NPT
      IXRI=NRI-NPT
      IXII=NII-NPT
      IXV=NAMEDP-NPT
      IXL=FSTBIT-NPT
      IXB=BITS-NPT
      IXS=SAMP-NPT
      IXRO=NRO-NPT
      IX1=BITS-NPT
      IX2=SKIP-NPT
      IXIO=NIO-NPT
      IEND=NUMVEC
C
K 710 FORMAT(' NPT,IXRI,IXV,IXL,IXRO,IXIO', 9I5)
K     WRITE(KCHECK,710)NPT,IXRI,IXV,IXL,IXRO,IXIO
C
K 789 FORMAT(' IN DCODE - - TEST, VINDN, EPS, DELX ', 2F12.2,2O23)
      DELX=ABS(VINDN-TEST)
K     WRITE(KCHECK,789)TEST,VINDN,EPS,DELX
C
      IF(DELX.LT.EPS)
C
      VINDO=VINDN
C
C     ---------- 7.0 ----------
C
C     GET THE DATA
C
      DO(K=1,IEND)
C
      IXC=IXC+NPT
      IXK=IXK+NPT
      IXA=IXA+NPT
      IX1=IX1+NPT
      IX2=IX2+NPT
      IXP=IXP+NPT
      IXRI=IXRI+NPT
      IXII=IXII+NPT
      IXV=IXV+NPT
      IXL=IXL+NPT
      IXB=IXB+NPT
      IXS=IXS+NPT
      IXRO=IXRO+NPT
      IXIO=IXIO+NPT
C
      NUMR=ISAV(IXRO)
      NAMEV=ISAV(IXV)
      IPUT=ISAV(IXIO)+(MCDO-1)*NUMR
C
K     WRITE(KCHECK,711)NUMR,IXV,NAMEV,IPUT
K 711 FORMAT(' NUMR,IXV,NAMEV,IPUT ',2I5,1A10,1I5)
K 790 FORMAT(' IXA,IX1,IX2,IXP,IXL,IXB,IXS =',7I5)
K     WRITE(KCHECK,790)IXA,IX1,IX2,IXP,IXL,IXB,IXS
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 3JUN85
C     IF(NAMEV.EQ.5HLORN1) WRITE(KCHECK,722)NUMR,IXV,NAMEV,IPUT
C     IF(NAMEV.EQ.5HLORN2) WRITE(KCHECK,722)NUMR,IXV,NAMEV,IPUT
C 722 FORMAT(' NUMR,IXV,NAMEV,IPUT ',2I5,1A10,1I5)
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c      PRINT 18,IX,NUMR,KK,ISAV(IX),NAMEV,ISAV(IXK)
 18   FORMAT(' DECODE1:IX,NUMR,KK,ISAV(IX),NAMEV,conkey - ',4I8,A8,i8)
C
C     ---------- 8.0 ----------
C
C     INPUT PARAMETERS
C
K 795 FORMAT(' ISAV(IXRI)',I5)
K     WRITE(KCHECK,795)ISAV(IXRI)
C
      IF(ISAV(IXRI).EQ.0)
C
      I0=ISAV(IXL)+ISAV(NTOT)
C
      I1=I0/BITNSU+1
      I2=MOD(I0,BITNSU)-1
      IF(I2.LT.0)
      I2=I2+BITNSU
      I1=I1-1
      END IF
      I3=ISAV(IXB)
C
      NBUF=LOCSAV(THISOP)
      N1=NBUF+I1-1
      N2=IPUT
      N3=I2
      N4=IX2
      N5=IXS
      N6=I3
C
  782 FORMAT(' I1,N1,N2,N3,N4,N5,N6 = ',7I5)
C     WRITE(KCHECK,782)I1,N1,N2,N3,N4,N5,N6
K 785 FORMAT(' ISAV(N1) = ',O26)
K     WRITE(KCHECK,785)ISAV(N1)
C
      ISAV(N2)=0
C
.USE  GBYTES
C
K 791 FORMAT(' ISAV(N2) = ',O25)
K     WRITE(KCHECK,791)ISAV(N2)
C
C     ---------- 9.0 ----------
C
C     CONKEY - CONVERSION KEY APPLIES THE APPROPRIATE CONVERSION TO
C              THE BITS REPRESENTING THE DEP. VAR. VALUE.
C
C     NO CONVERSION NEEDED FOR A REAL VALUE
C     CONKEY = 0
C
K 800 FORMAT(' CONKEY = ',I10)
K     WRITE(KCHECK,800)ISAV(IXK)
c      PRINT 1840,IX,IXA,IXP,SPACE(IXA),SPACE(IXP),NAMEV,TEST
 1840 FORMAT(' DECODE:IX,IXA,IXP,ADD,P,NAMEV,TEST',3I8,2F9.2,A8,F9.1)
      IF(ISAV(IXK).EQ.0)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
c      IF(NAMEV.EQ.'DME') PRINT 1849,IX,NUMR,KK,ISAV(IX),SAV(IX),NAMEV
      END DO
C
C     NO CONVERSION NEEDED FOR AN INTEGER VALUE
C     CONKEY = 1
C
      OR IF(ISAV(IXK).EQ.1)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      SAV(IX) = ISAV(IX)
 1849 FORMAT(' DEC:IX,NUMR,KK,ISAV,SAV,NAMEV ',4I8,F9.2,A8)
C     PRINT 1849,IX,NUMR,KK,ISAV(IX),SAV(IX),NAMEV
C     IF(NAMEV.EQ.2HHR .OR. NAMEV.EQ.3HMIN) PRINT 1849,IX,NUMR,KK,
C    1      SAV(IX),NAMEV
c 1849 FORMAT(' DEC:KEY1,IX,NUMR,KK,ISAV,SAV,NAMEV ',4I8,F9.2,A8)
      END DO
C
C     USE CONKEY TO PUT INPUT PARAMETERS INTO +/- RANGE
C     CONKEY = 2
C
      OR IF(ISAV(IXK).EQ.2)
K 851 FORMAT(' THE MASK() ARRAY = '/4O26)
C     WRITE(KCHECK,851)(MASK(III),III=1,63)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
C
K 850 FORMAT(' ISAV(IXB)=BITS= ',I10)
K     WRITE(KCHECK,850)ISAV(IXB)
C
      IF(ISAV(IXB).LT.BITNSU)
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.ISAV(IX))
V     MAX1=(MAX1.AND.ISAV(IX))
M     MAX1=IAND(MAX1,ISAV(IX))
C
K 767 FORMAT(' I1, MASK(I1),ISAV(IX), MAX1 =',/4O26)
K     WRITE(KCHECK,767)ISAV(IX),MAX1
C
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      ISAV(IX)=ISAV(IX)-MASK(I1)
      END IF
      END IF
      SAV(IX)=ISAV(IX)
      END DO
C
      OR IF(ISAV(IXK).EQ.3)
C
C     THIS CONKEY MOVES THE LOW 8 BITS TO THE HIGH 8 BITS AND VISA VERSA
C                             (NCAR SAILPLANE)
C     CONKEY = 3
C
      MASK1=2**8-1
      MASK2=2**16-1
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
K 770 FORMAT(' ISAV(IX), MASK1, MASK2 ',3O25)
K     WRITE(KCHECK,770)ISAV(IX),MASK1,MASK2
H     ISAV(IX)=ISAV(IX).AND.MASK2
V     ISAV(IX)=ISAV(IX).AND.MASK2
G     ISAV(IX)=ISAV(IX).AND.MASK2
M     ISAV(IX)=IAND(ISAV(IX),MASK2)
K 771 FORMAT(' ISAV(IX) ',O25)
K     WRITE(KCHECK,771)ISAV(IX)
V     ITEMP=ISAV(IX).AND.MASK1
H     ITEMP=ISAV(IX).AND.MASK1
G     ITEMP=ISAV(IX).AND.MASK1
M     ITEMP=IAND(ISAV(IX),MASK1)
K 772 FORMAT(' ITEMP ',O25)
K     WRITE(KCHECK,772)ITEMP
      ITEMP=ITEMP*2**8
K     WRITE(KCHECK,772)ITEMP
      ISAV(IX)=ISAV(IX)/2**8
K     WRITE(KCHECK,771)ISAV(IX)
H     ISAV(IX)=ISAV(IX).OR.ITEMP
V     ISAV(IX)=ISAV(IX).OR.ITEMP
G     ISAV(IX)=ISAV(IX).OR.ITEMP
M     ISAV(IX)=IOR(ISAV(IX),ITEMP)
K     WRITE(KCHECK,771)ISAV(IX)
      SAV(IX)=ISAV(IX)
      END DO
C
C     T28 INDEPENDENT VARIABLE
C     CONKEY=4
C
      OR IF(ISAV(IXK).EQ.4)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      ITEMP=ISAV(IX)
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
      ISAV(IX)=ITEMP
K 775 FORMAT(' IHR,IMIN,ISEC,ITEMP',4I10)
K     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
      SAV(IX)=ISAV(IX)
      END DO
C
C     STORE THE INPUT IV INTO ANOTHER DEPENDENT VARIABLE
C     CONKEY=5
C
      OR IF(ISAV(IXK).EQ.5)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      SAV(IX)=VIND
      END DO
C
C     THIS CONKEY COMPLIMENTS THE DATUM
C     CONKEY=6
C
      OR IF(ISAV(IXK).EQ.6)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
K 888 FORMAT(' ISAV(IX)/BEFORE NOT = ',O25)
K     WRITE(KCHECK,888)ISAV(IX)
      ISAV(IX)=.NOT.ISAV(IX)
K 889 FORMAT(' ISAV(IX)/AFTER NOT = ',O25)
K     WRITE(KCHECK,889)ISAV(IX)
      IF(ISAV(IXB).LT.BITNSU)
      MSK=2**(ISAV(IXB))-1
      ISAV(IX)=ISAV(IX).AND.MSK
      END IF
K     WRITE(KCHECK,889)ISAV(IX)
      SAV(IX)=ISAV(IX)
      END DO
C
C     THIS CONKEY DOES A COMPLIMENT OF THE DATUM FOLLOWED IMMEDIATELY
C     BY THE CONVERSION ALGORITHM OF CONKEY = 2
C     CONKEY=7
C
      OR IF(ISAV(IXK).EQ.7)
      IX=IPUT-1
c      print 4005,namev,test,bitnsu,isav(ixb)
 4005 format(' namev, time,bitnsr,isav(ixb) ',a8,f12.2,2i8)
CDIR$ NEXTSCALAR
      DO(KK=1,NUMR)
      IX=IX+1
 4003 FORMAT(' DCODE before not-namev,test,KK,IX,ISAV ',a8,f10.1,3I9)
c      if(kk.eq.1)PRINT 4003,namev,test,KK,IX,ISAV(IX)
K     WRITE(KCHECK,888)ISAV(IX)
      ISAV(IX)=.NOT.ISAV(IX)
C
c      IF(NAMEV.EQ.'PSFD') PRINT 4001, KK,IX,ISAV(IX)
c 4001  FORMAT(' DCODE- PSFD: KK,IX,ISAV ',3I9)
 4002  FORMAT(' DCODE after not- ISAV ',I9)
c       if(kk.eq.1)PRINT 4002,ISAV(IX)
K     WRITE(KCHECK,889)ISAV(IX)
K     WRITE(KCHECK,850)ISAV(IXB)
C
      IF(ISAV(IXB).LT.BITNSU)
      MSK=2**(ISAV(IXB))-1
      ISAV(IX)=ISAV(IX).AND.MSK
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.ISAV(IX))
V     MAX1=(MAX1.AND.ISAV(IX))
M     MAX1=IAND(MAX1,ISAV(IX))
C
K     WRITE(KCHECK,767)ISAV(IX),MAX1
C
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      ISAV(IX)=ISAV(IX)-MASK(I1)
      END IF
      END IF
 4004  FORMAT(' DCODE after masking ISAV ',I9)
c       if(kk.eq.1)PRINT 4004,ISAV(IX)
      SAV(IX)=ISAV(IX)
      END DO
C--------------------------------------- CONKEY=9 ---------------------
C     THIS CONKEY CONVERTS HP REAL NUMBER AND PUT IT INTO SCALED INTEGER
C     BY THE CONVERSION ALGORITHM OF CONKEY = 9
C     CONKEY=9
C
      OR IF(ISAV(IXK).EQ.9)
      IX=IPUT-1
      DO(KK=1,NUMR)
       IX=IX+1
       CALL HPREAL(ISAV(IX),REAL)
       SAV(IX) = REAL
C      ISAV(IX)=SAV(IX)
      END DO
C--------------------------------------- CONKEY =  8  -------------
C**  JOINT HAWAII PROJECT 1985   SEPT. 04, 1985 (CC)
C
C     WYOMING KING AIR ARCHIVE TAPE  INDEPENDENT VARIABLE
C     CONKEY= 8
C
      OR IF(ISAV(IXK).EQ. 8)
      IX=IPUT-1
      DO(KK=1,NUMR)
       IX=IX+1
       CALL HPREAL(ISAV(IX),REAL)
       SAV(IX) = REAL
       ISAV(IX)=SAV(IX)
C-----
      ITEMP=ISAV(IX)
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
      ISAV(IX)=ITEMP
C 775 FORMAT(' IHR,IMIN,ISEC,ITEMP',4I10)
C     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
      SAV(IX)=ISAV(IX)
      END DO
C--------------------------------------- END OF CONKEY=8      -----
C----------------------  CONKEY=10 --------------------
C     2UW FLAG WORD
C     CONKEY=10
C
      OR IF(ISAV(IXK).EQ.10)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      ITEMP=ISAV(IX)
      IFLG=ITEMP/100
      ITEMP=ITEMP-IFLG*100
      ISAV(IX)=ITEMP
  775 FORMAT(' ITEMP-2UW FLAG WORD = ', I10)
C     WRITE(KCHECK,775)ITEMP
      SAV(IX)=ISAV(IX)
      END DO
C
C--------------------------------------- CONKEY=11 ---------------------
C     THIS CONKEY CONVERTS IEEE REAL NUMBER AND PUT IT INTO
C     CRAY REAL NUMBER
C     CONKEY=11
C
      OR IF(ISAV(IXK).EQ.11)
      IX=IPUT-1
      DO(KK=1,NUMR)
       IX=IX+1
C      WRITE(KCHECK,888)ISAV(IX)
  888 FORMAT(' ISAV(IX) = ',O25)
       CALL I3ER(ISAV(IX),REAL)
C      PRINT 4000, NAMEV,ISAV(IX),REAL
 4000  FORMAT(' DCODE1- NAMEV,ISAV,REAL ',A8,O25,F10.3)
       SAV(IX) = REAL
C      ISAV(IX)=SAV(IX)
      END DO
C--------------------------------------- END OF CONKEY=11 ----------
      END IF
C
C     ---------- 10.0 ----------
C
C     SCALE THE INPUT PARAMETERS
C
      IX=IPUT-1
      IF(ISAV(IXC).EQ.1)
C     WRITE(KCHECK,734) NAMEV,TEST,ISAV(IX)
  734 FORMAT(' NAMEV,TIME,ISAV(IX)    ',A8,F12.3,I8)
C
      OR IF(ISAV(IXC).EQ.2)
c      PRINT 2083,NAMEV,TEST,SAV(IX),SPACE(IXP),SPACE(IXA)
 2083 FORMAT(' DCODE:NAMEV,TIME,SAV(IX),P,A - ',A8,4F12.3)
      DO(KK=1,NUMR)
      IX=IX+1
C     PRINT 720,SPACE(IXP),SPACE(IXA)
      SPACE(IX)=(SAV(IX)/SPACE(IXP))-SPACE(IXA)
  720 FORMAT(' DECODE:namev,time,KK,SCALED ',a8,f10.1,I4,F12.5)
c      if(nstage.eq.4.and.kk.eq.1)PRINT 720,namev,test,KK,SPACE(IX)
      END DO
C
      END IF
C
      ELSE
C
C     ---------- 11.0 ----------
C
C     PASSED PARAMETERS
C
K 753 FORMAT(' ISAV(IXII),MCDO, NUMR,IGET ',4I7)
K     WRITE(KCHECK,753)ISAV(IXII),MCDO,NUMR,IGET
C
      IGET=ISAV(IXII)+(MCDO-1)*NUMR
      CALL MOVESP(ISAV,IGET,1,ISAV,IPUT,1,NUMR)
C
      END IF
C
      END DO
C
      END IF
C
C     ---------- 12.0 ----------
C
C     INDEPENDENT VARIABLE INCONSISTENCY
C
  200 CONTINUE
C
K     WRITE(KCHECK,788)ISAV(KSTOP)
K     WRITE(KCHECK,789)TEST,VINDN,EPS,DELX
C
      IF(DELX.GT.EPS.OR.ISAV(KSTOP).GT.0)
      IF(VINDN.GT.TEST.OR.ISAV(KSTOP).GT.0)
C
C     ---------- 13.0 ----------
C
C     FILL IN DATA GAP WITH GAPVAL
C
      IXRI=NRI-LENCON
      IXRO=NRO-LENCON
      IXII=NII-LENCON
      IXIO=NIO-LENCON
C
      DO(K=1,NUMVEC)
      IXRI=IXRI+LENCON
      IXRO=IXRO+LENCON
      IXII=IXII+LENCON
      IXIO=IXIO+LENCON
      NUMR=ISAV(IXRO)
      IPUT=ISAV(IXIO)+(MCDO-1)*NUMR
C
K 751 FORMAT(' IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC ',6I5)
K     WRITE(KCHECK,751)IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC
K 752 FORMAT(' NUMR, IPUT',2I10)
K     WRITE(KCHECK,752)NUMR,IPUT
C
C     ---------- 14.0 ----------
C
C     INPUT PARAMETERS
C
      IF(ISAV(IXRI).EQ.0)
C
      DO(KK=1,NUMR)
      SPACE(IPUT)=GAPVAL
      IPUT=IPUT+1
      END DO
C
      ELSE
C
C     ---------- 15.0 ----------
C
C     PASSED PARAMETERS
C
      IGET=ISAV(IXII)+(MCDO-1)*NUMR
      CALL MOVESP(ISAV,IGET,1,ISAV,IPUT,1,NUMR)
C
      END IF
C
      END DO
C
      ISAV(NTOT)=ISAV(NTOT)-ISAV(LOGBIT)
      ISAV(I)=ISAV(I)-1
      ISAV(NUMLOG)=ISAV(NUMLOG)-1
K 755 FORMAT(' IN DCODE - - ISAV(NTOT),ISAV(I) = ',2I10)
K     WRITE(KCHECK,755)ISAV(NTOT),ISAV(I)
C
      OR IF(VINDN.LT.TEST)
C
      VINDO=VINDO-SPACE(FRTIM)
      GO TO 100
C
      END IF
C
      END IF
C
      END DO
C
      END IF
C
C     ---------- 16.0 ----------
C
C     RELEASE/REWIND VOLUMES WHEN LAST IV IS PROCESSED
C     FOR THE LAST CASE INTERVAL
C
      TESTL=ENDIV-DELIV
      IF(ISAV(KSTOP).GT.0.OR.VINDT.GE.TESTL)
      IF(ISAV(KSTOP).NE.2.AND.IVINT.EQ.IVINTS)
      ISAV(KSTOP)=2
      IUNIT=ISAV(KIN)
C     CALL REWIND(IUNIT)
C
H     IF(ICON(JCL).NE.YES)
H1000 FORMAT('fort.',I2)
H     ENCODE(7,1000,NAMEK)IUNIT
C H     CALL RELEASE(IER,'DN',NAMEK)
      CLOSE(UNIT=IUNIT,IOSTAT=IOS,ERR=829)
C      CLOSE(UNIT=IUNIT,STATUS='DELETE',IOSTAT=IOS,ERR=829)
H     END IF
C
      IF(ISAV(NAMKEY).GT.0.AND.ISAV(IKOUNT).GT.0)
      AT = 16.1
      MSGVAL(1)=ISAV(IKOUNT)
      MSGVAL(2)=INNUM
      CALL COMERR(240,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(2),1,2,2)
      END IF
C
      END IF
      END IF
C
C     ----------------------------------------------------------------
C
C     PRINT THE SPACE() ARRAY AFTER STORAGE
C
      IF(ISAV(IVPR).GT.0)
C
      NPT=LENCON
      IX=ISAV(NIO)
      IDX1=NRO+NPT*(NUMVEC-1)
      IDX2=NIO+NPT*(NUMVEC-1)
      IY=ISAV(IDX2)+ISAV(IDX1)*NCDO
K 799 FORMAT('IX,IDX1,IDX2,IY= ',4I5)
K     WRITE(KCHECK,799)IX,IDX1,IDX2,IY
      CALL COMERR(241,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,0,1)
  704 FORMAT(10F10.3)
      WRITE(KCHECK,704)(SPACE(KK),KK=IX,IY)
      CALL COMERR(0,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,0,3)
C
      END IF
C
C
      RETURN
  829 print 828,iunit
  828 format(' dcode: error occurs on nunit ',i5)
      END
.EJECT
      SUBROUTINE MINID
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
.NOREP
.USE  COMINA
      DATA NAMSUB /4HMINI  ,2HD /
C
K 700 FORMAT(' AM IN SUBROUTINE MINID ')
K     WRITE(KCHECK,700)
C
      CALL MINID1
C
K 750 FORMAT(' AFTER MINID1, VIND =', F12.2)
K     WRITE(KCHECK,750)VIND
C
      IF(NSTAGE.GE.4)
C
      IF(VIND.EQ.0.0)RETURN
C
      EPS=.01*DELIV
      TEST =ABS( (VINDO+SAV(FRTIM))-VIND )
      IF(TEST.GT.EPS)
      TEST =ABS( TEST-SAV(MAXIV) )
      IF(TEST.LT.EPS)
      VIND=VIND+SAV(MAXIV)
      SAV(OFFSET)=SAV(OFFSET)+SAV(MAXIV)
      ELSE
      CALL TESTIV
      END IF
      END IF
C
      END IF
C
K 702 FORMAT(' VIND  = ',F12.2)
K     WRITE(KCHECK,702)VIND
C
C
K 780 FORMAT(' IN MINID - - VINDO, VIND, BEGIV, ENDIV = ',4F12.2)
K     WRITE(KCHECK,780)VINDO,VIND,BEGIV,ENDIV
      RETURN
      END
.EJECT
      SUBROUTINE MINID1
C
C     THIS IS MINI DECODE ROUTINE TO DECODE THE IND VAR AND THE SYNCH
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
.NOREP
.USE  COMINA
      DIMENSION NTYP(10),LTYP(10),JTYP(10)
      EQUIVALENCE (TEMP,ITEMP)
      EQUIVALENCE (KTEMP,RTEMP)
      EQUIVALENCE (N2,XN2)
C
      DATA JTYP /1HC,1HI,1HI,1HI,1HI,1HI,1HI,1HI,1HI,1HI/
      DATA MTYP /1HC,1HI,1HI,1HC,1HI,1HC,1HI,1HC,1HI,1HI/
      DATA NTYP /1HC,1HI,1HC,1HI,1HC,1HR,1HC,1HR,1HC,1HC/
      DATA LTYP /1HI,1HI,1HI,1HI,1HR,1HR,1HR,1HI,1HI,1HI/
      DATA NAMSUB /4HMINI  ,2HD1/
C
T     DIMENSION MASK(63)
T     DATA MASK/2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
T    - 16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,
T    - 8388608,16777216,33554432,67108864,134217728,268435456,
T    - 536870912,1073741824,2147483648,4294967296,8589934592,
T    - 17179869184,34359738368,68719476736,137438953472,274877906944,
T    - 549755813888,1099511627776,2199023255552,4398046511104,
T    - 8796093022208,17592186044416,35184372088832,70368744177664,
T    - 140737488355328,281474976710656,562949953421312,
T    - 1125899906842624,2251799813685248,4503599627370496,
T    - 9007199254740992,18014398509481984,36028797018963968,
T    - 72057594037927936,144115188075855872,288230376151711744,
T    - 576460752303423488,1152921504606846976,2305843009213693952,
C    - 4611686018427387904,-9223372036854775808/
T    - 4611686018427387904,1000000000000000000000B/
C
R     DIMENSION MASK(31)
R     DATA MASK/2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
R    - 16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,
R    - 8388608,16777216,33554432,67108864,134217728,268435456,
R    - 536870912,1073741824,2147483648/
C
C
K 799 FORMAT(' AM IN MINID1')
K     WRITE(KCHECK,799)
K 725 FORMAT(' THE INPUT SAVE SPACE'/(5O24))
K     K1=LOCSAV(THISOP)
K     K2=K1+LENSAV(THISOP)
K     WRITE(KCHECK,725)(ISAV(KKK),K1,K2)
C
C
      IF(ISAV(I).GT.ISAV(DATLOG))
      RETURN
      END IF
C
C     ---------- 0.0 ----------
C
C     CHECK THE SYNCH WORD IF THERE IS ONE
C
K 703 FORMAT(' PARAMETER NUMBER OF SYNCH WORD ',I5)
K     WRITE(KCHECK,703)ISAV(NAMKEY)
      IPDY=0
      IF(ISAV(NAMKEY).GT.0)
      JJ=ISAV(NAMKEY)-1
      IND1=FACTOR+JJ*LENCON
      IND2=TERM+JJ*LENCON
      IND3=CONKEY+JJ*LENCON
      IND4=SCLKEY+JJ*LENCON
      IXB=BITS+JJ*LENCON
      I0=FSTBIT+JJ*LENCON
      I0=ISAV(I0)+ISAV(NTOT)
      I1=I0/BITNSU+1
      I2=MOD(I0,BITNSU)-1
      IF(I2.LT.0)
      I2=I2+BITNSU
      I1=I1-1
      END IF
      I3=BITS+JJ*LENCON
      I3=ISAV(I3)
C
      N1=LOCSAV(THISOP)+I1-1
      N3=I2
      N4=I3
C     WRITE(KCHECK,710)IND1,IND2,I0,I1,I2,I3,N1,N3,N4
.USE  GBYTE
C     WRITE(KCHECK,7751)ISAV(N1),N2
 7751 FORMAT('ISAV(N1),N2 ',2I6)
      ITEMP=N2
C
C     ---------- 0.5 ----------
C
C     USE CONKEY
C
      IF(ISAV(IND3).EQ.0)
C
      OR IF(ISAV(IND3).EQ.1)
C
      XN2=N2
C     PRINT 8,N2,XN2
   8  FORMAT(' CONKEY=1, N2,XN2 ',I4,F6.2)
C
      OR IF(ISAV(IND3).EQ.2)
C
      IF(ISAV(IXB).LT.BITNSU)
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
V     MAX1=(MAX1.AND.N2)
H     MAX1=(MAX1.AND.N2)
M     MAX1=IAND(MAX1,N2)
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      N2=N2-MASK(I1)
      END IF
      END IF
      XN2=N2
C
      OR IF(ISAV(IND3).EQ.3)
C
C     THIS CONKEY MOVES THE LOW 8 BITS TO THE HIGH 8 BITS AND VISA VERSA
C                             (NCAR SAILPLANE)
      MASK1=2**8-1
      MASK2=2**16-1
K     WRITE(KCHECK,770)ISAV(IX),MASK1,MASK2
H     N2=N2.AND.MASK2
V     N2=N2.AND.MASK2
G     N2=N2.AND.MASK2
M     N2=IAND(N2,MASK2)
K     WRITE(KCHECK,771)N2
G     ITEMP=N2.AND.MASK1
H     ITEMP=N2.AND.MASK1
V     ITEMP=N2.AND.MASK1
M     ITEMP=IAND(N2,MASK1)
K     WRITE(KCHECK,772)ITEMP
      ITEMP=ITEMP*2**8
K     WRITE(KCHECK,772)ITEMP
      N2=N2/2**8
K     WRITE(KCHECK,771)N2
V     N2=N2.OR.ITEMP
H     N2=N2.OR.ITEMP
G     N2=N2.OR.ITEMP
M     N2=IOR(N2,ITEMP)
      XN2=N2
K     WRITE(KCHECK,771)N2
C
C     T28 INDEPENDENT VARIABLE          (CONKEY=4)
C
      OR IF(ISAV(IND3).EQ.4)
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
      XN2=ITEMP
K     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
C
C     THIS CONKEY COMPLIMENTS THE DATUM
C
      OR IF(ISAV(IND3).EQ.6)
      N2=.NOT.N2
      IF(ISAV(IXB).LT.BITNSU)
      MSK=2**(ISAV(IXB))-1
      N2=N2.AND.MSK
      END IF
      XN2=N2
C
C     DO A ONES COMPLIMENT ON THE INCOMING DATUM AND THEN APPLY THE
C     CONKEY = 2 CODE
C
      OR IF(ISAV(IND3).EQ.7)
      N2 =.NOT.N2
      IF(ISAV(IXB).LT.BITNSU)
      MSK=2**(ISAV(IXB))-1
      N2=N2.AND.MSK
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.N2)
V     MAX1=(MAX1.AND.N2)
M     MAX1=IAND(MAX1,N2)
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      N2=N2-MASK(I1)
      END IF
      END IF
      XN2=N2
C--------------------------------------- CONKEY=9 ---------------------
C     THIS CONKEY CONVERTS HP REAL NUMBER AND PUT IT INTO SCALED INTEGER
C     BY THE CONVERSION ALGORITHM OF CONKEY = 9
C     CONKEY=9
C
      OR IF(ISAV(IND3).EQ.9)
       CALL HPREAL(N2,XN2)
C
C--------------------------------------- CONKEY =  8  -------------
C**  JOINT HAWAII PROJECT 1985   SEPT. 04, 1985 (CC)
C
C     WYOMING KING AIR ARCHIVE TAPE  INDEPENDENT VARIABLE
C     CONKEY= 8
C
      OR IF(ISAV(IND3).EQ. 8)
       CALL HPREAL(N2,SN2)
       N2 = SN2
C-----
      ITEMP=N2
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
  775 FORMAT(' MINID1-IHR,IMIN,ISEC,ITEMP',4I10)
C     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
      XN2 = ITEMP
C--------------------------------------- END OF CONKEY= 8    -----
C----------------------  CONKEY=10 --------------------
C     2UW FLAG WORD
C     CONKEY=10
C
      OR IF(ISAV(IXK).EQ.10)
       CALL HPREAL(N2,XN2)
       N2 = XN2
      ITEMP=N2
      IFLG=ITEMP/100
      ITEMP=ITEMP-IFLG*100
      XN2 = ITEMP
C--------------------------------------- CONKEY=11 --------------------
C     THIS CONKEY CONVERTS IEEE REAL NUMBER AND PUT IT INTO CRAY REAL
C     NUMBER
C     CONKEY=11
C
      OR IF(ISAV(IND3).EQ.11)
       CALL I3ER  (N2,XN2)
C      PRINT 4000,NAMEV,N2,XN2
 4000  FORMAT(' DCODE - NAMEV,N2,XN2  - ',A8,O25,F10.3)
C--------------------------------------- END OF CONKEY=11 ---------
C
      END IF
C
      TEMP=XN2
C
C     ---------- 0.6 ----------
C
C     USE SCLKEY
C
      IF(ISAV(IND4).EQ.1)
C
      OR IF(ISAV(IND4).EQ.2)
C
      TEMP=TEMP/SAV(IND1)-SAV(IND2)
C
      END IF
C
C     ---------- 0.7 ----------
C
C     CHECK BIT PATTERN TO DETERMINE PARITY ERROR
C
      ITEMP = TEMP + .001
C
K 765 FORMAT(' ITEMP, ISAV(BITKEY)',2I20)
K     WRITE(KCHECK,765)ITEMP,ISAV(BITKEY)
      IF(ITEMP.NE.ISAV(BITKEY))
      IF(ISAV(KOUNT).EQ.1)
      AT=.71
      MSGVAL(1)=NAMVOL(INNUM)
      MSGVAL(2)=NAMFIL(INNUM)
      MSGVAL(3)=NAMREC(INNUM)
      MSGVAL(4)=ISAV(I)
      MSGVAL(5)=NUNIT(INNUM)
      CALL COMERR(237,NAMSUB,AT,KWARN,MSGVAL(1),JTYP(1),1,5,2)
      END IF
      ISAV(IKOUNT) = ISAV(IKOUNT) + 1
      IPDY=1
K 766 FORMAT(' IKOUNT = ',I20)
K     WRITE(KCHECK,766)ISAV(IKOUNT)
      VIND=0.0
C
      IF(ISAV(IVPR).EQ.1)
      AT=.72
      MSGVAL(1)=NAMVOL(INNUM)
      MSGVAL(2)=NAMFIL(INNUM)
      MSGVAL(3)=NAMREC(INNUM)
      MSGVAL(4)=ISAV(I)
      MSGVAL(5)=NUNIT(INNUM)
      CALL COMERR(237,NAMSUB,AT,KWARN,MSGVAL(1),JTYP(1),1,5,2)
      END IF
C
      RETURN
C
      END IF
C
      END IF
C
C     ---------- 1.0 ----------
C
C     LOCATE THE INDEPENDENT VARIABLE(S)
C
      IF(ISAV(IVTYPE).EQ.1)
C
      VIND=0.0
      NIV=LENCNV
K 700 FORMAT(' NIV=',I5)
K     WRITE(KCHECK,700)NIV
      DO (K=1,NIV)
      JJ=ISAV(IVNAM+K-1)-1
K 701 FORMAT(' JJ=',I5)
K     WRITE(KCHECK,701)JJ
      IND1=FACTOR+JJ*LENCON
      IND2=TERM+JJ*LENCON
      IND3=CONKEY+JJ*LENCON
      IND4=SCLKEY+JJ*LENCON
      IXB=BITS+JJ*LENCON
      I0=FSTBIT+JJ*LENCON
      I0=ISAV(I0)+ISAV(NTOT)
      I1=I0/BITNSU+1
      I2=MOD(I0,BITNSU)-1
      IF(I2.LT.0)
      I2=I2+BITNSU
      I1=I1-1
      END IF
      I3=BITS+JJ*LENCON
      I3=ISAV(I3)
C
      N1=LOCSAV(THISOP)+I1-1
      N3=I2
      N4=I3
  710 FORMAT(' IND1,IND2,I0,I1,I2,I3,N1,N3,N4 = ',9I5)
C     WRITE(KCHECK,710)IND1,IND2,I0,I1,I2,I3,N1,N3,N4
.USE  GBYTE
C     WRITE(KCHECK,751)ISAV(N1),N2
  751 FORMAT('ISAV(N1),N2 ',2I6)
K 760 FORMAT(' IVPR, ISAV(IVPR)',2I5)
K     WRITE(KCHECK,760)IVPR,ISAV(IVPR)
      IF(ISAV(IVPR).EQ.1)
      AT=1.1
      MSGVAL(1)=ISAV(N1)
      MSGVAL(2)=N2
      MSGVAL(3)=N3
      MSGVAL(4)=N4
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(236,NAMSUB,AT,KINFO,MSGVAL(1),LTYP(1),1,4,2)
      KERR=KSAV
      END IF
C
C     ---------- 2.0 ----------
C
C     USE CONKEY
C
      IF(ISAV(IND3).EQ.1)
C
      XN2 = N2
C
      OR IF(ISAV(IND3).EQ.2)
C
      IF(ISAV(IXB).LT.BITNSU)
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.N2)
V     MAX1=(MAX1.AND.N2)
M     MAX1=IAND(MAX1,N2)
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      N2=N2-MASK(I1)
      END IF
      END IF
      XN2=N2
C
      OR IF(ISAV(IND3).EQ.3)
C
C     THIS CONKEY MOVES THE LOW 8 BITS TO THE HIGH 8 BITS AND VISA VERSA
C
      MASK1=2**8-1
      MASK2=2**16-1
K 770 FORMAT(' ISAV(IX), MASK1, MASK2 ',3O25)
K     WRITE(KCHECK,770)ISAV(IX),MASK1,MASK2
V     N2=N2.AND.MASK2
H     N2=N2.AND.MASK2
G     N2=N2.AND.MASK2
M     N2=IAND(N2,MASK2)
K 771 FORMAT(' ISAV(IX) ',O25)
K     WRITE(KCHECK,771)N2
V     ITEMP=N2.AND.MASK1
H     ITEMP=N2.AND.MASK1
G     ITEMP=N2.AND.MASK1
M     ITEMP=IAND(N2,MASK1)
K 772 FORMAT(' ITEMP ',O25)
K     WRITE(KCHECK,772)ITEMP
      ITEMP=ITEMP*2**8
K     WRITE(KCHECK,772)ITEMP
      N2=N2/2**8
K     WRITE(KCHECK,771)N2
V     N2=N2.OR.ITEMP
H     N2=N2.OR.ITEMP
G     N2=N2.OR.ITEMP
M     N2=IOR(N2,ITEMP)
K     WRITE(KCHECK,771)N2
      XN2=N2
C
C     T28 INDEPENDENT VARIABLE          (CONKEY=4)
C
      OR IF(ISAV(IND3).EQ.4)
      ITEMP=N2
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
      XN2=ITEMP
K 775 FORMAT(' IHR,IMIN,ISEC,ITEMP',4I10)
K     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
C
C     THIS CONKEY COMPLIMENTS THE DATUM
C
      OR IF(ISAV(IND3).EQ.6)
      N2   =.NOT.N2
      XN2=N2
C
C     DO A ONES COMPLIMENT ON THE INCOMING DATUM AND THEN APPLY THE
C     CONKEY = 2 CODE
C
      OR IF(ISAV(IND3).EQ.7)
      N2=.NOT.N2
      IF(ISAV(IXB).LT.BITNSU)
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.N2)
V     MAX1=(MAX1.AND.N2)
M     MAX1=IAND(MAX1,N2)
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      N2=N2-MASK(I1)
      END IF
      END IF
      XN2=N2
C--------------------------------------- CONKEY=9 ---------------------
C     THIS CONKEY CONVERTS HP REAL NUMBER AND PUT IT INTO CRAY REAL
C     BY THE CONVERSION ALGORITHM OF CONKEY = 9
C     CONKEY=9
C
      OR IF(ISAV(IND3).EQ.9)
       CALL HPREAL(N2,XN2)
C--------------------------------------- END OF CONKEY=9 ----------
C
C--------------------------------------- CONKEY =  8  -------------
C**  JOINT HAWAII PROJECT 1985   SEPT. 04, 1985 (CC)
C
C     WYOMING KING AIR ARCHIVE TAPE  INDEPENDENT VARIABLE
C     CONKEY= 8
C
      OR IF(ISAV(IND3).EQ. 8)
       CALL HPREAL(N2,XN2)
       N2 =XN2
C-----
      ITEMP=N2
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
C     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
      XN2 = ITEMP
C--------------------------------------- END OF CONKEY= 8    -----
C----------------------  CONKEY=10 --------------------
C     2UW FLAG WORD
C     CONKEY=10
C
      OR IF(ISAV(IXK).EQ.10)
      CALL HPREAL(N2,XN2)
      N2 = XN2
      ITEMP= N2
      IFLG=ITEMP/100
      ITEMP=ITEMP-IFLG*100
      N2 =ITEMP
C 775 FORMAT(' ITEMP-2UW FLAG WORD = ', I10)
C     WRITE(KCHECK,775)ITEMP
      XN2 = N2
C--------------------------------------- CONKEY=11 ---------------------
C     THIS CONKEY CONVERTS IEEE REAL NUMBER AND PUT IT INTO CRAY REAL
C
C     CONKEY=11
C
      OR IF(ISAV(IND3).EQ.11)
       CALL I3ER(N2,XN2)
C      PRINT 4001,NAMEV,N2,XN2
 4001  FORMAT(' MINI1 - NAMEV,N2,SN2 - ',A8,O25,F10.3)
C--------------------------------------- END OF CONKEY=11 ----------
      END IF
C
      TEMP = XN2
C
C     ---------- 3.0 ----------
C
C     USE SCLKEY
C
      IF(ISAV(IND4).EQ.1)
C
      OR IF(ISAV(IND4).EQ.2)
C
      TEMP=TEMP/SPACE(IND1)-SPACE(IND2)
C
      IF(ISAV(IVPR).EQ.1)
      AT=3.1
      RTEMP=TEMP
      MSGVAL(1)=KTEMP
      RTEMP=CON(IND1)
      MSGVAL(2)=KTEMP
      RTEMP=CON(IND2)
      MSGVAL(3)=KTEMP
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(234,NAMSUB,AT,KINFO,MSGVAL(1),LTYP(5),1,3,2)
      KERR=KSAV
      END IF
C
      END IF
C
  740 FORMAT(' VIND,TEMP,ITEMP,CONV,K,SPACE(CONV+K-1)',
     -       2F12.2,3I5,F12.2)
C     WRITE(KCHECK,740)VIND,TEMP,ITEMP,CONV,K,SPACE(CONV+K-1)
C
      VIND =VIND +TEMP*SPACE(CONV+K-1)
C
      IF(ISAV(IVPR).EQ.1)
      AT=3.2
      RTEMP=VIND
      MSGVAL(1)=KTEMP
      K1=CONV+K-1
      RTEMP=SAV(K1)
      MSGVAL(2)=KTEMP
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(235,NAMSUB,AT,KINFO,MSGVAL(1),LTYP(5),1,2,2)
      KERR=KSAV
      END IF
C
      END DO
C
      ELSE
C
      VIND=VINDO + DELIV
C
      END IF
C
C     APPLY THE OFFSET AND CHECK FOR THE CROSS-OVER
C
      VIND = VIND + SAV(OFFSET)
C
C     AT CROSS-OVER VIND = 0.0
C     MAKE SURE THIS VALUE IS NOT MIS-INTERPRETED
C     VIND = 0.0 WHEN A LOGICAL RECORD IS ENCOUNTERED WITH A BIKEY MIS-MATCH
C
      TEST = VIND - 0.0
      TEST = ABS(TEST)
      IF(TEST .LE. .001)
      VIND = SAV(MAXIV) + SAV(OFFSET)
      SAV(OFFSET) = SAV(MAXIV)
      END IF
C
K     WRITE(KCHECK,750)VIND
K 750 FORMAT(' IN MINID1, VIND =',F12.2)
C
      RETURN
      END
C
.EJECT
      SUBROUTINE TESTIV
C
C     THIS ROUTINE VERIFIES THAT A IV GAP IS REAL
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION NAMSUB(2)
      INTEGER YES
      DATA NAMSUB,YES /4HTEST  ,2HIV,3HYES/
.NOREP
.USE  COMINA
C
K 700 FORMAT(' AM IN TESTIV ')
K     WRITE(KCHECK,700)
C
C     SAVE THE CURRENT VALUES
C
K 701 FORMAT(' VIND, VINDO, NTOT, I =',2F12.2,2I10)
K     WRITE(KCHECK,701)VIND,VINDO,ISAV(NTOT),ISAV(I)
C
      LOCSV=LOCSAV(THISOP)
      IB=0
      VO=VIND
      VOO=VINDO
      NT=ISAV(NTOT)
      IO=ISAV(I)
      IVOLF=0
C
C     CHECK TO SEE IF A NEW PHYSICAL RECORD IS NEEDED
C     IF YES, READ IT INTO THE SCRATCH AREA
C
K 702 FORMAT(' IO,ISAV(DATLOG) =',2I10)
K     WRITE(KCHECK,702)IO,ISAV(DATLOG)
C
 100  CONTINUE
C
      IF(ISAV(I).GE.ISAV(DATLOG))
K 750 FORMAT(' LOCSAV(THISOP), LOCSCR = ',2I10)
K     WRITE(KCHECK,750)LOCSAV(THISOP),LOCSCR
 
      LOCSV=LOCSAV(THISOP)
      LOCSAV(THISOP)=LOCSCR
      IF(IVOLF.NE.1)
      IB=IB+1
      END IF
      CALL READT
C
K 703 FORMAT(' IVOL = ',I5)
K     WRITE(KCHECK,703)IVOL
C
      IF(IVOL.EQ.1)
      IFLG=0
      VINDT=VO+SPACE(FRTIM)
K 900 FORMAT(' IN TESTIV - CALL TPOS')
K     WRITE(KCHECK,900)
      CALL TPOS
      IVOL=0
      IB=IB-1
      IVOLF=1
      ELSE
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
      END IF
C
K 704 FORMAT(' ISAV(KSTOP) = ',I5)
K     WRITE(KCHECK,704)ISAV(KSTOP)
C
      IF(ISAV(KSTOP).GT.0)
      VIND=VINDO
      GO TO 200
      END IF
C
      END IF
C
K 705 FORMAT(' VIND = ',F12.2)
K     WRITE(KCHECK,705)VIND
C
      VINDO=VIND
      ISAV(NTOT)=ISAV(NTOT)+ISAV(LOGBIT)
      ISAV(I)=ISAV(I)+1
      CALL MINID1
C
      IF(VIND.EQ.0.0)
      VIND=VINDO
      GO TO 100
      END IF
C
C
K 706 FORMAT(' VIND, VINDO AFTER MINID1 = ',2F12.2)
K     WRITE(KCHECK,706)VIND,VINDO
C
C     COMPARE NEXT IV WITH VINDO
C
      EPS=.01*DELIV
C
C     CASE 1:  N,N+1,*,N+2  :  * IS THROWN AWAY
C
      TEST=ABS((VOO + SAV(FRTIM))-VIND)
K     WRITE(KCHECK,707)TEST
      IF(TEST.LT.EPS)
      VIND=VOO
K     WRITE(KCHECK,709)VIND
      GO TO 200
      ELSE
      TEST=ABS(TEST-SAV(MAXIV))
K     WRITE(KCHECK,707)TEST
      IF(TEST.LT.EPS)
      VIND=VOO+SAV(MAXIV)
      SAV(OFFSET)=SAV(OFFSET)+SAV(MAXIV)
K 709 FORMAT(' CASE 1, VIND = ',F12.2)
K     WRITE(KCHECK,709)VIND
      GO TO 200
      END IF
      END IF
C
C     CASE 2:   N,N+1,*,N+3   :  * IS KEPT
C
      TEST=ABS((VOO+2.*SAV(FRTIM))-VIND)
K     WRITE(KCHECK,707)TEST
      IF(TEST.LT.EPS)
      VIND=VOO+SAV(FRTIM)
K 710 FORMAT(' CASE 2, VIND = ',F12.2)
K     WRITE(KCHECK,710)VIND
      GO TO 200
      ELSE
      TEST=ABS(TEST-SAV(MAXIV))
K     WRITE(KCHECK,707)TEST
      IF(TEST.LT.EPS)
      VIND=VOO+SAV(FRTIM)+SAV(MAXIV)
K     WRITE(KCHECK,710)VIND
      SAV(OFFSET)=SAV(OFFSET)+SAV(MAXIV)
      GO TO 200
      END IF
      END IF
C
C     COMPARE NEXT IV WITH IV IN QUESTION
C
C     CASE 3:   N, N+1, N+M, N+M+1,  :  A REAL GAP
C
      TEST=ABS((VO+SAV(FRTIM))-VIND)
K     WRITE(KCHECK,707)TEST
      IF(TEST.LT.EPS)
      VIND=VO
K 711 FORMAT(' CASE 3, VIND = ',F12.2)
K     WRITE(KCHECK,711)VIND
      GO TO 200
      ELSE
      TEST=ABS(TEST-SAV(MAXIV))
K     WRITE(KCHECK,707)TEST
      IF(TEST.LT.EPS)
      VIND=VO+SAV(MAXIV)
K     WRITE(KCHECK,711)VIND
      SAV(OFFSET)=SAV(OFFSET)+SAV(MAXIV)
      GO TO 200
      END IF
      END IF
C
C     CASE 4:  N,N+M,N+2M,N+3M,...  WHERE M.NE.DELIV, A REAL GAP!!!
C
      TEST1=VINDO-VOO
      TEST2=VIND-VINDO
      TEST=ABS(TEST1-TEST2)
K     WRITE(KCHECK,707)TEST
      IF(TEST.LE.EPS)
      VIND=VO
      GO TO 200
      ELSE
      TEST=TEST-SAV(MAXIV)
K     WRITE(KCHECK,707)TEST
      IF(TEST.LE.EPS)
      VIND=VO
      GO TO 200
      END IF
      END IF
C
C     KEEP ALL OTHER IV ANOMOLIES
C
C     CASE 5:  N,N+1,*,%,N+2,N+3,N+4  :  *,% ARE KEPT, N+2,N+3 ARE THROWN OUT
C
      VIND=VOO+SAV(FRTIM)
K 712 FORMAT(' CASE 4, VIND = ',F12.2)
K     WRITE(KCHECK,712)VIND
C
K 707 FORMAT(' TEST = ',F12.2)
C
  200 CONTINUE
C
C     RESET VALUES
C
      VINDO=VOO
      ISAV(I)=IO
      ISAV(NTOT)=NT
      LOCSAV(THISOP)=LOCSV
C
      IF(IVOLF.EQ.1)
      IF(ICON(JCL).EQ.YES)
      KIN=KIN-1
      END IF
      NUNIT(INNUM)=ISAV(KIN)
      NWVOL=NWVOL-1
      ISAV(NEWV)=ISAV(NEWV)+1
      ISAV(NOLDV)=ISAV(NOLDV)-1
      END IF
      IT=ICON(KIN)
C
      DO (KKK=1,IB)
      BACKSPACE IT
      END DO
C
C
K     WRITE(KCHECK,701)VIND,VINDO,ISAV(NTOT),ISAV(I)
K 708 FORMAT(' EXITING TESTIV ')
K     WRITE(KCHECK,708)
C
      RETURN
      END
.EJECT
      SUBROUTINE DCODE1
C
C     THIS DECODER IS USED WHEN DELIV IS A MULTIPLE OF FRTIM
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
.USE  COMINA
      DIMENSION NTYP(10)
C
      DATA MTYP /1HC,1HI,1HI,1HC,1HI,1HC,1HI,1HC,1HI,1HI/
      DATA NTYP /1HC,1HI,1HC,1HI,1HC,1HR,1HC,1HR,1HC,1HC/
      DATA NAMSUB /4HDCOD  ,2HE1/
C  Added these two statements to fix missing DLV   Ron Ruth  920615
T     DATA SPAN,NSPAN,DLV /4HSPAN,6HNOSPAN,5HDELIV/
T     DATA SPAN,NSPAN,DLV /4HSPAN,6HNOSPAN,5HDELIV/
C
T     DIMENSION MASK(63)
T     DATA MASK/2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
T    - 16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,
T    - 8388608,16777216,33554432,67108864,134217728,268435456,
T    - 536870912,1073741824,2147483648,4294967296,8589934592,
T    - 17179869184,34359738368,68719476736,137438953472,274877906944,
T    - 549755813888,1099511627776,2199023255552,4398046511104,
T    - 8796093022208,17592186044416,35184372088832,70368744177664,
T    - 140737488355328,281474976710656,562949953421312,
T    - 1125899906842624,2251799813685248,4503599627370496,
T    - 9007199254740992,18014398509481984,36028797018963968,
T    - 72057594037927936,144115188075855872,288230376151711744,
T    - 576460752303423488,1152921504606846976,2305843009213693952,
C    - 4611686018427387904,-9223372036854775808/
T    - 4611686018427387904,1000000000000000000000B/
C
R     DIMENSION MASK(31)
R     DATA MASK/2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,
R    - 16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,
R    - 8388608,16777216,33554432,67108864,134217728,268435456,
R    - 536870912,1073741824,2147483648/
C
K 760 FORMAT(' AM IN DCODE1')
K     WRITE(KCHECK,760)
C
      EPS=.01*DELIV
      KCDO=DELIV/SPACE(FRTIM)
      IF(KCDO.LT.1)
      AT=1.0
      INDZ=NMCONG+8
      MSGVAL(1)=ICON(INDZ)
      RTEMP=CON(FRTIM)
      MSGVAL(2)=KTEMP
      MSGVAL(3)=DLV
      RTEMP=DELIV
      MSGVAL(4)=KTEMP
      CALL COMERR(9,NAMSUB,AT,KFATAL,MSGVAL(1),NTYP(5),1,4,2)
      END IF
C
C     ---------- 1.0 ----------
C
C     SOME INITIALIZATION
C
      VINDO=VALIV(LASTOP)-SPACE(FRTIM)
      IF(ISAV(IVPR).EQ.1)
      AT=1.1
      MSGVAL(1)=VINDO
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(233,NAMSUB,AT,KINFO,MSGVAL(1),NTYP(6),1,1,2)
      KERR=KSAV
      END IF
C
K 797 FORMAT(' VINDO ON ENTRY = ',F12.2)
K     WRITE(KCHECK,797)VINDO
C
C     ---------- 2.0 ----------
C
C     MAIN PROCESSING LOOP
C
      MCDO=0
C
      DO  (KKK=1,NCDO)
C
      DO  (JJJ=1,KCDO)
C
      MCDO=MCDO+1
C
C     IF THERE IS NO MORE DATA TO PROCESS
C
K 788 FORMAT(' ISAV(KSTOP)',I5)
K     WRITE(KCHECK,788)ISAV(KSTOP)
      IF(ISAV(KSTOP).GT.0)
      TEST=0.0
      VINDN=VINDO
      GO TO 200
      END IF
C
  100 CONTINUE
C
C     ---------- 3.0 ----------
C
C     READ ANOTHER RECORD IF NECESSARY (FRAME COUNT .GE. NUMBER OF
C     FRAMES PER RECORD)
C
      IF(ISAV(I).GE.ISAV(DATLOG))
      CALL READT
      IF(IVOL.EQ.1)
      IFLG=0
      VINDT=VINDT+SPACE(FRTIM)
K 900 FORMAT(' IN DCODE1 - CALL TPOS')
K     WRITE(KCHECK,900)
      CALL TPOS
      IVOL=0
      ELSE
      ISAV(I)=0
      ISAV(NTOT)=-ISAV(LOGBIT)
C
      END IF
C
      IF(ISAV(KSTOP).GT.0)
      TEST=0.0
      VINDN=VINDO
      GO TO 200
      END IF
C
      END IF
C
      ISAV(NUMLOG)=ISAV(NUMLOG)+1
      ISAV(NTOT)=ISAV(NTOT)+ISAV(LOGBIT)
      ISAV(I)=ISAV(I)+1
C
K 701 FORMAT(' NTOT, I =',2I10)
K     WRITE(KCHECK,701)ISAV(NTOT),ISAV(I)
C
C     ---------- 4.0 ----------
C
C     LOCATE THE INDEPENDENT VARIABLE(S) AND THE BITKEY
C
      CALL MINID
C
      VINDN=VIND
C
K 702 FORMAT(' VINDN = ',F12.2)
K     WRITE(KCHECK,702)VINDN
C
C     ---------- 5.0 ----------
C
C     CHECK FOR CONSISTENCY
C
      TEST=VINDO+SPACE(FRTIM)
      VINDT=TEST
      VINDO=TEST
C
K 703 FORMAT(' TEST =',F12.2)
K     WRITE(KCHECK,703)TEST
C
C     ---------- 6.0 ----------
C
C     SET UP SOME POINTERS
C
      NPT=LENCON
      IXC=SCLKEY-NPT
      IXR=SAMP-NPT
      IXK=CONKEY-NPT
      IXA=TERM-NPT
      IXP=FACTOR-NPT
      IXRI=NRI-NPT
      IXII=NII-NPT
      IXV=NAMEDP-NPT
      IXL=FSTBIT-NPT
      IXB=BITS-NPT
      IXS=SAMP-NPT
      IXRO=NRO-NPT
      IX1=BITS-NPT
      IX2=SKIP-NPT
      IXIO=NIO-NPT
      IEND=NUMVEC
K 710 FORMAT(' NPT,IXRI,IXV,IXL,IXRO,IXIO',9I5)
K     WRITE(KCHECK,710)NPT,IXRI,IXV,IXL,IXRO,IXIO
K 789 FORMAT(' TEST, VINDN, EPS, DELX ', 4O23)
      DELX=ABS(VINDN-TEST)
K     WRITE(KCHECK,789)TEST,VINDN,EPS,DELX
C
      IF(DELX.LT.EPS)
C
      VINDO=VINDN
C
C     ---------- 7.0 ----------
C
C     GET THE INPUT DATA
C
      DO(K=1,IEND)
C
      IXC=IXC+NPT
      IXK=IXK+NPT
      IXA=IXA+NPT
      IX1=IX1+NPT
      IX2=IX2+NPT
      IXP=IXP+NPT
      IXRI=IXRI+NPT
      IXII=IXII+NPT
      IXV=IXV+NPT
      IXL=IXL+NPT
      IXB=IXB+NPT
      IXS=IXS+NPT
      IXRO=IXRO+NPT
      IXIO=IXIO+NPT
      IXR=IXR+NPT
C
      NUMR=ISAV(IXR)
      NAMEV=ISAV(IXV)
      IPUT=ISAV(IXIO)+(MCDO-1)*NUMR
C
K     WRITE(KCHECK,711)NUMR,IXV,NAMEV,IPUT
K 711 FORMAT(' NUMR,IXV,NAMEV,IPUT ',2I5,1A10,1I5)
K 790 FORMAT(' IXA,IX1,IX2,IXP,IXL,IXB,IXS =',7I5)
K     WRITE(KCHECK,790)IXA,IX1,IX2,IXP,IXL,IXB,IXS
C
C     ---------- 8.0 ----------
C
C     INPUT PARAMETERS
C
K 795 FORMAT(' ISAV(IXRI)',I5)
K     WRITE(KCHECK,795)ISAV(IXRI)
C
      IF(ISAV(IXRI).EQ.0)
C
      I0=ISAV(IXL)+ISAV(NTOT)
      I1=I0/BITNSU+1
      I2=MOD(I0,BITNSU)-1
      IF(I2.LT.0)
      I2=I2+BITNSU
      I1=I1-1
      END IF
      I3=ISAV(IXB)
C
      NBUF=LOCSAV(THISOP)
      N1=NBUF+I1-1
      N2=IPUT
      N3=I2
      N4=IX2
      N5=IXS
      N6=I3
C
C 782 FORMAT(' N1,N2,N3,N4,N5,N6 = ',6I5)
C     WRITE(KCHECK,782)N1,N2,N3,N4,N5,N6
K 785 FORMAT(' ISAV(N1) = ',O26)
K     WRITE(KCHECK,785)ISAV(N1)
C
.USE  GBYTES
C
K 791 FORMAT(' ISAV(N2) = ',I10)
K     WRITE(KCHECK,791)ISAV(N2)
C
C     ---------- 9.0 ----------
C
C     CONKEY - CONVERSION KEY APPLIES THE APPROPRIATE CONVERSION TO
C              THE BITS REPRESENTING THE DEP. VAR. VALUE.
C
C     NO CONVERSION NEEDED FOR A REAL VALUE
C     CONKEY = 0
C
      PRINT 184,IX,NUMR,KK,ISAV(IX),NAMEV,ISAV(IXK)
 184  FORMAT(' DECODE1:IX,NUMR,KK,ISAV(IX),NAMEV,conkey - ',4I8,A8,i8)
      IF(ISAV(IXK).EQ.0)
C     PRINT 1847,IX,NUMR,KK,ISAV(IX),NAMEV
 1847 FORMAT(' DECODE1:IX,NUMR,KK,ISAV(IX),NAMEV - ',4I8,A8)
C
C     NO CONVERSION NEEDED FOR AN INTEGER VALUE
C     CONKEY = 1
C
      OR IF(ISAV(IXK).EQ.1)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      SAV(IX) = ISAV(IX)
C     PRINT 1849,IX,NUMR,KK,SAV(IX),NAMEV
c 1849 FORMAT(' DECODE1:IX,NUMR,KK,SAV(IX),NAMEV - ',3I8,F12.2,A8)
      END DO
C
C     USE CONKEY TO PUT INPUT PARAMETERS INTO +/- RANGE
C     CONKEY = 2
C
K 765 FORMAT(' ISAV(IXK) =',I5)
K     WRITE(KCHECK,765)ISAV(IXK)
C
      OR IF(ISAV(IXK).EQ.2)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      IF(ISAV(IXB).LT.BITNSU)
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.ISAV(IX))
V     MAX1=(MAX1.AND.ISAV(IX))
M     MAX1=IAND(MAX1,ISAV(IX))
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      ISAV(IX)=ISAV(IX)-MASK(I1)
      END IF
      END IF
      SAV(IX)=ISAV(IX)
      END DO
C
      OR IF(ISAV(IXK).EQ.3)
C
C     THIS CONKEY MOVES THE LOW 8 BITS TO THE HIGH 8 BITS AND VISA VERSA
C                             (NCAR SAILPLANE)
C     CONKEY = 3
C
      MASK1=2**8-1
      MASK2=2**16-1
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
K 770 FORMAT(' ISAV(IX), MASK1, MASK2 ',3O25)
K     WRITE(KCHECK,770)ISAV(IX),MASK1,MASK2
V     ISAV(IX)=ISAV(IX).AND.MASK2
H     ISAV(IX)=ISAV(IX).AND.MASK2
G     ISAV(IX)=ISAV(IX).AND.MASK2
M     ISAV(IX)=IAND(ISAV(IX),MASK2)
K 771 FORMAT(' ISAV(IX) ',O25)
K     WRITE(KCHECK,771)ISAV(IX)
V     ITEMP=ISAV(IX).AND.MASK1
H     ITEMP=ISAV(IX).AND.MASK1
G     ITEMP=ISAV(IX).AND.MASK1
M     ITEMP=IAND(ISAV(IX),MASK1)
K 772 FORMAT(' ITEMP ',O25)
K     WRITE(KCHECK,772)ITEMP
      ITEMP=ITEMP*2**8
K     WRITE(KCHECK,772)ITEMP
      ISAV(IX)=ISAV(IX)/2**8
K     WRITE(KCHECK,771)ISAV(IX)
G     ISAV(IX)=ISAV(IX).OR.ITEMP
V     ISAV(IX)=ISAV(IX).OR.ITEMP
H     ISAV(IX)=ISAV(IX).OR.ITEMP
M     ISAV(IX)=IOR(ISAV(IX),ITEMP)
K     WRITE(KCHECK,771)ISAV(IX)
      SAV(IX)=ISAV(IX)
      END DO
C
C     T28 INDEPENDENT VARIABLE
C     CONKEY=4
C
      OR IF(ISAV(IXK).EQ.4)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      ITEMP=ISAV(IX)
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
      ISAV(IX)=ITEMP
K 775 FORMAT(' IHR,IMIN,ISEC,ITEMP',4I10)
K     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
      SAV(IX)=ISAV(IX)
      END DO
C
C     STORE THE INPUT IV INTO ANOTHER DEPENDENT VARIABLE
C     CONKEY=5
C
      OR IF(ISAV(IXK).EQ.5)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      SAV(IX)=VIND
      END DO
C
C     THIS CONKEY COMPLIMENTS THE DATUM
C     CONKEY=6
C
      OR IF(ISAV(IXK).EQ.6)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      ISAV(IX)=.NOT.ISAV(IX)
      IF(ISAV(IXB).LT.BITNSU)
      MSK=2**(ISAV(IXB))-1
      ISAV(IX)=ISAV(IX).AND.MSK
      END IF
      SAV(IX)=ISAV(IX)
      END DO
C
C     THIS CONKEY DOES A COMPLIMENT OF THE DATUM FOLLOWED IMMEDIATELY
C     BY THE CONVERSION ALGORITHM OF CONKEY = 2
C     CONKEY=7
C
      OR IF(ISAV(IXK).EQ.7)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      ISAV(IX)=.NOT.ISAV(IX)
c      IF(NAMEV.EQ.'PSFD') PRINT 4001, KK,IX,ISAV(IX)
 4001  FORMAT(' DCODE1- PSFD: KK,IX,ISAV ',3I9)
 4002  FORMAT(' DCODE- NAMEV,KK,IX,ISAV ',A8,3I9)
       PRINT 4002,NAMEV,KK,IX,ISAV(IX)
      IF(ISAV(IXB).LT.BITNSU)
      MSK=2**(ISAV(IXB))-1
      ISAV(IX)=ISAV(IX).AND.MSK
      I1=ISAV(IXB)-1
      MAX1=MASK(I1)
H     MAX1=(MAX1.AND.ISAV(IX))
V     MAX1=(MAX1.AND.ISAV(IX))
M     MAX1=IAND(MAX1,ISAV(IX))
      IF(MAX1.NE.0)
      I1=ISAV(IXB)
      ISAV(IX)=ISAV(IX)-MASK(I1)
      END IF
      END IF
      SAV(IX)=ISAV(IX)
      END DO
C
C--------------------------------------- CONKEY = 8   -------------
C**  JOINT HAWAII PROJECT 1985   SEPT. 04, 1985 (CC)
C
C     WYOMING KING AIR ARCHIVE TAPE  INDEPENDENT VARIABLE
C     CONKEY= 8
C
      OR IF(ISAV(IXK).EQ. 8)
      IX=IPUT-1
      DO(KK=1,NUMR)
       IX=IX+1
C      WRITE(KCHECK,888)ISAV(IX)
       CALL HPREAL(ISAV(IX),SAV(IX))
       ISAV(IX)=SAV(IX)
C-----
      ITEMP=ISAV(IX)
      IDAY=ITEMP/1000000
      ITEMP=ITEMP-IDAY*1000000
      IHR=ITEMP/10000
      ITEMP=ITEMP-IHR*10000
      IMIN=ITEMP/100
      ITEMP=ITEMP-IMIN*100
      ISEC=ITEMP
      ITEMP=IHR*3600+IMIN*60+ISEC
      ISAV(IX)=ITEMP
  775 FORMAT(' IHR,IMIN,ISEC,ITEMP',4I10)
C     WRITE(KCHECK,775)IHR,IMIN,ISEC,ITEMP
      SAV(IX)=ISAV(IX)
      END DO
C--------------------------------------- END OF CONKEY= 8     -----
C
C--------------------------------------- CONKEY=9 ---------------------
C     THIS CONKEY CONVERTS HP REAL NUMBER AND PUT IT INTO CRAY REAL
C     NUMBER
C     CONKEY=9
C
      OR IF(ISAV(IXK).EQ.9)
      IX=IPUT-1
      DO(KK=1,NUMR)
       IX=IX+1
C      WRITE(KCHECK,888)ISAV(IX)
C 888 FORMAT(' ISAV(IX) = ',O25)
       CALL HPREAL(ISAV(IX),REAL)
       SAV(IX) = REAL
      END DO
C--------------------------------------- END OF CONKEY=9 ----------
C
C----------------------  CONKEY=10 --------------------
C     2UW FLAG WORD
C     CONKEY=10
C
      OR IF(ISAV(IXK).EQ.10)
      IX=IPUT-1
      DO(KK=1,NUMR)
      IX=IX+1
      ITEMP=ISAV(IX)
      IFLG=ITEMP/100
      ITEMP=ITEMP-IFLG*100
      ISAV(IX)=ITEMP
C 775 FORMAT(' ITEMP-2UW FLAG WORD = ', I10)
C     WRITE(KCHECK,775)ITEMP
      SAV(IX)=ISAV(IX)
      END DO
C ------------------------------------------------  END OF CONKEY=10 --
C
C--------------------------------------- CONKEY=11 ---------------------
C     THIS CONKEY CONVERTS IEEE REAL NUMBER AND PUT IT INTO
C     CRAY REAL NUMBER
C     CONKEY=11
C
      OR IF(ISAV(IXK).EQ.11)
      IX=IPUT-1
      DO(KK=1,NUMR)
       IX=IX+1
C      WRITE(KCHECK,888)ISAV(IX)
  888 FORMAT(' ISAV(IX) = ',O25)
       CALL I3ER(ISAV(IX),REAL)
C      PRINT 4000, NAMEV,ISAV(IX),REAL
 4000  FORMAT(' DCODE1- NAMEV,ISAV,REAL ',A8,O25,F10.3)
       SAV(IX) = REAL
C      ISAV(IX)=SAV(IX)
      END DO
C--------------------------------------- END OF CONKEY=11 ----------
C
      END IF
C
C     ---------- 10.0 ----------
C
C     SCALE THE INPUT PARAMETERS
C
      IX=IPUT-1
      IF(ISAV(IXC).EQ.1)
C
      OR IF(ISAV(IXC).EQ.2)
C
      DO(KK=1,NUMR)
      IX=IX+1
      SPACE(IX)=(SAV(IX)/SPACE(IXP))-SPACE(IXA)
C
K 720 FORMAT(' SPACE, P, AD', F12.5,10X,2F12.5)
K     WRITE(KCHECK,720)SPACE(IX),SPACE(IXP),SPACE(IXA)
C
      END DO
C
      END IF
C
      END IF
C
      END DO
C
      END IF
C
C     ---------- 11.0 ----------
C
C     INDEPENDENT VARIABLE INCONSISTENCY
C
  200 CONTINUE
C
K 764 FORMAT(' VINDN,TEST,ISAV(KSTOP)',2F12.5,I10)
K     WRITE(KCHECK,764)VINDN,TEST,ISAV(KSTOP)
K     WRITE(KCHECK,788)ISAV(KSTOP)
K     WRITE(KCHECK,789)TEST,VINDN,EPS,DELX
C
      IF(DELX.GT.EPS.OR.ISAV(KSTOP).GT.0)
      IF(VINDN.GT.TEST.OR.ISAV(KSTOP).GT.0)
K 755 FORMAT(' SAMP,NRI,NRO,NII,NIO,LENCON,NUMVEC',7I6)
K     WRITE(KCHECK,755)SAMP,NRI,NRO,NII,NIO,LENCON,NUMVEC
C
C     ---------- 12.0 ----------
C
C     FILL IN DATA GAP WITH GAPVAL
C
      IXR=SAMP-LENCON
      IXRI=NRI-LENCON
      IXRO=NRO-LENCON
      IXII=NII-LENCON
      IXIO=NIO-LENCON
K 756 FORMAT(' IXR,IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC',7I6)
K     WRITE(KCHECK,756)IXR,IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC
C
      DO(K=1,NUMVEC)
      IXR=IXR+LENCON
      IXRI=IXRI+LENCON
      IXRO=IXRO+LENCON
      IXII=IXII+LENCON
      IXIO=IXIO+LENCON
K     WRITE(KCHECK,756)IXR,IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC
K 757 FORMAT(' MCDO =',I5)
K     WRITE(KCHECK,757)MCDO
      NUMR=ISAV(IXR)
      IPUT=ISAV(IXIO)+(MCDO-1)*NUMR
C
K 751 FORMAT(' IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC ',6I5)
K     WRITE(KCHECK,751)IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC
K 752 FORMAT(' NUMR, IPUT',2I10)
K     WRITE(KCHECK,752)NUMR,IPUT
C
C     ---------- 13.0 ----------
C
C     INPUT PARAMETERS
C
      IF(ISAV(IXRI).EQ.0)
C
      DO(KK=1,NUMR)
      SPACE(IPUT)=GAPVAL
      IPUT=IPUT+1
      END DO
C
      END IF
C
      END DO
C
      ISAV(NTOT)=ISAV(NTOT)-ISAV(LOGBIT)
      ISAV(I)=ISAV(I)-1
      ISAV(NUMLOG)=ISAV(NUMLOG)-1
C
      OR IF(VINDN.LT.TEST)
      VINDO=VINDO-SPACE(FRTIM)
      GO TO 100
C
      END IF
C
      END IF
C
      END DO
C
C     ---------- 14.0 ----------
C
C     PASSED VARIABLES
C
      IXRI=NRI-LENCON
      IXII=NII-LENCON
      IXIO=NIO-LENCON
      IXRO=NRO-LENCON
K 758 FORMAT(' IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC',6I6)
K     WRITE(KCHECK,758)IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC
C
      DO(K=1,NUMVEC)
C
      IXRI=IXRI+LENCON
      IXII=IXII+LENCON
      IXIO=IXIO+LENCON
      IXRO=IXRO+LENCON
K     WRITE(KCHECK,758)IXRI,IXRO,IXII,IXIO,LENCON,NUMVEC
K     WRITE(KCHECK,758)ISAV(IXRI),ISAV(IXRO),ISAV(IXII),
K    -                 ISAV(IXIO),LENCON,NUMVEC
      IF(ISAV(IXRI).NE.0)
K 759 FORMAT(' THE PASSED PARAMETER SECTION')
K     WRITE(KCHECK,759)
C
      NUMR=ISAV(IXRO)
K 763 FORMAT(' NUMR =',I5)
K     WRITE(KCHECK,763)NUMR
      IPUT=ISAV(IXIO)+(KKK-1)*NUMR
K 761 FORMAT(' IPUT =',I5)
K     WRITE(KCHECK,761)IPUT
      IGET=ISAV(IXII)+(KKK-1)*NUMR
K 762 FORMAT(' IGET=',I5)
K     WRITE(KCHECK,762)IGET
      CALL MOVESP(ISAV,IGET,1,ISAV,IPUT,1,NUMR)
C
      END IF
C
      END DO
C
      END DO
C
      RETURN
      END
.EJECT
      SUBROUTINE NWVL
C
C     THIS ROUTINE ASSIGN NEW VOLUMES
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
.USE  COMINA
      DATA NAMSUB /4HNWVL  ,2H  /
      INTEGER YES
      CHARACTER*80 STRING
      INTEGER IEXEC
      DATA YES/3HYES/
C
C     JCL - YES, USER SUPPLIES JCL FOR INPUT VOLUME
C           NO, GENPRO SUPPLIES JCL (DEFAULT)
C     NWVOL - POINTS TO THE NEXT VOLUME NAME
C     NEWV - THE NUMBER OF VOLUMES REMAINING
C     NUMV - THE NUMBER OF CONTROL WRDS COMMECTED WITH EACH VOLUMEE
C
K 799 FORMAT(' AM IN NWVL')
K     WRITE(KCHECK,799)
C
      NREEL=ISAV(NWVOL)
      KUNIT=ISAV(KIN)
      NAMREC(INNUM)=0
      NAMVOL(INNUM)=ISAV(NWVOL)
      NAMFIL(INNUM)=1
K 700 FORMAT(' NWVOL,KIN,JCL,NREEL,KUNIT,ISAV(JCL) = ', 3I5,A10,I3,A10)
K     WRITE(KCHECK,700)NWVOL,KIN,JCL,NREEL,KUNIT,ISAV(JCL)
C
C     UPDATE THE POINTERS
C
      IF(ICON(JCL).EQ.YES)
      KIN=KIN+1
      END IF
      NUNIT(INNUM)=ISAV(KIN)
      NWVOL=NWVOL+1
      NAMVOL(INNUM)=ISAV(NWVOL)
      ISAV(NEWV)=ISAV(NEWV)-1
      ISAV(NOLDV)=ISAV(NOLDV)+1
      KPOS=KPOS+2
K     CALL CADUMP
K 765 FORMAT(' KIN, ISAV(KIN),ISAV(NOLDV) ',3I10)
K     WRITE(KCHECK,765)KIN,ISAV(KIN),ISAV(NOLDV)
K 766 FORMAT(' KPOS, ISAV(KPOS), ISAV(KPOS+1) ',3I7)
K     WRITE(KCHECK,766)KPOS,ISAV(KPOS),ISAV(KPOS+1)
C
H     IF(ICON(JCL).NE.YES)
H1000 FORMAT('fort.',I2)
H     ENCODE(7,1000,NAMEK)KUNIT
K1200 FORMAT(' IN NWVL - NAMEK = ',A10)
K1201 FORMAT(' IN NWVL - NAMEK, ICON(NWVOL)  = ',2A10)
K     WRITE(KCHECK,1201)NAMEK,ISAV(NWVOL)
K     WRITE(KCHECK,1200)NAMEK
C H     CALL RELEASE(IER,'DN',NAMEK)
C H     CALL ACQUIRE(IER,'DN',NAMEK,'PDN',ICON(NWVOL)
C H    -,'DF','76','MF','TB')
C    -,'TEXT','ONLINE')
1201  FORMAT(' IN NWVL:old volume close,ios= ',i4,/,
     1  ' new volume assigned-NAMEK,NWVOL=',2A10)

C CC Steps for reading new volumes:
C
C    1. Close the old volume 
C    2. New volume and old unit number written to STRING
C    3. Assign the new volume to the old unit - using iexec
C
      CLOSE(UNIT=KUNIT,IOSTAT=IOS,ERR=829)
      WRITE(KCHECK,1201)IOS,NAMEK,ICON(NWVOL)
C CC New volume and old unit number written to STRING
      write(string,1202)icon(nwvol),isav(kin)
1202  format('assign -a ',a4,' fort.',i2)
C CC Assign the new volume to the old unit
      ier=iexec(STRING)
C      open(unit=kunit,file=newf,status=old,iostat=ioso,err=929)
H     END IF
C
      RETURN
  929 print 928, kunit
  928 format(' nwvl: error in opening unit ',i5)
  829 print 828, kunit
  828 format(' nwvl: error in closing kunit ',i5)
      END
.EJECT
      SUBROUTINE READT
C
C     THIS ROUTINE READS THE INPUT TAPE
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
C
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
C CC
      DIMENSION ISVCC(2000)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
.USE  COMINA
      DATA NAMSUB /4HREAD  ,2HT /
      DATA MTYP /1HC,1HI,1HI,1HI,1HC,1HI,1HI,1HI,1HI,1HI/
C
K 705 FORMAT(' AM IN READT')
K     WRITE(KCHECK,705)
C
      NEOT=0
C
C     ---------- 1.0 ----------
C
C          TAPE READ
C
      IUNIT=ISAV(KIN)
      IMODE=ISAV(KMODE)
      ITYPE=ISAV(KTYPE)
H     LEN=(ISAV(DATLOG)*ISAV(LOGBIT)/BITNSU)+1
M     LEN=(ISAV(DATLOG)*ISAV(LOGBIT)/BITNSU)+1
.REPL
V     LEN=LENSAV(THISOP)*$NCPNSU
.NOREP
      NUM=ISAV(NPHY)
C
  100 CONTINUE
      NBUF=LOCSAV(THISOP)
K 750 FORMAT(' ICON(DATLOG),ICON(LOGBIT),BITNSU,LOCSAV(THISOP),NBUF,
K    -LEN = ',6I10)
K     WRITE(KCHECK,750)ISAV(DATLOG),ISAV(LOGBIT),BITNSU,LOCSAV(THISOP),
K    -                 NBUF,LEN
C   CCCCCCCC
      LEN=LEN -1
      DO (K=1,NUM)
C
 9999 CONTINUE
      NAMREC(INNUM)=NAMREC(INNUM)+1
C
C     ---------- 2.0 ----------
C
  101 CONTINUE
C
  799 FORMAT(' K,NAMREC,IUNIT,IMODE,ITYPE,NBUF,LEN',7I5)
C     WRITE(KCHECK,799)K,NAMREC(INNUM),IUNIT,IMODE,ITYPE,NBUF,LEN
      CALL RDTAPE(IUNIT,IMODE,ITYPE,ISAV(NBUF),LEN)
      CALL IOWAIT(IUNIT,NSTATE,LENREC)
      if(nstate.eq.1) nstate=3
C     PRINT 3599,LEN,LENREC
 3599 FORMAT(' LEN, LENREC --- ',2I8)
C  CHECK FOR EOF OR EOT
      IF(NSTATE.EQ.1 .OR.NSTATE.EQ.3) GO TO 9998
C  MODS TO TAKE OUT SHORT RECORDS HERE -- CODE MODIFIED DEC 4, 1985
C     NBUFX = NBUF+LEN-1
C     IF(NAMREC(INNUM).GT.1490) PRINT 4009,(ISAV(N),N=NBUF,NBUFX)
 4009 FORMAT((5(1X,O20)))
 4100 FORMAT(' NAMREC,LENREC,LEN,LDIF,NBUF ', 5I6)
      LDIF = ABS(LENREC-LEN)
      IF( LDIF.GT.1)
C     PRINT 4100,NAMREC(INNUM),LENREC,LEN,LDIF,NBUF
      GO TO 9999
C      DO (IC=1,LEN)
C       INBUF = NBUF+IC-1
C       ISAV(IC)= 0.0
C      END DO
      END IF
 9998 CONTINUE
C --------------------------- ORIGINAL CODE ----------------
      IF(LENREC.LT.LEN)
H      I1 = NBUF + LENREC
H      I2 = NBUF + LEN - 1
.REPL
V      I1 = NBUF + LENREC/$NCPNSU
V      I2 = NBUF + LEN/$NCPNSU - 1
.NOREP
M      I1 = NBUF + LENREC
M      I2 = NBUF + LEN - 1
      DO (III=I1,I2)
       ISAV(III) = 0.0
      END DO
      END IF
C ------------------------------------ END OF THE ORIGINAL CODE
      ISTATE(INNUM)=NSTATE
K 798 FORMAT(' NSTATE, LENREC = ',2I5)
K     WRITE(KCHECK,798)NSTATE,LENREC
K     WRITE(KCHECK,777)ISAV(NBUF)
K 777 FORMAT(' ISAV(NBUF) = ',O25)
C
      IF(ISAV(IVPR).EQ.1)
      AT=2.1
      KSAV=KERR
      KERR=KCHECK
      CALL COMERR(238,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,0,1)
      I1=NBUF
      I2=NBUF+LENREC-1
      WRITE(KCHECK,3052)(ISAV(III),III=I1,I2)
      CALL COMERR(0,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,0,3)
      MSGVAL(1)=NAMVOL(INNUM)
      MSGVAL(2)=ISTATE(INNUM)
      MSGVAL(3)=LENREC
      MSGVAL(4)=NAMREC(INNUM)
      CALL COMERR(239,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(1),1,4,3)
      KERR=KSAV
      END IF
C
C     ---------- 3.0 ----------
C
C     EOF ENCOUNTERED
C
      IF(NSTATE.EQ.1)
      AT=3.1
      MSGVAL(1)=NAMREC(INNUM)
      MSGVAL(2)=NUNIT(INNUM)
      MSGVAL(3)=NAMVOL(INNUM)
      CALL COMERR(104,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(3),1,3,2)
C
K 788 FORMAT(' ITPOS =',I5)
K     WRITE(KCHECK,788)ITPOS
      IF(ITPOS.EQ.999)
G     BACKFILE IUNIT
H     BACKSPACE IUNIT
      NAMREC(INNUM)=NAMREC(INNUM)-1
      NEOT=1
      RETURN
      END IF
C
      NAMREC(INNUM)=0
      NAMFIL(INNUM)=NAMFIL(INNUM)+1
C
      IF(ISAV(KEOF).EQ.0)
      GO TO 101
      OR IF(ISAV(KEOF).EQ.1)
      ENDTAP(INNUM)=VINDT
      ISAV(KSTOP)=1
      RETURN
      END IF
C
C     ---------- 4.0 ----------
C
C     EOT ENCOUTNERED
C
      OR IF(NSTATE.EQ.3)
      NAMFIL(INNUM)=1
      NEOT=1
      AT=4.1
      MSGVAL(1)=NAMREC(INNUM)
      MSGVAL(2)=NUNIT(INNUM)
      MSGVAL(3)=NAMVOL(INNUM)
      CALL COMERR(104,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(3),1,3,2)
      NAMREC(INNUM)=0
C
      IF(ISAV(NEWV).GT.0)
      NAMVOL(INNUM)=NAMVOL(INNUM)+1
      CALL NWVL
      IVOL=1
C
      ELSE
C
      AT=4.2
      MSGVAL(1)=NAMREC(INNUM)
      MSGVAL(2)=NUNIT(INNUM)
      MSGVAL(3)=NAMVOL(INNUM)
      CALL COMERR(105,NAMSUB,AT,KINFO,MSGVAL(1),MTYP(3),1,3,2)
      ENDTAP(INNUM)=VINDT
      ISAV(KSTOP)=1
      IUNIT=ISAV(KIN)
      RETURN
C
      END IF
C
      END IF
C
C     ---------- 5.0 ----------
C
K 701 FORMAT(' RECORD NUMBER, STATUS = ',2I5)
K     WRITE(KCHECK,701)NAMREC(INNUM),NSTATE
K 776 FORMAT(' NBUF, IEND ',2I5)
K 700 FORMAT(' THE INPUT RAW DATA RECORD '/(5O24))
      IEND=NBUF+LENREC-1
K     WRITE(KCHECK,776)NBUF,IEND
K     WRITE(KCHECK,700)(ISAV(KKK),KKK=NBUF,IEND)
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  3JUN85
C 701 FORMAT(' RECORD NUMBER, STATUS = ',2I5)
C     WRITE(KCHECK,701)NAMREC(INNUM),NSTATE
C 776 FORMAT(' NBUF, IEND ',2I5)
C 700 FORMAT(' THE INPUT RAW DATA RECORD '/(5O24))
C     WRITE(KCHECK,776)NBUF,IEND
C     WRITE(KCHECK,700)(ISAV(KKK),KKK=NBUF,IEND)
C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      NBUF=NBUF+LEN
C
      END DO
C
C     ------------------------------------------------------------------
C
C     SOME FORMATS
 3052 FORMAT(1X,5O24)
C
C
      RETURN
      END
.EJECT
      SUBROUTINE SKIPFL
C
C     THIS ROUTINE IS A SKIP FILE ROUTINE
C
.REPL
.USE  BLANK
.USE  CYCVAR
.USE  ERROR
.USE  INPUT
.USE  IOUNIT
.USE  OP
.USE  TYPVAR
.USE  MSGPR
      DIMENSION MTYP(10),NAMSUB(2)
      EQUIVALENCE (KTEMP,RTEMP)
.NOREP
      DATA NAMSUB /4HSKIP  ,2HFL /
.USE  COMINA
      IT=ISAV(KIN)
      IMODE = 1
      ITYPE = 2
      LOOP
      LEN = 1
      CALL RDTAPE(IT,IMODE,ITYPE,JUNK,LEN)
      CALL IOWAIT(IT,NSTATE,LENREC)
      EXIT IF (NSTATE.EQ.1.OR.NSTATE.EQ.3)
      END LOOP
C
      RETURN
      END
.DE   K
.NOLIST
C--------------------------------------------------------------------
      SUBROUTINE HPREAL(IWD,A)
C
C     SUBROUTINE HPREAL CONVERTS 32 BIT FLOATING POINT NUMBERS ENCODED
C     BY THE HP GROUND STATION INTO WORDS SUITABLE FOR THE CRAY
C     (CRAY IS A 2'S COMPLIMENT MACHINE - FOR FLOATING NUMBERS)
C
C----------------- ** AS OF AUGUST 30,1985 (CC) ** --------------------
C
C**     H P - 1 0 0 0    R E A L   F O R M A T  ( 32 BITS )
C
C----------
C BIT NO.  31 30 29 28 27 ................... 07 06 05 04 03 02 01 00
C           |  |  |  |  | ...................  |  |  |  |  |  |  |  |
C
C   WHERE  BIT    31 IS SIGN OF FRACTION (0-POSITIVE;1-NEGATIVE)
C          BITS 8-30 ARE FRACTION BITS
C NOTE: 1'S COMPLIMENT FRACTION FOR NEGATIVE SIGN OF FRACTION
C          BIT   00   IS SIGN OF EXPONENT (0-POSITIVE;1-NEGATIVE)
C          BITS 1-7  ARE EXPONENT BITS
C NOTE: 2'S COMPLIMENT EXPONENT FOR NEGATIVE SIGN OF EXPONENT
C----------------------------------------------------------------------
C
C     PRINT 4000,IWD
 4000 FORMAT(' HPREAL - IWD ', O25)
C** PICK SIGN OF FRACTION BIT
      ISIGN = 20000000000B .AND. IWD
C** SAVE ORIGINAL WORD FOR DECODING EXPONENT WORD
      IWDS=IWD
C** NEGATIVE SIGN FRACTION -- 1'S COMPLIMENT
      IF(ISIGN.NE.0) IWD = .NOT. IWD
      NFRAC = IWD .AND. 17777777400B
      NFRAC  = NFRAC/256
C** PICK UP SIGN OF EXPONENT BIT FROM THE SAVED WORD
      NXSIGN = IWDS  .AND. 1B
      IF(NXSIGN.EQ.0)
C** POSITIVE SIGN OF EXPONENT
       NEXP = IWDS .AND. 376B
       NEXP = NEXP/2
      ELSE
C** NEGATIVE SIGN OF EXPONENT -- 2'S COMPLIMENT
       IWD2 = .NOT. IWDS
       NEXP = IWD2 .AND. 376B
       NEXP =(NEXP/2) +1
       NEXP = -NEXP
      END IF
      FRAC = NFRAC* 1.192092896E-7
      A = 2.**NEXP * FRAC
      IF(ISIGN.NE.0) A = - A
C     PRINT 5000,A
 5000 FORMAT(' HPREAL - A ', F10.3)
      RETURN
      END
C--------------------------------------------------------------------
      SUBROUTINE I3ER(IWD,A)
C
C     SUBROUTINE I3EER CONVERTS 32 BIT IEEE FLOATING POINT NUMBERS
C     INTO WORDS SUITABLE FOR THE CRAY COMPUTER
C     (CRAY IS A 2'S COMPLIMENT MACHINE - FOR FLOATING NUMBERS)
C
C----------------- ** AS OF MARCH 14,1989  (CC) ** --------------------
C
C**     IEEE  FLOATING POINT F O R M A T  ( 32 BITS )
C
C----------
C BIT NO.  31 30 29 28 27 ................... 07 06 05 04 03 02 01 00
C           |  |  |  |  | ...................  |  |  |  |  |  |  |  |
C
C   WHERE  BIT    31 IS SIGN OF FRACTION (0-POSITIVE;1-NEGATIVE)
C          BITS 0-22 ARE FRACTION BITS
C          BITS 22-30 ARE EXPONENT BITS
C  IF E=255 AND F.NE.0,  THEN A=NAN (NOT A NUMBER)
C  IF E=255 AND F=0, THEN A=SIGNED INFINITY
C  IF 0<E<255, THEN A =2**(E-127)*1.F
C  IF E=0 AND F.NE.0, THEN A =2**(-126)*0.F
C  IF E=0 AND F=0, THEN A = 0
C
C----------------------------------------------------------------------
C
C     PRINT 4000,IWD
 4000 FORMAT(' IEEE REAL- IWD ', O25)
C** PICK SIGN OF FRACTION BIT
      ISIGN = 20000000000B .AND. IWD
C** PICK EXPONENT BITS AND MOVE 2**23
      NEX = IWD .AND. 17740000000B
      NEX  = NEX/8388608
C     PRINT 31,NEX,NEX
  31  FORMAT(' NEX ', O25,3X,I6)
C** PICK UP FRACTION BITS
      NF= IWD .AND. 37777777B
C     PRINT 30,NF,NF
  30  FORMAT(' NF ', O25,3X,I9)
C
      FRAC = NF*1.192092896E-7
C
      IF(NEX.EQ.255 .AND. NF.NE. 0) A = 99999.
      IF(NEX.EQ.255 .AND. NF.EQ. 0) A = 99999.
      IF(NEX.GT.0 .AND. NEX.LT.255) A =( 2.**(NEX-127))*(1.+FRAC)
      IF(NEX.EQ.0 .AND. NF.NE.0) A = (2.**(-126))*FRAC
      IF(NEX.EQ.0 .AND. NF.EQ.0) A= 0.
      IF(ISIGN.NE.0) A = (-1.)*A
C
C     PRINT 5000,A
 5000 FORMAT(' IEEE REAL - A ', F10.3)
      RETURN
      END
C--------------------------------------------------------------------
C*****************************************************************************
C Changed order of moisture variable calculations -- June 1991 -- Ron Ruth
C Originally done for project 1-739 Smith/Kok
C Necessitated by use of cryogenic hygrometer whose output occurs in LEVEL 3
C Moisture calculations now in LEVELs 4 and 5, allowing the cryogenic
C   hygrometer to be used as a reference, if desired
c
c Mods for Harp Project:   Jan. 1991  -cc
c BIAS added for TASF
c Commented out some input information on PLWC
C
      SUBROUTINE CALIB1
.REPL
.USE  TBLANK
.USE  TCYCVAR
.USE  TIOUNIT
.USE  TOP
.USE  BLANK
.USE  CYCVAR
.USE  OP
.USE  ERROR
.USE  IOUNIT
.USE  CALCOM
.NOREP
      INTEGER TITLE,UNITS,CONSU
      DIMENSION NAMQC(2),NAMSOU(9),LRGUST(8),LRGUSTR(8)
      DIMENSION NGUST(8),KTSV(500),NRGUST(8),CONA(50),KUNIT(10)
     1         ,KONSN(50),KONU(50),KONN(50),KONVN(10),CONV(10),KONVU(10)
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
      COMMON/GUSTIN/IPGUST(8)
      COMMON/GUSTINR/IRGUST(8)
      COMMON/PWRITE/ARAY(20),IY,IXK
      COMMON/HIST/LT(5),NCELLS,SIZE(64),NSIZE
      COMMON/PFSSP/TAU1,TAU2,TAU3,CWD(4),CBIAS(4),DOF,BDIA,NCSUMF,
     1             THRESHF,KRANGE,KSTROB,KRESET,MRATEF,MWORDF,MCELLF,
     2             SIZEF(15)
      COMMON/PASAS/NCSUMA,THRESHA,MRATEA,MWORDA,MCELLA
      COMMON/PX200/NCSUMX,THRESHX,MRATEX,MWORDX,MCELLX,SIZEX
      COMMON/PX260/NCSUM6,THRESH6,MRATE6,MWORD6,MCELL6,SIZE6
      COMMON/PY200/NCSUMY,THRESHY,MRATEY,MWORDY,MCELLY,SIZEY
      COMMON/PLWC/TWIRE,CN1,EN1
      COMMON/DLA/CX(4),XC,CX1(4),XC1
C
C-----------------------------------------------------------------------------
      DATA NATFR /8HATFR    /,NRHORF /8HRHORF   /
      DATA NTVCRH/8HTVCRH   /,NPCNC  /8HPCNC    /,NFCNC   /8HFCNC    /,
     1     NCONCNC/8HCONCNC  /,NXICNC/8HXICNC   /,NRHOCR  /8HRHOCR   /,
     2     NCNC  /8HCNC     / ,NCRYOC/8HCRYOC   /
      DATA NATF20/8HATF20   /,NPALT20/8HPALT20  /,NPSFDC20/8HPSFDC20 /,
     1     NQCFC20/8HQCFC20  /
      DATA NAKDF /8HAKDF    /,NAKFXL /8HAKFXL   /,NAKFXR  /8HAKFXR   /,
     A     NAKRD /8HAKRD    /,NAMASS /8HAMASS   /,NATB    /8HATB     /,
     A     NATBH /8HATBH    /,NATF   /8HATF     /,NATFH   /8HATFH    /,
     A     NATKP /8HATKP    /,NATK3  /8HATK3    /,NATRF   /8HATRF    /,
     A     NATW  /8HNATW    /,
     A     NASAS /8HASAS    /,NATWH  /8HATWH    /,NAVOLF  /8HAVOLF   /,
     A     NATOPH/8HATOPH   /,NATRW  /8HATRW    /,NATRE   /8HATRE    /,
     A     NATB1 /8HATB1    /,NATR3  /8HATR3    /,NATR6   /8HATR6    /
      DATA NBETA3/8HBETA3   /,NBMACH /8HBMACH   /,NATKPR  /8HATKPR   /,
     B     NBMACH2/8HBMACH2  /,NBRE  /8HBRE     /, NCONSN /8HFUNCTION/,
     C     NCONC2C/8HCONC2C  /,NCONC2P/8HCONC2P  /,NCONC2P2/8HCONC2P2 /,
     C     NCVI   /8HCVI     /,NDPCVC /8HDPCVC   /,NRHOCD  /8HRHOCD   /,
     C     NCLDHT /8HCLDHT   /,
     C     NCOC  /8HCOC     /,NDPCRC /8HDPCRC   /,
     D     NDA   /8HDA      /,NDIF   /2HDF/      ,NDO3C   /8HDO3C    /,
     D     NDLA  /8HDLA     /,NDLA1  /8HDLA1    /,NDMEC   /8HDMEC    /,
     D     NDPBC /8HDPBC    /,NDPC   /8HDPC     /,NDPTC   /8HDPTC    /,
     D     NSCLWC/8HSCLWC   /,NDVALU /8HDVALU   /,NDPGEC  /8HDPGEC   /
      DATA NFMACH/8HFMACH   /,NFMACH2/8HFMACH2  /,NFSSP   /8HFSSP    /,
     E     NETHETAK/8HETHETAK /,
     G     NGEDPC/8HGEDPC   /,NGERHOTD/8HGERHOTD /,
     G     NGMACH/8HGMACH   /,NGMACH2/8HGMACH2  /,NGUSTD  /8HGUSTD   /,
     G     NGSF  /8HGSF     /,NGUSTO /8HGUSTO   /,NGUSTR  /8HGUSTR   /,
     I     NIAS  /8HIAS     /,NIRBC  /8HIRBC    /,NIRTC   /8HIRTC    /,
     K     NKRA /8HKRA     /,NHRDFAFX/8HHRDFAFX /,NHRDFBFX/8HHRDFBFX /,
     L     NLWCC /8HLWCC    /,NLYAPX /8HLYAPX   /,NLYAP1  /8HLYAP1   /,
     L     NLWCCF/8HLWCCF   /,NLWCCZ/8HLWCCZ   /,
     L     NHGME /8HHGME    /,
     M     NMR   /8HMR      /,
     N     NNETI /8HNETI    /,NNETT  /8HNETT    /,NNETV   /8HNETV    /
      DATA NPALT /8HPALT    /,NPLCL  /8HPLCL    /,NPLWCC  /8HPLWCC   /,
     P     NPLWCCZ/8HPLWCCZ  /,   NPD/8HPD      /,
     P     NPLWCCF/8HPLWCCF   /,
     P     NPALTF/8HPALTF   /,NPSBC  /8HPSBC    /,NPSFC  /8HPSFC    /,
     P     NPSFDC/8HPSFDC   /,NPSURF /8HPSURF   /,NPSWC  /8HPSWC    /,
     P     NP210M/8HP210M   /,NPOSDF /8HPOSDF   /,NP2DFLG/8HP2DFLG  /,
     Q     NQCBC /8HQCBC    /,NQCFC  /8HQCFC    /,NQCGC  /8HQCGC    /,
     Q     NQCR  /8HQCR     /,NQCRC  /8HQCRC    /,NQCWC  /8HQCWC    /,
     Q     NQMR  /8HQMR     /,NTHETAQ/8HTHETAQ  /,NQCRCC /8HQCRCC   /,
     Q     NQCDC /8HQCDC    /
      DATA NRATIO/2HRZ/      ,NRE    /8HRE      /,NRHODGE/8HRHODGE  /,
     R     NRHODB/8HRHODB   /,NRHODT /8HRHODT   /,NRHUM  /8HRHUM    /,
     R     NRMACH/8HRMACH   /,NRMACH2/8HRMACH2  /,
     S     NSPHUM/8HSPHUM   /,NSSDF  /8HSSDF    /,NSSFXB /8HSSFXB   /,
     S     NSSFXT/8HSSFXT   /,NSSRD  /8HSSRD    /,NSUM   /2HSM/      ,
     T     NTASB /8HTASB    /,NTASF  /8HTASF    /,NTASD  /8HTASD    /,
     T     NTASG /8HTASG    /,NTASR  /8HTASR    /,NTASW  /8HTASW    /,
     T     NTHETA/8HTHETA   /,NTHETAE/8HTHETAE  /,NTHETAK/8HTHETAK  /,
     T     NTHETAV/8HTHETAV  /,NTLCL /8HTLCL    /,NTRKI  /8HTRKI    /,
     T     NTVIR /8HTVIR    /,NTEO3C /8HTEO3C   /,NTEPC  /8HTEPC    /,
     W     NWMACH/8HWMACH   /,NWMACH2/8HWMACH2  /,
     X     NX200/8HX200    /, NX260  /8HX260    /,
     X     NXXXXXX/8HXXXXXX  /, 
     Y     NY200/8HY200    /, NVARED /8HVARED   /,
     Y     NYYYYY /8HYYYYY   /,
     Z     NZPG    /8HZPG     /
      DATA MAXSOU/9/
C ** NEW VARIABLE NAMES CAN BE ADDED IN SAVE BLOCK ADDNVAR
.USE  ADDNVAR
C
C-----------------------------------------------------------------------
 3000 FORMAT(' CALIB WARNING: AT ',F3.1,' IERR=',I2,' THISOP=',I3,
     1 ' NSTAGE=',I3)
C------------------
C**1.0 THIS SECTION PERFORMS INITIALIZATIONS, EDITING, AND CONSISTENCY
C      CHECKING.
C**1.1 NSTAGE = 1, OR UNDEFINED.  ILLEGAL VALUES IN AN OPERATION.
      IF(NSTAGE .EQ. 1)
       AT = 1.1
       IERR = IERR + 1
       WRITE(KERR,3000) AT,IERR,THISOP,NSTAGE
       RETURN
C-----------------
C**1.2 NSTAGE = 2, CHECK CONTROLS, COMPUTE NEEDED OVERLAP, AND STATE
C      SAV AND SCR SPACE REQUIREMENTS.
C      ALLOCATE SAVE SPACE FOR LAST VALUES OF GUSTO/GUSTR VARIABLES
C      QTHETA,ETHETA,ATXH,DLA/SLYAP(LYMAN ALPHA VARS),LWCCZ,PLWCCZ,DMEC
C
C SUBNAME:POINTER (LOCATION) IN SAVE SPACE
C
C SGUSTO:  1-HX;2-HXX;3-WP3;4-HI3;5-PITCH0;6-THF0;7-VZIO;
C SGUSTR: 11-RHX;12-RHXX;13-RWP3;14-RHI3;15-RPITCH0;16-RTHF0;17-RVZIO
C STHETAQ: 8-SVQTA
C SRICE  : 9-RLAST;51-KCNT
C SETHETA:18-SVETA;
C SATXH  :19-ATBH; 20-ATFH;21-ATWH
c stpl:    22,23,24 (tiso3,4,5)
C SCOUNTS:25-SPRZC
C SAMASS :26-AMXC
C SLYAP1/SDLA : 31-N1;32-RHOLA;33-CORC1
C SYLAP2/SDLA1: 41-N1;42-RHOLA1;43-CORC1
C SLWCCZ : 34-INCLD;35-AJWOFF
C SPLWCCZ: 44-INCLD;45-TWIRE
C SDMEC  : USING SAVE STATEMENT FOR ITIMES,XCORR,YCORR,ISTATN,LASTFQ,
C          INDFRQ,NUMSTATS,VRTLN,VRTLT,STNALT,FQIND
C SCLRAN : 51-CFLAG
      OR IF(NSTAGE .EQ. 2)
       LENSAV(THISOP) = 100
       RETURN
C-----------------
C**1.3 NSTAGE = 3, INITIALIZE FOR THE SPACE WHICH HAS BEEN ALLOCATED
      OR IF(NSTAGE .EQ. 3)
       RETURN
      END IF
C-----------------
C**1.4 NSTAGE = 4, THIS IS THE FIRST CALL WITH NCDO CYCLES OF REAL DATA
C      END OF INITIALIZATION
C**1.5 NSTAGE = 4 OR 5.  WE ARE PROCESSING.  THIS IS NCDO CYCLES OF
C      REAL DATA AT NUMCAL(THISOP) .GE. 1
C---------------------------------------------------------------------
C****** ACCESS THE GENERAL  CONTROLS
C  DEFGEN=1-NAMEOP;2-NAMPD;3-NAMLIB;4-NUMCYC;5-ITYPOP;6-PROJECT(5);
C         7-QCREF(2);8-GUSTIN(8):(1)-LAT,(2)-ALPHA,
C           (3)-XVI,(4)-YVI,(5)-PITCH,(6)-ROLL,(7)-VZI,(8)-PALT
C         9-GUSTR(8)
C PMS FSSP PROBE:10-NCSUMF;11-THRESHF;12-TAU1;13-TAU2;14-TAU3;15-DOF;
C                16-BDIA;17-CWD(4);18-CBIAS(4);19-KRANGE;20-KSTROB;
C                21-KRESET;22-MRATEF;23-MWORDF;24-MCELLF;
C PMS ASASP PROBE:25-NCSUMA;26-THRESHA;27-MRATEA;28-MWORDA;29-MCELLA;
C PMS X200 PROBE:30-NCSUMX;31-THRESHX;32-MRATEX;33-MWORDX;34-MCELLX;
C PMS X260 PROBE:35-NCSUM6;36-THRESH6;37-MRATE6;38-MWORD6;39-MCELL6;
C PMS Y200 PROBE:40-NCSUMY;41-THRESHY;42-MRATEY;43-MWORDY;44-MCELLY;
C PMS LWC       :45-TWIRE;46-CN1;47-EN1
C PMS FSSP SIZEF:48-62
C PMS X200 SIZEX:49
C PMS X260 SIZE6:50
C PMS Y200 SIZEY:51
C     MRATE - PMS PROBE SAMPLING RATE
C     MWORD - TOTAL NO OF WORDS PER SAMPLE OF A PMS PROBE BLOCK
C     MCELL - TOTAL NO OF CELLS PER SAMPLE
C     KRANGE - LOCATION OF FSSP RANGE WORD
C     KSTROB - LOCATION OF FSSP STROBE WORD
C     KRESET - LOCATION OF FSSP RESET WORD
C     NCSUM = THE NO OF CELLS TO BE SUM UP FOR THRESH CHECK
C     THRESH= THRESH FOR PLOTING HISTOGRAM
C     TAU'S ARE MEASURED FSSP PROBE DELAYS IN SECONDS
C     DOF = FSSP MEASURED DEPTH OF FIELD (MM)
C     BDIA = FSSP MEASURED BEAM DIAMETER(MM)
C     FSSP CELL WIDTHS CORRESPONDING TO RANGES(IRANGE)1,2,3,4,(MICRONS)
C     CBIAS = CALIBRATED CELL WIDTH OFFSET     (MICRONS)
C
      INDST =1
.USE  INDEX
C** VALUES OF THE GENERAL CONTROLS STARTS AT ICON(INDVAL+INDEX FOR GEN)
C   WHERE INDEX= INDOFF + ITEM NUMBER
C   LT - PROJECT TITLE FOR PMS HISTOGRAMS
C   NAMQC - NAMES OF QC  USED FOR REFERENCE
C
      INDPJ = INDVAL + ICON(INDOFF+6)
      DO(K=1,5)
       LT(K)=ICON(INDPJ+K-1)
      END DO
      INDQC= INDVAL + ICON(INDOFF+7)
      DO(K= 1,2)
        NAMQC(K)=ICON(INDQC + K -1)
      END DO
      INGUST = INDVAL + ICON(INDOFF+8)
      DO(K= 1,8)
        NGUST(K)=ICON(INGUST+ K -1)
      END DO
      IGUSTR = INDVAL + ICON(INDOFF+9)
      DO(K= 1,8)
        NRGUST(K)=ICON(IGUSTR+ K -1)
      END DO
C** PMS FSSP CALIBRATION COEFS
      ISUMF = INDVAL + ICON(INDOFF+10)
      NCSUMF= ICON(ISUMF)
      ITHRF  = INDVAL + ICON(INDOFF+11)
      THRESHF=  CON(ITHRF)
      ITAU1 = INDVAL + ICON(INDOFF+12)
      TAU1  =  CON(ITAU1)
      ITAU2 = INDVAL + ICON(INDOFF+13)
      TAU2  =  CON(ITAU2)
      ITAU3 = INDVAL + ICON(INDOFF+14)
      TAU3  =  CON(ITAU3)
      IDOF  = INDVAL + ICON(INDOFF+15)
      DOF   =  CON(IDOF)
      IBDIA = INDVAL + ICON(INDOFF+16)
      BDIA  =  CON(IBDIA)
      IFW = INDVAL + ICON(INDOFF+17)
      IFB = INDVAL + ICON(INDOFF+18)
      DO(IL=1,4)
        CWD(IL)  = CON(IFW+IL-1)
        CBIAS(IL)= CON(IFB+IL-1)
      END DO
      IRANGE = INDVAL + ICON(INDOFF+19)
      KRANGE= ICON(IRANGE)
      ISTROB = INDVAL + ICON(INDOFF+20)
      KSTROB= ICON(ISTROB)
      IRESET = INDVAL + ICON(INDOFF+21)
      KRESET= ICON(IRESET)
      IRATEF = INDVAL + ICON(INDOFF+22)
      MRATEF= ICON(IRATEF)
      IWORDF = INDVAL + ICON(INDOFF+23)
      MWORDF= ICON(IWORDF)
      ICELLF = INDVAL + ICON(INDOFF+24)
      MCELLF= ICON(ICELLF)
C** PMS ASASP CALIBRATION COEFS
      ISUMA = INDVAL + ICON(INDOFF+25)
      NCSUMA= ICON(ISUMA )
      ITHRA  = INDVAL + ICON(INDOFF+26)
      THRESHA=  CON(ITHRA)
      IRATEA = INDVAL + ICON(INDOFF+27)
      MRATEA= ICON(IRATEA)
      IWORDA = INDVAL + ICON(INDOFF+28)
      MWORDA= ICON(IWORDA)
      ICELLA= INDVAL + ICON(INDOFF+29)
      MCELLA= ICON(ICELLA)
C** PMS X200 CALIBRATION COEFS
      ISUMX = INDVAL + ICON(INDOFF+30)
      NCSUMX= ICON(ISUMX)
      ITHRX  = INDVAL + ICON(INDOFF+31)
      THRESHX=  CON(ITHRX)
      IRATEX= INDVAL + ICON(INDOFF+32)
      MRATEX= ICON(IRATEX)
      IWORDX= INDVAL + ICON(INDOFF+33)
      MWORDX= ICON(IWORDX)
      ICELLX= INDVAL + ICON(INDOFF+34)
      MCELLX= ICON(ICELLX)
C** PMS X260 CALIBRATION COEFS
      ISUM6 = INDVAL + ICON(INDOFF+35)
      NCSUM6= ICON(ISUM6)
      ITHR6  = INDVAL + ICON(INDOFF+36)
      THRESH6=  CON(ITHR6)
      IRATE6= INDVAL + ICON(INDOFF+37)
      MRATE6= ICON(IRATE6)
      IWORD6 = INDVAL + ICON(INDOFF+38)
      MWORD6= ICON(IWORD6)
      ICELL6= INDVAL + ICON(INDOFF+39)
      MCELL6= ICON(ICELL6)
C** PMS Y200 CALIBRATION COEFS
      ISUMY = INDVAL + ICON(INDOFF+40)
      NCSUMY= ICON(ISUMY )
      ITHRY = INDVAL + ICON(INDOFF+41)
      THRESHY=  CON(ITHRY)
      IRATEY = INDVAL + ICON(INDOFF+42)
      MRATEY= ICON(IRATEY)
      IWORDY = INDVAL + ICON(INDOFF+43)
      MWORDY= ICON(IWORDY)
      ICELLY = INDVAL + ICON(INDOFF+44)
      MCELLY= ICON(ICELLY)
C** PMS LIQUIT WATER CONSTANTS:TWIRE,CN1,EN1
      ITWIRE = INDVAL + ICON(INDOFF+45)
      TWIRE = CON(ITWIRE)
      ICN1  = INDVAL + ICON(INDOFF+46)
      CN1   = CON(ICN1)
      IEN1 = INDVAL + ICON(INDOFF+47)
      EN1  = CON(IEN1)
C** PMS CELL SIZE TABLE OR CALCULATION CONSTANT
      ISZF= INDVAL + ICON(INDOFF+48)
      DO(IL=1,15)
        SIZEF(IL)= CON(ISZF+IL-1)
      END DO
      ISZX= INDVAL + ICON(INDOFF+49)
      SIZEX = CON(ISZX)
      ISZ6= INDVAL + ICON(INDOFF+50)
      SIZE6 = CON(ISZ6)
      ISZY= INDVAL + ICON(INDOFF+51)
      SIZEY = CON(ISZY)
C** CONSTANTS USED IN DERIVING LAYMAN ALPHA VARIABLES (DLA/DLA1)
C** DLA
      ICX = INDVAL + ICON(INDOFF+52)
      DO(IC=1,4)
        CX(IC)= CON(ICX+IC-1)
      END DO
      IXC= INDVAL + ICON(INDOFF+53)
      XC = CON(IXC)
C** DLA1
      ICX1 = INDVAL + ICON(INDOFF+54)
      DO(IC=1,4)
        CX1(IC)= CON(ICX1+IC-1)
      END DO
      IXC1= INDVAL + ICON(INDOFF+55)
      XC1 = CON(IXC1)
C--------------------------------------------------------------------
C       ACCESS THE VARIABLE CONTROLS
C   DEFVAR =1-NAMVAR;2-INDGET;3-INRATE;4-INDPUT;5-RATE;6-UNITS,7-TITLE;
C           8-CONS1;9-CONSN;10-CONSU;11-NUMSOU;12-DERIVE();13-CONVERT;
C           14-KONVU
C  1 NAMVAR   THE NAME OF THE VARIABLE
C  2 INDGET   INDEX GET
C  3 INRATE   INPUT RATE
C  4 INDPUT   INDEX PUT
C  5 RATE     OUTPUT RATE
C  6 UNITS    THE UNIT FOR EACH PARAMETER
C  7 TITLE    TITLE OF EACH PARAMETER (UP TO 40 CHAR)
C  8 CONS1    CONSTANT TO BE ADDED OR MULTIPLIED TO A DERIVED VARIABLE
C  9 CONSN    CONSTANT NAME ('BIAS','OFFSET',...)
C 10 CONSU    UNIT FOR THE CONSTANT
C 11 NUMSOU   NUMBER OF INPUT SOURCE VARIABLES USED IN DERIVATION OF
C             A DERIVED VARIABLE
C 12 DERIVE   INDICES OF INPUT SOURCE VARIABLES WHICH ARE NEEDED
C             BY THE DERIVED-VARIABLE
C 13 CONVERT  CONSTANT USED TO CONVERT A VALUE FROM ONE UNIT TO ANOTHER
C 14 KONVUF   CONVERSION UNITS FROM  ( 'M/S')
C-----------------------------------------------------------------------
      INDST =2
.USE  INDEX
C      IF(NSTAGE.EQ.4)CALL CPRINT(0,6,128,8,5,DUM,0)
      IOFF01= ICON(INDOFF+  1)
      IOFF02= ICON(INDOFF+  2)
      IOFF03= ICON(INDOFF+  3)
      IOFF04= ICON(INDOFF+  4)
      IOFF05= ICON(INDOFF+  5)
      IOFF06= ICON(INDOFF+  6)
      IOFF07= ICON(INDOFF+  7)
      IOFF08= ICON(INDOFF+  8)
      IOFF09= ICON(INDOFF+  9)
      IOFF10= ICON(INDOFF+ 10)
      IOFF11= ICON(INDOFF+ 11)
      IOFF12= ICON(INDOFF+ 12)
      IOFF13= ICON(INDOFF+ 13)
      IOFF14= ICON(INDOFF+ 14)
C-----------------------------------------------------------------------
      IY= 1000
      IXK = 0
      KT0 = 0
      KT1 = 0
      KT2 = 0
      KT3 = 0
      KT4 = 0
      KT5 = 0
      KT6 = 0
      KT7 = 0
      KT8 = 0
      KONS = 0
      KONV = 0
      DO (K=1,NUMVEC)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR=ICON(IND +IOFF01)
       INDGET   = ICON(IND+IOFF02)
       INRATE   = ICON(IND+IOFF03)
       INDPUT   = ICON(IND+IOFF04)
       LRATE    = ICON(IND+IOFF05)
       UNITS    = ICON(IND+IOFF06)
       CONS1 = CON(IND+IOFF08)
       CONSN = ICON(IND+IOFF09)
       CONSU = ICON(IND+IOFF10)
C      IF(NSTAGE.EQ.4 .AND. CONS1 .NE. 99999.0)
C       KONS= KONS + 1
C       KONSN(KONS)= NAMVAR
C       CONA(KONS) = CONS1
C       KONN(KONS) = CONSN
C       KONU(KONS) = CONSU
C      END IF
       CONVERT= CON(IND+IOFF13)
       KONVUFT= ICON(IND+IOFF14)
C      IF(NSTAGE.EQ.4 .AND. CONVERT.NE. 1.0)
C       KONV= KONV + 1
C       KONVN(KONV)= NAMVAR
C       CONV(KONV) = CONVERT
C       KONVU(KONV)=KONVUFT
C       KUNIT(KONV)=UNITS
C      END IF
       IF(NAMVAR.EQ. NAMQC(1)  )
        IPQC1 = INDPUT
        LRTQC1 = LRATE
      END IF
      IF(NAMVAR.EQ. NAMQC(2)  )
        IPQC2 = INDPUT
        LRTQC2 = LRATE
       END IF
       DO (KG=1,8)
        IF(NAMVAR.EQ. NGUST(KG))
         IPGUST(KG) = INDPUT
         LRGUST(KG) = LRATE
        END IF
       END DO
       DO (KG=1,8)
        IF(NAMVAR.EQ. NRGUST(KG))
         IRGUST(KG) = INDPUT
         LRGUSTR(KG) = LRATE
        END IF
       END DO
       LDO = NCDO * LRATE
       NUMSOU   = ICON(IND+IOFF11)
C-----------------------------------------------------------------------
C** INRATE.GT.0 - CALL MOVESP TO MOVE INPUT DATA FROM INDGET TO INDPUT
C               - CALL SMOVE TO MOVE DATA WITH OFFSET(CONSTANT) ADDED
C               - MOVE HAS TO BE DONE BEFORE DERIVATION BEGINS
C               - IN A MOVE INPUT RATE MUST AGREE WITH THE OUTPUT RATE
       IF(INRATE .GT. 0 .AND. NUMSOU.EQ.0)
        IF(INRATE.NE. LRATE)
         IF(NSTAGE.EQ.4)WRITE(KPROC,90) NAMVAR,INRATE,LRATE
         GO TO 9
        END IF
        IF(CONS1 .EQ. 99999.0)
         CALL MOVESP(DATA,INDGET,1,DATA,INDPUT,1,LDO)
        ELSE
         CALL SMOVE
        END IF
       END IF
C----------------------------------------------------------------------
C** NUMSOU.GT.0 - DERIVATION REQUIRED
C** INRATE.EQ.0 - DATA TO BE DERIVED FROM OTHER VARIABLES IN A
C               A) SINGLE OUTPUT SUBROUTINE ;
C               B) MULTIPLE OUTPUT SUBROUTINE (FOR PMS/GUSTO VARIABLES)
       IF( NUMSOU.GT.0 )
C----------------------------------------------------------------------
C** NSTAGE=4 --  PRINT OUT BIAS/CONS/OFFSET,CONVERTION FACTOR AND
C   DERIVATION INFORMATION ON PAPER OUTPUT AND  MICROFILM VIA PWRT
C
        IF(NSTAGE.EQ.4)
C**      PICK UP THE SOURCE VARIABLE NAMES HERE
         DO(J=1,NUMSOU)
          INDKS = IND+(J-1) + IOFF12
          KSOU  = ICON(INDKS )
          INDNS = INDVAL+LENCON*(KSOU-1) + IOFF01
          NAMSOU( J) = ICON(INDNS)
         END DO
  109    FORMAT(' CALIB: ',A8,' IS DERIVED FROM VARIABLES ',9A8)
         WRITE(KPROC,109)NAMVAR,(NAMSOU(KV),KV=1,NUMSOU)
         ENCODE(115,109,ARAY) NAMVAR,(NAMSOU(KV),KV=1,NUMSOU)
         CALL PWRIT(CPUX(10),CPUY(IY),ARAY,115,0,0,-1)
.USE  LINPR
  108  FORMAT(' CALIB: ',A8,' USES CONSTANT ',A8,' = ',G15.7,' UNIT = ',
     1 A8,' IN THE COMPUTATION')
  419  FORMAT(' CALIB: ',A8,' USES FUNCTION RECOVERY FACTOR ')
        IF(CONS1 .NE. 99999.)
         IF(CONSN.EQ.NCONSN)
          PRINT 419, NAMVAR
         ELSE
          ENCODE(92,108,ARAY) NAMVAR,CONSN,CONS1,CONSU
          WRITE(KPROC,108) NAMVAR,CONSN,CONS1,CONSU
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,92,0,0,-1)
.USE  LINPR
         END IF
        END IF
  107  FORMAT(' CALIB: ',A8,' USES A FACTOR = ',G15.7,
     1 ' TO CONVERT UNITS FROM ',A8,' TO ',A8)
  707  FORMAT(' CALIB: ',A8,' USES A BIAS OF ',G15.7)
        IF(CONVERT.NE.1.0)
         if(namvar.eq.ntasf)
          ENCODE(47,707,ARAY) NAMVAR,CONVERT
          WRITE(KPROC,707) NAMVAR,CONVERT
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,47,0,0,-1)
         else
          ENCODE(91,107,ARAY) NAMVAR,CONVERT,KONVUFT,UNITS
          WRITE(KPROC,107) NAMVAR,CONVERT,KONVUFT,UNITS
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,91,0,0,-1)
         end if
.USE  LINPR
        END IF
C
         IF(NAMVAR.EQ.NGUSTO)
  284 FORMAT(' CALIB:',8A8,' ARE USED IN COMP. OF GUST VARIABLES')
          ENCODE(107,284,ARAY) NGUST
          WRITE(KPROC,284) NGUST
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,107,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NGUSTR .OR. NAMVAR.EQ.NGUSTD)
  285 FORMAT(' CALIB:',8A8,' ARE USED IN COMP. OF GUSTR VARIABLES')
          ENCODE(108,285,ARAY) NGUST
          WRITE(KPROC,285) NGUST
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,108,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NFSSP)
  201 FORMAT(' SUM OF RAW COUNTS OF THE 1ST ',I2,1X,A4,' PROBE CELLS',
     1' EXCEEDS ',F5.1,' IN ',F5.1,' SEC, A HISTOGRAM WILL BE PLOTTED')
  202 FORMAT(' PMS PROBE ',A8,' SAMPLING RATE PER SEC = ',I2,
     1',NO OF WORDS PER SAMPLE = ',I4,',NO OF CELLS = ',I3)
  205 FORMAT(' PMS FSSP PROBE WORD LOCATION FOR RANGE = ',I3,
     1',STROBE = ',I3,',RESET = ',I3)
  206 FORMAT(' CALIB: ',A8,' USES PMS CALIBRATION COEFS:  ',
     1' CELL WIDTH -- CWD(4) ',4F9.3 )
  207 FORMAT(36X,' CALIBRATED CELL WIDTH OFFSET -- CBIAS(4) ',4F9.3)
  208 FORMAT(36X,' SLOW RESET(TAU1),FAST RESET(TAU2),TAU3 ',3F12.9)
  209 FORMAT(36X,' DEPTH OF FIELD(DOF), BEAM DIAMETER(BDIA) ',2G15.7)
  301 FORMAT(' FSSP SIZE TABLE ',15F6.2)
  303 FORMAT(' PMS PROBE ',A8,' SAMPLING RATE PER SEC = ',I2,
     1',NO OF WORDS PER SAMPLE = ',I4,',NO OF CELLS = ',I3,
     2',SIZE CONS= ',F5.1)
C         WRITE(KPROC,301) SIZEF
C         ENCODE(107,301,ARAY) SIZEF
C         CALL PWRIT(CPUX(10),CPUY(IY),ARAY,107,0,0,-1)
C .USE  LINPR
          WRITE(KPROC,202) NAMVAR,MRATEF,MWORDF,MCELLF
          ENCODE(94,202,ARAY) NAMVAR,MRATEF,MWORDF,MCELLF
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,94,0,0,-1)
.USE  LINPR
C         WRITE(KPROC,206) NAMVAR,CWD
C         ENCODE(104,206,ARAY) NAMVAR,CWD
C         CALL PWRIT(CPUX(10),CPUY(IY),ARAY,104,0,0,-1)
C .USE  LINPR
C          WRITE(KPROC,207) CBIAS
C          ENCODE(114,207,ARAY) CBIAS
C          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,114,0,0,-1)
C  .USE  LINPR
          WRITE(KPROC,208) TAU1,TAU2,TAU3
          ENCODE(112,208,ARAY) TAU1,TAU2,TAU3
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,112,0,0,-1)
.USE  LINPR
          WRITE(KPROC,209) DOF,BDIA
          ENCODE(108,209,ARAY) DOF,BDIA
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,108,0,0,-1)
.USE  LINPR
          WRITE(KPROC,201) NCSUMF,NAMVAR,THRESHF,CONS1
          ENCODE(105,201,ARAY) NCSUMF,NAMVAR,THRESHF,CONS1
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,105,0,0,-1)
.USE  LINPR
          WRITE(KPROC,205) KRANGE,KSTROB,KRESET
          ENCODE(70,205,ARAY) KRANGE,KSTROB,KRESET
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,70,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NY200)
          WRITE(KPROC,303) NAMVAR,MRATEY,MWORDY,MCELLY,SIZEY
          ENCODE(111,303,ARAY) NAMVAR,MRATEY,MWORDY,MCELLY,SIZEY
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,111,0,0,-1)
.USE  LINPR
          WRITE(KPROC,201) NCSUMY,NAMVAR,THRESHY,CONS1
          ENCODE(105,201,ARAY) NCSUMY,NAMVAR,THRESHY,CONS1
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,105,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NASAS)
          WRITE(KPROC,202) NAMVAR,MRATEA,MWORDA,MCELLA
          ENCODE(94,202,ARAY) NAMVAR,MRATEA,MWORDA,MCELLA
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,94,0,0,-1)
.USE  LINPR
          WRITE(KPROC,201) NCSUMA,NAMVAR,THRESHA,CONS1
          ENCODE(105,201,ARAY) NCSUMA,NAMVAR,THRESHA,CONS1
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,105,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NX200)
          WRITE(KPROC,303) NAMVAR,MRATEX,MWORDX,MCELLX,SIZEX
          ENCODE(111,303,ARAY) NAMVAR,MRATEX,MWORDX,MCELLX,SIZEX
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,111,0,0,-1)
.USE  LINPR
          WRITE(KPROC,201) NCSUMX,NAMVAR,THRESHX,CONS1
          ENCODE(105,201,ARAY) NCSUMX,NAMVAR,THRESHX,CONS1
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,105,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NX260)
          WRITE(KPROC,303) NAMVAR,MRATE6,MWORD6,MCELL6,SIZE6
          ENCODE(111,303,ARAY) NAMVAR,MRATE6,MWORD6,MCELL6,SIZE6
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,111,0,0,-1)
.USE  LINPR
          WRITE(KPROC,201) NCSUM6,NAMVAR,THRESH6,CONS1
          ENCODE(105,201,ARAY) NCSUM6,NAMVAR,THRESH6,CONS1
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,105,0,0,-1)
c.USE  LINPR
C
c         OR IF(NAMVAR.EQ.NPLWCC)
c          WRITE(KPROC,302) NAMVAR,TWIRE,CN1,EN1
c  302 FORMAT(' CALIB: ',A8,' USES TWIRE= ',F9.2 ,',CN1= ',F8.3 ,
c     1',EN1= ',F8.3 ,' IN THE CALCULATON OF ANUP=CN1*REYNO**EN1')
c          ENCODE(107,302,ARAY) NAMVAR,TWIRE,CN1,EN1
c          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,107,0,0,-1)
.USE  LINPR
C
         OR IF(NAMVAR.EQ.NPLWCC)
          WRITE(KPROC,302) NAMVAR,TWIRE
  302 FORMAT(' CALIB: ',A8,' USES TWIRE = ',G15.7)
          ENCODE(45,302,ARAY) NAMVAR,TWIRE
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,45,0,0,-1)
.USE  LINPR
         OR IF(NAMVAR.EQ.NDLA)
  403 FORMAT(' CALIB: ',A8,' USES COEFFICIENTS FROM EMPIRICAL FIT ',
     1       4F8.3,' PATHLENGTH OF LYMAN ALPHA= ',F6.2 )
          WRITE(KPROC,403) NAMVAR,CX,XC
          ENCODE(120,403,ARAY) NAMVAR,CX,XC
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,120,0,0,-1)
.USE  LINPR
         OR IF(NAMVAR.EQ.NDLA1)
          WRITE(KPROC,403) NAMVAR,CX1,XC1
          ENCODE(120,403,ARAY) NAMVAR,CX1,XC1
          CALL PWRIT(CPUX(10),CPUY(IY),ARAY,120,0,0,-1)
.USE  LINPR
         END IF
       END IF
C** END OF NSTAGE=4 CHECK-------------------------------------
C-----------------------------------------------------------------------
   90 FORMAT(' CALIB WARNING: ',A8,' INRATE= ',I2,' LRATE= ',I2,
     1' DATA VALUE SET TO 99999. FOR THIS VARIABLE OUTPUT AT LRATE')
   92 FORMAT(' CALIB WARNING: NAMVAR= ',A8,' LRATE=',I3,' NAMSOU= ',A8,
     1 'RATE=',I2,/,' --CHECK THE RATES OF YOUR SOURCE/OUTPUT VARS !!!',
     2' DIF. RATE OF TASX USED IN PMS SUBS -OK;DF/SMXX -1PT PICK OFF ',/
     3,' DMEC OK FOR ALAT,ALON,PALT; PLWCCZ OK FOR CONCF')
   91 FORMAT(' CALIB WARNING: ',A8,' NEEDS ',I2,' SOURCE VAR. ',A8,
     1  ' NOT ON THE VECVAR LIST. 99999. STORED AT LRATE')
C
        ISFLAG = 0
        DO(J=1,NUMSOU)
         INDD= IND+IOFF12+(J-1)
         KSOU= ICON(INDD)
         NAMSOU(J) = ICON(INDS+IOFF01)
         IF(KSOU.LE.0)
          ISFLAG = ISFLAG+1
          IF(NSTAGE.EQ.4) WRITE(KPROC,91) NAMVAR,NUMSOU,NAMSOU(J)
         ELSE
C
          ENCODE(2,13,KEYWD) NAMVAR
          IF(NAMVAR.EQ.NASAS.OR.NAMVAR.EQ.NFSSP.OR.NAMVAR.EQ.NX200
     1       .OR.NAMVAR.EQ.NX260.OR.NAMVAR.EQ.NY200) GO TO 88
          IF(KEYWD.EQ. NDIF .OR. KEYWD.EQ.NSUM) GO TO 88
C-------------------------------------------------
C** PICK UP THE SOURCE VARIABLE RATES HERE - IF INPUT VARIABLE RATES
C   DIFFER FROM OUTPUT VAR. RATE, WARNING MSG PRINTED
          INDS = INDVAL + LENCON *(KSOU-1)
          NAMSOU(J) = ICON(INDS+IOFF01)
          LRTSOU(J) = ICON(INDS + IOFF05)
          IF(LRTSOU(J).NE.LRATE.AND.NSTAGE.EQ.4)
     1      PRINT 92, NAMVAR,LRATE,NAMSOU(J),LRTSOU(J)
         END IF
   88    CONTINUE
        END DO
        IF(ISFLAG.GT.0)
.USE   D99999
         GO TO 9
        END IF
C-------
        KT0 = KT0 + 1
        KTSV(KT0) = K
       END IF
   9   CONTINUE
       IF(CONS1.NE.99999. .AND. NSTAGE.EQ.4 .AND. NUMSOU.LE.0)
        ENCODE(87,108,ARAY) NAMVAR,CONSN,CONS1,CONSU
        WRITE(KPROC,108) NAMVAR,CONSN,CONS1,CONSU
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,87,0,0,-1)
.USE  LINPR
       END IF
      END DO
C----------------------------------------------------------------------
C**    PRINT OUT BIAS/CONS/OFFSET INFORMATON ON THE MICROFILM VIA PWRT
C 108  FORMAT(' CALIB: ',A8,' USES CONSTANT ',A8,' = ',F10.3,' UNIT = ',
C    1 A8,' IN THE COMPUTATION')
C      IF(NSTAGE.EQ.4 )
C       DO (KC=1,KONS)
C        ENCODE(87,108,ARAY) KONSN(KC),KONN(KC),CONA(KC),KONU(KC)
C        WRITE(KPROC,108) KONSN(KC),KONN(KC),CONA(KC),KONU(KC)
C        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,87,0,0,-1)
C USE  LINPR
C       END DO
C 107  FORMAT(' CALIB: ',A8,' USES A FACTOR= ',F10.3,
C    1 ' TO CONVERT UNITS FROM ',A8,' TO ',A8)
C       DO (KC=1,KONV)
C        ENCODE(85,107,ARAY) KONVN(KC),CONV(KC),KONVU(KC),KUNIT(KC)
C        WRITE(KPROC,107) KONVN(KC),CONV(KC),KONVU(KC),KUNIT(KC)
C        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,85,0,0,-1)
C USE  LINPR
C       END DO
C
C**   PRINT OUT GENERAL CONTROLS ON THE MICROFILM VIA PWRT
  282   FORMAT(' CALIB: ',2A8,' ARE USED AS QC REFERENCE VARS.')
  283   FORMAT(' ALL HUMIDITY AND WATER VAPOR CALCULATIONS ARE BASED',
     1         ' ON GOFF-GRATCH FORMULATON.  AN ENHANCEMENT FACTOR IS')
  294   FORMAT(' INCORPORATED INTO THIS CALCULATION TO ACCOUNT FOR THE',
     1         ' DIFFERENCES BETWEEN PURE WATER VAPOR AND MOIST AIR.' )
  295   FORMAT(' PLEASE SEE NCAR/RAF BULLETIN 9 FOR MORE INFORMATION.')
C
       IF(NSTAGE.EQ.4)
        ENCODE(105,283,ARAY)
        WRITE(KPROC,283)
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,105,0,0,-1)
.USE  LINPR
        ENCODE(106,294,ARAY)
        WRITE(KPROC,294)
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,106,0,0,-1)
.USE  LINPR
        ENCODE( 53,295,ARAY)
        WRITE(KPROC,295)
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,53,0,0,-1)
.USE  LINPR
        ENCODE(55,282,ARAY) NAMQC
        WRITE(KPROC,282) NAMQC
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,55,0,0,-1)
.USE  LINPR
      END IF
C***************************************************************************
C****************       LEVEL ONE DERIVATION        ************************
C***************************************************************************
      IF(KT0.GT.0)
      DO (KT=1,KT0)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR =ICON(IND +IOFF01)
       INDGET = ICON(IND+IOFF02)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       CONS1  =  CON(IND+IOFF08)
       NUMSOU = ICON(IND+IOFF11)
       LDO    = NCDO*LRATE
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
C**     PICK UP THE SOURCE VARIABLE'S RATE AND INDPUT HERE
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------------ DPC,DPRBC,DPRTC
C** DEWPOINT TEMPERATURE (THERMOELEC) (C)
      IF(NAMVAR.EQ.NDPC .OR. NAMVAR.EQ.NDPBC .OR. NAMVAR.EQ.NDPTC
     1      .OR. NAMVAR.EQ.NDPGEC .OR. NAMVAR.EQ.NDPCVC)
       CALL SDPC
C------------------------------------------------ GSF
C** GROUND SPEED
      OR IF(NAMVAR   .EQ. NGSF     )
       CALL  SGSF
C------------------------------------------------ IRBC,IRTC,TPYGC2
C** CORRECTED PYRGEOMTER IRRADIANCE (TOP/BOTTOM)(WATTS/M2)
      OR IF(NAMVAR.EQ.NIRBC.OR.NAMVAR.EQ.NIRTC)
        CALL SIRTBC
C------------------------------------------------ POSDF
C** DIFF. IN POSITION BETWEEN INS AND LORAN C (NMI)
      OR IF(NAMVAR   .EQ.NPOSDF   )
        CALL SPOSDF
C------------------------------------------------ PSFC,PSWC
C** CORRECTED STATIC PRESSURE (FUSELAGE/FUSELAGE DIGITAL/WING)
      OR IF(NAMVAR.EQ.NPSFC .OR. NAMVAR.EQ.NPSBC .OR. NAMVAR.EQ.NPSWC
     1       .OR. NAMVAR.EQ.NPSFDC .OR. NAMVAR.EQ.NPSFDC20)
         CALL SPSXC
C------------------------------------------------ QCFC,QCWC
C** CORRECTED DYNAMIC PRESSURE (FUSELAGE/WING) (MB)
      OR IF(NAMVAR.EQ.NQCWC .OR. NAMVAR.EQ.NQCGC
     1 .OR. NAMVAR.EQ.NQCBC .OR. NAMVAR.EQ.NQCDC .OR. NAMVAR.EQ.NQCFC20)
       CALL SQCXC
S     OR IF(NAMVAR.EQ.NQCFC)
S      CALL SQCXC
Q     OR IF(NAMVAR.EQ.NQCFC)
Q      CALL SQCXC
C  ELECTRA PROJECT ONLY (308)
E     OR IF(NAMVAR.EQ.NQCFC )
E      CALL SQCFC
C------------------------------------------------ QCRC
C** CORRECTED RADOME PRESS. (MB)
      OR IF(NAMVAR   .EQ.NQCRC  )
        CALL SQCRC
C--------------------------------------------------- ATOPH
C** OPHIR RADIOMETER AMBIENT TEMPERATURE (C)
      OR IF(NAMVAR .EQ. NATOPH     )
        CALL SATOPH
C------------------------------------------------ TEPC
C** CORRECTED INTERNAL SAMPLING PRESSURE (MB)
      OR IF(NAMVAR   .EQ.NTEPC )
         CALL STEPC
C------------------------------------------------ COUNTS
C** COUNTS DIFFERENCE OF SPARE ICE NUCLEI COUNTER
C     OR IF(NAMVAR.EQ.NCOUNTS )
C        CALL SCOUNTS
C------------------------------------------------ ZPG
C** GEOPOTENTIAL HEIGHT (M)
C     OR IF(NAMVAR .EQ. NZPG       )
C       CALL SZPG
C-----------------------------------------------------------------------
C **  ADD LEVEL ONE NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV1
.USE  ADDV1
C-----------------------------------------------------------------------
      ELSE
       KT1 = KT1+1
       KTSV(KT1) = K
      END IF
      END DO
      END IF
C***************************************************************************
C****************       LEVEL TWO DERIVATION        ************************
C***************************************************************************
      IF(KT1.GT.0)
      DO (KT=1,KT1)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR =ICON(IND +IOFF01)
       INDGET = ICON(IND+IOFF02)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       CONS1  =  CON(IND+IOFF08)
       CONSN = ICON(IND+IOFF09)
       NUMSOU = ICON(IND+IOFF11)
       LDO    = NCDO*LRATE
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------- AKFXL,AKFXR,SSFXB,SSFXT
C** ATTACK ANGLE (FIXED VANE) (DEG)
C** SIDESLIP ANGLE (FIXED VANE) (DEG)
      IF(NAMVAR.EQ.NAKFXL.OR.NAMVAR.EQ.NAKFXR.OR.NAMVAR.EQ.NSSFXB
     1  .OR.NAMVAR.EQ.NSSFXT)
        CALL SABFIX
C------------------------------------------------ AKDF,SSDF
C** ATTACK ANGLE/SIDESLIP ANGLE(ROSEMOUNT) (DEG)
      OR IF(NAMVAR.EQ.NAKDF .OR.NAMVAR.EQ.NSSDF    )
        CALL SATKSLP
C------------------------------------------------ ATRF
C** AMBIENT TEMPERATURE (REVERSE FLOW   ) (C)
      OR IF(NAMVAR   .EQ.NATRF    )
        CALL SATRF
C------------------------------------------------ ATB,ATB2,ATF,ATKP,ATW
C** AMBIENT TEMPERATURE (BOOM/ROSEMOUNT/FAST RESPONSE/FUSELAGE/WING)   (C)
      OR IF(NAMVAR.EQ.NATB.OR.NAMVAR.EQ.NATF.OR.NAMVAR.EQ.NATKP
     1  .OR.NAMVAR.EQ. NATW .OR. NAMVAR.EQ.NATRW.OR.NAMVAR.EQ.NATFR)
       CALL  SATX
      OR IF(NAMVAR.EQ.NATB1.OR.NAMVAR.EQ.NATR3.OR.NAMVAR.EQ.NATR6
     1  .OR.NAMVAR.EQ.NATRE.OR.NAMVAR.EQ.NATKPR .OR.NAMVAR.EQ.NATF20)
       CALL  SATX
C------------------------------------------------ ATBH,ATFH,ATWH
C** AMBIENT TEMPERATURE (DEICED ROSEMOUNT) (BOOM/FUSELAGE/WING)
      OR IF(NAMVAR.EQ.NATBH .OR. NAMVAR.EQ.NATFH .OR. NAMVAR.EQ.NATWH)
        CALL SATXH
C------------------------------------------------ IAS
C** INDICATED AIRSPEED (M/S)
      OR IF(NAMVAR .EQ. NIAS      )
        CALL SIAS
C------------------------------------------------ PALT
C** NCAA PRESSURE ALTITUDE (M)
      OR IF(NAMVAR .EQ. NPALT .OR. NAMVAR.EQ.NPALT20 )
       CALL  SPALT
C------------------------------------------------ PALTF
C**      PRESSURE ALTITUDE (FT)
      OR IF(NAMVAR .EQ. NPALTF     )
       CALL  SPALTF
C ---------------------------------------- TASD, TASB,TASF,TASG,TASW
C******* AIRCRAFT TRUE AIRSPEED (BOOM/FUSELAGE/GUST PROBE/WING)   (M/S)
      OR IF(NAMVAR.EQ.NTASB.OR.NAMVAR.EQ.NTASF.OR.NAMVAR.EQ.NTASG
     1 .OR. NAMVAR.EQ.NTASW .OR. NAMVAR.EQ.NTASR .OR. NAMVAR.EQ.NTASD)
       CALL  STASX
C-------------------------------------------------  MACH(B/F/G/W)
      OR IF(NAMVAR.EQ.NBMACH.OR.NAMVAR.EQ.NFMACH .OR. NAMVAR.EQ.NRMACH
     1 .OR. NAMVAR.EQ.NGMACH.OR.NAMVAR.EQ.NWMACH)
         CALL SXMACH
C-------------------------------------------------  MACH2(B/F/G/W)
      OR IF(NAMVAR.EQ.NBMACH2.OR.NAMVAR.EQ.NFMACH2.OR.NAMVAR.EQ.NRMACH2
     1 .OR. NAMVAR.EQ.NGMACH2.OR.NAMVAR.EQ.NWMACH2)
         CALL SXMACH2
C------------------------------------------------ HGME
C** Corrected Geometric Radar Altitude (APN-159)
C    Added by RLR 12DEC91 for 1-815
      OR IF(NAMVAR   .EQ.NHGME )
         CALL SHGME
C------------------------------------------------ CRFLO
C** CORRECTED VOL. FLOW RATE PROJ 240
C     OR IF(NAMVAR   .EQ.NCRFLO )
C        CALL SCRFLO
C------------------------------------------------ CLDHT
C** LIDAR - HEIGHT TO CLOUD BOUNDARY
C     OR IF(NAMVAR   .EQ.NCLDHT )
C        CALL SCLDHT
C-----------------------------------------------------------------------
C **  ADD LEVEL TWO NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV2
.USE  ADDV2
C-----------------------------------------------------------------------------
      ELSE
       KT2 = KT2+1
       KTSV(KT2) = K
      END IF
      END DO
      END IF
C***************************************************************************
C****************       LEVEL THREE DERIVATION        **********************
C***************************************************************************
      IF(KT2.GT.0)
      DO (KT=1,KT2)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR =ICON(IND +IOFF01)
       INDGET = ICON(IND+IOFF02)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       CONS1  =  CON(IND+IOFF08)
       NUMSOU = ICON(IND+IOFF11)
       LDO    = NCDO*LRATE
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------------ CONC2C
C** TWO-D(C) CONCENTRATION FROM SHADOW - OR
      IF(NAMVAR   .EQ.NCONC2C )
        CALL SCONC2C
C------------------------------------------------ CONC2P
C** TWO-D(P) CONCENTRATION FROM SHADOW - OR
      OR IF(NAMVAR   .EQ.NCONC2P )
        CALL SCONC2P
C------------------------------------------------ CONC2P2
C** TWO-D(P)-2 CONCENTRATION FROM SHADOW - OR - 2
C      OR IF(NAMVAR   .EQ.NCONC2P2 )
C        CALL SCONC2P2
C------------------------------------------------ DO3C
C** CORRECTED OZONE CONCENTRATION (PARTS PER BILLION-PPB)
      OR IF(NAMVAR   .EQ.NDO3C  )
        CALL SDO3C
C------------------------------------------------ COC
C** CORRECTED CARBON MONOXIDE OUTPUT (PARTS PER BILLION-PPB)
      OR IF(NAMVAR   .EQ.NCOC   )
        CALL SCOC
C------------------------------------------------- SCLWC
C** SUPERCOOLED LIQUID WATER CONTENT
      OR IF(NAMVAR .EQ. NSCLWC     )
        CALL SSCLWC
C------------------------------------------------ DVALU
C** D-VALUE  (HGME - HP)  (FT)
      OR IF(NAMVAR   .EQ.NDVALU  )
        CALL SDIF
C------------------------------------------------ DPCRC
C** CORRECTED CRYOGENIC DEW POINT
      OR IF(NAMVAR   .EQ.NDPCRC )
         CALL SDPCRC
C------------------------------------------------ CRYOC
C** CORRECTED CRYOGENIC VARIABLES
      OR IF(NAMVAR   .EQ.NCRYOC )
         CALL SCRYOC
C------------------------------------------------ RHORF
C** ABSOLUTE HUMIDITY FROM MICROWAVE RERACTOMETER (G/M3)
      OR IF(NAMVAR   .EQ.NRHORF)
         CALL SRHORF
C------------------------------------------------ CNC
C** CORRECTED CN CNOUNTER VARIABELS
      OR IF(NAMVAR   .EQ.NCNC   )
         CALL SCNC
C------------------------------------------------ DMEC
C** DME DERVATION
      OR IF(NAMVAR   .EQ.NDMEC  )
        CALL SDMEC
C------------------------------------------------ LWCC
C** CORRECTED J-W LIQUID WATER CONTENT
      OR IF(NAMVAR .EQ. NLWCC)
       CALL SLWCC
C------------------------------------------------- PLWCC
C** PMS-KING  LIQUID WATER CONTENT
      OR IF (NAMVAR .EQ.NPLWCC)
        CALL SPLWCC
C------------------------------------------------ PSURF
C** SURFACE PRESSURE
      OR IF(NAMVAR .EQ. NPSURF    )
        CALL SPSURF
C------------------------------------------- RHODB,RHODT,GERHOTD
C** ABSOLUTE HUMIDITY (THERMOELEC) (G/M3)
      OR IF(NAMVAR.EQ.NRHODT.OR.NAMVAR.EQ.NRHODB.OR.NAMVAR.EQ.NGERHOTD
     1  .OR. NAMVAR.EQ.NRHODGE .OR. NAMVAR.EQ.NRHOCR)
        CALL  SRHOTD
      OR IF(NAMVAR.EQ.NRHOCD)
        CALL  SRHOTD
C------------------------------------------------ THETA
C** POTENTIAL TEMPERATURE    (K)
      OR IF(NAMVAR.EQ.NTHETA .OR.NAMVAR.EQ.NTHETAK )
         CALL STHETA
C------------------------------------------------ TEO3C
C** CORRECTED OZONE CONCENTRATION  (PPB)
      OR IF(NAMVAR   .EQ.NTEO3C )
         CALL STEO3C
C------------------------------------------------ P210M
C** PRESSURE AT 210 M LEVEL (MB)
C     OR IF(NAMVAR.EQ.NP210M    )
C       CALL SP210M
C------------------------------------------------ PD
C** POWER DENSITY (WATTS/IN2)               PD
C     OR IF(NAMVAR   .EQ.NPD )
C       CALL SPD
C------------------------------------------------ ATK3
C** RADOME ATTACK         (MB)
C     OR IF(NAMVAR .EQ.NATK3  )
C       CALL SATK3
C------------------------------------------------ AVOLF
C** CORRECTED VOL. AEROSOL FLOW PROJ 240
C     OR IF(NAMVAR   .EQ.NAVOLF )
C        CALL SAVOLF
C------------------------------------------------ BETA3
C** RADOME SIDESLIP       (MB)
C     OR IF(NAMVAR   .EQ.NBETA3  )
C       CALL SBETA3
C-----------------------------------------------------------------------
C **  ADD LEVEL THREE NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV3
.USE  ADDV3
      ELSE
       KT3 = KT3+1
       KTSV(KT3) = K
      END IF
   39 CONTINUE
      END DO
      END IF
C***************************************************************************
C****************       LEVEL FOUR DERIVATION       ************************
C***************************************************************************
      IF(KT3.GT.0)
      DO (KT=1,KT3)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR =ICON(IND +IOFF01)
       INDGET = ICON(IND+IOFF02)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       CONS1  =  CON(IND+IOFF08)
       NUMSOU = ICON(IND+IOFF11)
       LDO    = NCDO*LRATE
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C
C***** Following moisture variables were moved to level 4 because
C       SCRYOC (Cryogenic hygrometer) is in level 3.           RLR  910618
C------------------------------------------------ MR
C** MIXING RATIO (G/KG)
      IF(NAMVAR   .EQ.NMR      )
         CALL SMR
C------------------------------------------------ SPHUM
C** SPECIFIC  HUMIDITY  (G/KG)
      OR IF(NAMVAR   .EQ.NSPHUM  )
         CALL SSPHUM
C------------------------------------------------ RHUM
C** RELATIVE HUMIDITY  (PERCENT)
      OR IF(NAMVAR   .EQ.NRHUM    )
         CALL SRHUM
C------------------------------------------------ AKRD
C** RADOME ATTACK ANGLE    (DEG)
      OR IF(NAMVAR   .EQ.NAKRD  )
        CALL SAKRD
C------------------------------------------------ DLA
C** LYMAN ALPHA CALCULATION (ADDED BY CC 31AUG1987)
      OR IF(NAMVAR.EQ.NDLA .OR. NAMVAR.EQ.NDLA1)
       CALL  SDLA
C------------------------------------------------ SSRD
C** RADOME SIDESLIP ANGLE (DEG)
      OR IF(NAMVAR   .EQ.NSSRD )
        CALL SSSRD
C------------------------------------------------ QCRCC
C** CORRECTED QCRC (ED BROWN FEB.26,1985 - PROJECT 250)
C     OR IF(NAMVAR   .EQ.NQCRCC )
C       CALL SQCRCC
C------------------------------------------------ P2DFLG
C** PMS2D P-PROBE FLAG
C     OR IF(NAMVAR.EQ.NP2DFLG   )
C       CALL SP2DFLG
C------------------------------------------------ AMASS
C** CUMUL. MASS FLOW OF AEROSOL PROJ 240
C     OR IF(NAMVAR   .EQ.NAMASS )
C        CALL SAMASS
C------------------------------------------------ KRA
C** ATTACK SENSITIVITY    (MB)
C     OR IF(NAMVAR   .EQ.NKRA   )
C       CALL SKRA
C------------------------------------------------  LYMAN ALPHA STUFF
C     OR IF(NAMVAR.EQ.NLYAPX )
C      CALL  SLYAPX
C     OR IF(NAMVAR.EQ.NLYAP1 )
C      CALL  SLYAP1
C-----------------------------------------------------------------------
C **  ADD LEVEL FOUR NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV4
.USE  ADDV4
C---------------------------
      ELSE
       KT4 = KT4+1
       KTSV(KT4) = K
      END IF
      END DO
      END IF
C***************************************************************************
C****************       LEVEL FIVE DERIVATION          *********************
C***************************************************************************
      IF(KT4.GT.0)
      DO (KT=1,KT4)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR =ICON(IND +IOFF01)
       INDGET = ICON(IND+IOFF02)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       CONS1  =  CON(IND+IOFF08)
       NUMSOU = ICON(IND+IOFF11)
       LDO    = NCDO*LRATE
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------------ GUSTO
C**  G U S T O
C
   51 FORMAT(' CALIB:GUST RATE=',I2,'GEN. INPUT VAR. NO.',I2,' RATE=',
     1I2,' (1-ALT,2-ALPHA,3-XVI,4-YVI,5-PH,6-ROLL,7-VZI,8-HP)',
     2' WARNING: SGUST NOT CALLED')
   52 FORMAT(' CALIB:GUST GEN. INPUT VAR. NO.',I2,' NOT ON THE GEN.',
     1' CONTROL LIST (1-ALT,2-ALPHA,3-XVI,4-YVI,5-PH,6-ROLL,7-VZI,8-HP)'
     2,' WARNING: SGUST NOT CALLED')
      IF(NAMVAR.EQ.NGUSTO )
       DO(IG=1,8)
        IF(LRATE.NE.LRGUST(IG))
         IF(NSTAGE.EQ.4)
          WRITE(KPROC,51) LRATE,IG,LRGUST(IG)
         END IF
.USE  D99999
         GO TO 59
        END IF
        IF(IPGUST(IG).LE.0)
         IF(NSTAGE.EQ.4)
          WRITE(KPROC,52) IG
         END IF
.USE  D99999
         GO TO 59
        END IF
       END DO
       CALL SGUST
C------------------------------------------------ GUSTR
C**  G U S T O  R A D O M E
C
   53 FORMAT(' CALIB:GUSTR RATE=',I2,'GEN. INPUT VAR. NO.',I2,' RATE=',
     1I2,' (1-ALT,2-ALPHA,3-XVI,4-YVI,5-PH,6-ROLL,7-VZI,8-HP)',
     2' WARNING: SGUSTR NOT CALLED')
   54 FORMAT(' CALIB:GUSTR GEN. INPUT VAR. NO.',I2,' NOT ON THE GEN.',
     1' CONTROL LIST (1-ALT,2-ALPHA,3-XVI,4-YVI,5-PH,6-ROLL,7-VZI,8-HP)'
     2,' WARNING: SGUSTR NOT CALLED')
C
      OR IF(NAMVAR.EQ.NGUSTR .OR. NAMVAR.EQ.NGUSTD)
       DO(IG=1,8)
        IF(LRATE.NE.LRGUSTR(IG))
         IF(NSTAGE.EQ.4)
          WRITE(KPROC,53) LRATE,IG,LRGUSTR(IG)
         END IF
.USE  D99999
         GO TO 59
        END IF
        IF(IRGUST(IG).LE.0)
         IF(NSTAGE.EQ.4)
          WRITE(KPROC,54) IG
         END IF
.USE  D99999
         GO TO 59
        END IF
       END DO
       CALL SGUST
C
C***** Following moisture variables were moved to level 5 because
C       some source variables are in level 4.                     RLR  910618
C------------------------------------------------ THETAE
C*******       EQUIVALENT POTENTIAL TEMPERATURE (K)
      OR IF(NAMVAR   .EQ. NTHETAE   )
       CALL  STHETAE
C------------------------------------------------ THETAV
C** VIRTUAL POTENTIAL TEMPERATURE
      OR IF(NAMVAR.EQ.NTHETAV    )
        CALL STHETAV
C------------------------------------------------ PLCL
C** PRESSURE AT LCL
      OR IF(NAMVAR .EQ. NPLCL     )
       CALL  SPLCL
C------------------------------------------------ TLCL
C** TEMPERATURE AT LCL
      OR IF(NAMVAR .EQ. NTLCL     )
       CALL  STLCL
C------------------------------------------------ TVIR
C** VIRTUAL TEMPERATURE     (K)
      OR IF (NAMVAR .EQ. NTVIR)
       CALL STVIR
C------------------------------------------------ QMR
C** TOTAL MIXING RATIO
C     OR IF(NAMVAR.EQ.NQMR      )
C       CALL SQMR
C------------------------------------------------ ETHETAK
C** ETHETA FOR KERRY EMANUAL FOR PROJECT 813
C     OR IF(NAMVAR   .EQ.NETHETAK)
C        CALL SETHETAK
C------------------------------------------------ CVI
C******                  CVI
      OR IF(NAMVAR .EQ. NCVI)
       CALL SCVI
C------------------------------------------------ BRE
C******  REYNOLDS NUMBER COEFFICIENT
C     OR IF(NAMVAR .EQ. NBRE )
C      CALL SBRE
C------------------------------------------------ THETAQ
C*******  WET  EQUIVALENT POTENTIAL TEMPERATURE (K)
C     OR IF(NAMVAR   .EQ. NTHETAQ   )
C      CALL  STHETAQ
C------------------------------------------------ RE
C******  REYNOLDS NUMBER
C     OR IF(NAMVAR .EQ. NRE )
C      CALL SRE
C-----------------------------------------------------------------------
C **  ADD LEVEL FIVE NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV5
.USE  ADDV5
C-----------------------------------------------------------------------------
      ELSE
       KT5 = KT5+1
       KTSV(KT5) = K
      END IF
      END DO
   59 CONTINUE
      END IF
C***************************************************************************
C****************       LEVEL SIX DERIVATION        ************************
C***************************************************************************
C** CALL FRAME HERE FOR DATA BLOCK PRINTING ON MICROFILM BEFORE PLOTS
C   PMS HISTOGRAMS
      IF(NSTAGE.EQ.4) CALL FRAME
      IF(KT5.GT.0)
      DO (KT=1,KT5)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR =ICON(IND +IOFF01)
C----------------------------------------------------
C** KEYWD -- DF -- A 2-CHARACTER KEY WORD FOR DIFFERENCE/SUM  OF ANY
C                  TWO VARIABLES
C
       ENCODE(2,13,KEYWD) NAMVAR
   13 FORMAT(A2)
C-------------------------------------------------
       INDGET = ICON(IND+IOFF02)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       CONS1  =  CON(IND+IOFF08)
       NUMSOU = ICON(IND+IOFF11)
       LDO    = NCDO*LRATE
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------------ DFXXXXXX
C** DIFFERENCE OF ANY TWO VARIABLES
      IF(KEYWD .EQ.NDIF   )
       CALL  SDIF
C----------------------------------------------- NETT
      OR IF(NAMVAR .EQ. NNETT      )
        CALL SSUM2
C----------------------------------------------- NETV                   ------
C***** NET VISIBLE IRRADIANCES (POSITIVE INWARD)  ( W/M2)
      OR IF(NAMVAR .EQ. NNETV      )
         CALL SDIF
C----------------------------------------------- NETI                   ------
C***** NET INFRARED IRRADIANCES (POSITIVE INWARD) (W/M2)
      OR IF(NAMVAR .EQ. NNETI      )
         CALL SDIF
C------------------------------------------------ SMXXXXX
C** THE SUM OF ANY TWO VARIABLES
      OR IF(KEYWD .EQ.NSUM  )
       CALL  SSUM2
C------------------------------------------------ RZXXXXX
C** THE RATIO OF ANY TWO VARIABLES
      OR IF(KEYWD .EQ.NRATIO)
       CALL  SRATIO
C------------------------------------------------ TRKI
      OR IF(NAMVAR.EQ.NTRKI      )
         CALL STRKI
C----------------------------------  PMS-1D BLOCKS  ------
C------------------------------------------------ ASASP
      OR IF(NAMVAR.EQ.NASAS)
         CALL SASAS
C------------------------------------------------ FSSP
      OR IF(NAMVAR.EQ.NFSSP  )
         CALL SFSSP
C------------------------------------------------ X200
      OR IF(NAMVAR.EQ.NX200         )
         CALL SX200
C------------------------------------------------ X260
      OR IF(NAMVAR.EQ.NX260         )
         CALL SX260
C------------------------------------------------ Y200
      OR IF(NAMVAR.EQ.NY200         )
         CALL SY200
C-----------------------------------------------------------------------
C **  ADD LEVEL SIX NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV6
.USE  ADDV6
C-----------------------------------------------------------------------
      ELSE
       KT6= KT6+1
       KTSV(KT6)= K
      END IF
      END DO
      END IF
C***************************************************************************
C****************       LEVEL SEVEN DERIVATION      ************************
C***************************************************************************
      IF(KT6.GT.0)
      DO (KT=1,KT6)
       K= KTSV(KT)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR   =ICON(IND +IOFF01)
       INDGET   = ICON(IND+IOFF02)
       INDPUT   = ICON(IND+IOFF04)
       LRATE    = ICON(IND+IOFF05)
       CONS1   = CON(IND+IOFF08)
       LDO= LRATE * NCDO
       DO (N=1,MAXSOU)
        LRTSOU(N) = 1
        IPSOU(N) = 0
       END DO
       NUMSOU = ICON(IND+IOFF11)
       DO(J=1,NUMSOU)
        INDD= IND+IOFF12+(J-1)
        KSOU= ICON(INDD)
        INDS = INDVAL + LENCON *(KSOU-1)
        LRTSOU(J) = ICON  (INDS + IOFF05)
        IPSOU(J ) = ICON(INDS + IOFF04)
       END DO
C------------------------------------------------ DA
      IF(NAMVAR.EQ.NDA       )
         CALL SDA
C------------------------------------------------ LWCCZ
      OR IF(NAMVAR.EQ.NLWCCZ    )
          CALL SLWCCZ
C------------------------------------------------ PLWCCZ
      OR IF(NAMVAR.EQ.NPLWCCZ    )
          CALL SPLWCCZ
C------------------------------------------------ LWCCF
      OR IF(NAMVAR.EQ.NLWCCF    )
          CALL SLWCCF
C------------------------------------------------ PLWCCF
      OR IF(NAMVAR.EQ.NPLWCCF    )
          CALL SPLWCCF
C------------------------------------------------ DINSLR
C** DISTANCE BETWEEN INS AND LORANC POSITION
C     OR IF(NAMVAR.EQ.NDINSLR)
C       CALL  SDINSLR
C-----------------------------------------------------------------------
C **  ADD LEVEL SEVEN NEW DERIVED VARIABLE IN SAVE BLOCK: ADDV7
.USE  ADDV7
C-----------------------------------------------------------------------
      ELSE
       KT7= KT7+1
       KTSV(KT7)= K
      END IF
      END DO
      END IF
      KTEND=KT7
C-----------------------------------------------------------------------
C **  ADD A NEW LEVEL FOR DERIVED VARIABLE IN SAVE BLOCK: ADDV8
.USE  ADDV8
C********************************************************************
C*****************   VARIABLES NOT FOUND IN THIS SUBROUTINE  ********
C********************************************************************
      IF(KTEND.GT.0)
       DO (KT=1,KTEND)
        K= KTSV(KT)
        IND = INDVAL+LENCON*(K-1)
        NAMVAR =ICON(IND +IOFF01)
        LRATE    = ICON(IND+IOFF05)
        IF(NSTAGE.EQ.4)WRITE(KPROC,89) NAMVAR
   89   FORMAT(' CALIB WARNING: ',A8, ' NOT FOUND IN DATA STMT NAME',   E '
     $  ' LIST. VALUES OF 99999. ARE STORED AT LRATE')
        LDO= NCDO*LRATE
        INDPUT   = ICON(IND+IOFF04)
.USE  D99999
       END DO
      END IF
      RETURN
      END
C***********************************************************************
      SUBROUTINE SMOVE
C***********************************************************   MOVE
C** MOVE DATA FROM DATA(INDGET) TO DATA(INDPUT) WITH A BIAS/OFFSET
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  TOP
.USE  OP
.USE  ERROR
.NOREP
      INDGET = INDGET -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
        DATA(INDPUT+IX) = DATA(INDGET+IX) + CONS1
      END DO
      RETURN
      END
C-----------------------------------------------------------------------        
C SEWIC CORRECTION PER R. RUTH'S MEMO                       29MAY1990           
C STHETAE/SEWIC REPLACE "*10E-" WITH "E-"                   16SEP1988           
C STAX,SPSXC,STASX OFFSET=CONVERT (CINDE PROJECT REPROCESS) 23AUG1988           
C TLCL CALCULATION CONSTANT FIXED (CHANGED FROM 3.4 TO 3.5) 06JUN1988           
C-----------------------------------------------------------------------        
C SQCXC,SPSXC ADDED                                   02OCT1987                 
C-----------------------------------------------------------------------        
C QCDC ADDED TO SQCXC (PCOR8-858 DIFF PROBE)          04SEP1987                 
C-----------------------------------------------------------------------        
C SATX - MODS FOR TAKING REC. FACTOR FUNCTION         09MAR1987                 
C-----------------------------------------------------------------------        
C  THIS FILE CONTAINS THE FOLLOWING GENERAL DERIVATION CALIBRATION SUBS:        
C--------------------------------------------------------------------------     
C SUB NAME| REQUIRED VARIABLES    -NO|CONSTANT| DERIVED VARIABLES               
C-----------------------------------------------------------------------        
C SABFIX  |ABFIX;QCXC               2|BIAS    |AKFXL,AKFXR,SSFXT,SSFXB  IX      
C--------------------------------------------------------------------------     
C SATKSLP |ABDIF;QCXC;PSXC;QCX      4|BIAS    |AKDF,SSDF                        
C--------------------------------------------------------------------------     
C SATRF   |TTRX;QCXC;PSXC           3|RECFR   |ATRF                             
C--------------------------------------------------------------------------     
C SATX    |TTX;QCXC;PSXC            3|RECFR   |ATB,ATF,ATKP,ATW                 
C--------------------------------------------------------------------------     
C SATXH   |TTXH;QCXC;PSXC2          3|RECFR   |ATBH,ATFH,ATWH                   
C--------------------------------------------------------------------------     
C SDIF    |VAR1;VAR2                2|        |DIFFERENCE OF 2 VARS             
C--------------------------------------------------------------------------     
C SDPC    |DPX                      1|        |DPC,DPBC,DPTC,GEDPC              
C--------------------------------------------------------------------------     
C SGSF    |XVI;YVI                  2|        |GSF                              
C--------------------------------------------------------------------------     
C SGUSTO  |THI;TASX;TASG;ATK;SSLP   5|BMLENTH |GUSTO VARS.                      
C--------------------------------------------------------------------------     
C SIRTBC  |DDTB;STTB;IRTB           3|XKTB    |IRTC,IRBC                        
C--------------------------------------------------------------------------     
C SLWCC   |LWC;TASX                 2|REFJW   |LWCC                             
C--------------------------------------------------------------------------     
C SMR     |DPXC;PSXC                2|        |MR                               
C--------------------------------------------------------------------------     
C SPALT   |PSXC                     1|ASTG    |PALT                             
C--------------------------------------------------------------------------     
C SPLWCC  |PLWC;ATX;PSXC;TASX       4|        |PLWCC                            
C--------------------------------------------------------------------------     
C SPSURF  |ATX;MR;PSXC;HGM          4|        |PSURF                            
C-----------------------------------------------------------------------        
C SPSXC   |PSX;QCX                  2|        |PSFC,PSWC,PSBC,PSFDC             
C--------------------------------------------------------------------------     
C SQCXC   |QCX                      1|        |QCDX,QCFC,QCWC,QCGC,QCBC         
C--------------------------------------------------------------------------     
C SRHOTD  |DPXC;ATX;PSXC            3|        |RHOD,RHODT,RHODB,RHODGE          
C--------------------------------------------------------------------------     
C SRHUM   |DPXC;ATX;PSXC            3|        |RHUM                             
C--------------------------------------------------------------------------     
C SSPHUM  |DPXC;PSXC                2|        |SPHUM                            
C--------------------------------------------------------------------------     
C STASX   |TTX;QCXC;PSXC            3|RECFA   |TASB,TASF,TASG,TASW              
C--------------------------------------------------------------------------     
C STHETA  |ATX;PSXC                 2|        |THETA                            
C--------------------------------------------------------------------------     
C STHETAE |DPC;ATX;PSXC;RM          4|        |THETAE                           
C--------------------------------------------------------------------------     
C STHETAV |ATX;MR;PSXC              3|        |THETAV                           
C--------------------------------------------------------------------------     
C STVIR   |ATX;MR                   1|        |TVIR                             
C--------------------------------------------------------------------------     
      SUBROUTINE SABFIX                                                         
C**********************************************************  SABFIX             
C** ATTACK ANGLE / SIDE SLIP (FIXED VANE)  (DEG)                                
C** REQUIRES --- 1-ABFIX;2-QCXC                                                 
C                                                                               
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
.USE  FHSSATK                                                                   
.USE  WHSSATK                                                                   
      IPFIX = IPSOU(1) - 1                                                      
      IPQCXC = IPSOU(2) - 1                                                     
      INDPUT = INDPUT - 1                                                       
      BIAS = CONS1                                                              
      DO (IX = 1 , LDO)                                                         
        FIX = DATA(IPFIX + IX)                                                  
        QCXC = DATA(IPQCXC + IX)                                                
        IF(FIX.EQ.99999. .OR. QCXC.EQ.99999.)                                   
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        FIX = HSSATK(FIX,QCXC)                                                  
        IF(ABS(FIX).GT.20.) FIX = SIGN(20.,FIX)                                 
C HOLD ATTACK AND SIDESLIP ANGLES TO ZERO BEFORE TAKEOFF                        
        IF(QCXC.LT. 10.) FIX = 0.                                               
        IF(BIAS.EQ.99999.) BIAS = 0.                                            
        ABFIX = FIX + BIAS                                                      
        DATA(INDPUT+IX) = ABFIX                                                 
   99  CONTINUE                                                                 
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SATRF                                                          
C**********************************************************  SATRF              
C** AMBIENT TEMPERATURE (REVERSE FLOW)(C)                                       
C** REQUIRES:1-TTRF;2-QCXC;3-PSXC                                               
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
      DATA NCONSN/8HFUNCTION/                                                   
.USE  FRECFRN                                                                   
      IPTTRF = IPSOU(1)-1                                                       
      IPQCXC = IPSOU(2)-1                                                       
      IPPSXC = IPSOU(3)-1                                                       
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
        TTRF = DATA(IPTTRF   +IX)                                               
        PSXC = DATA(IPPSXC   +IX)                                               
        QCXC = DATA(IPQCXC +IX)                                                 
        IF(TTRF.EQ.99999. .OR. QCXC.EQ.99999. .OR. PSXC.EQ.99999.)              
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        XMACH2 = 5.*((QCXC /PSXC+1.)**.28571-1.)                                
        IF(CONSN .EQ. NCONSN)                                                   
.USE  WRECFRN                                                                   
         ATRF= (TTRF + 273.16)/(1.0 + 0.2*RECFRN(QCXC)*XMACH2) - 273.16         
        ELSE                                                                    
         IF(CONS1.EQ.99999.)                                                    
          PRINT 88,NAMVAR,CONS1                                                 
   88     FORMAT(' WARNING: SATRF- ',A8,' REQUIRES A RECOVERY FACTOR',          
     1    ' BUT NOT ',F9.2)                                                     
         END IF                                                                 
         ATRF= (TTRF + 273.16)/(1.0 + 0.2*CONS1*XMACH2) - 273.16                
        END IF                                                                  
        DATA(INDPUT+IX) = ATRF                                                  
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SATX                                                           
C***********************************************************  SATX              
C** AMBIENT TEMPERATURE (BOOM,FUSELAGE,FAST RESPONSE,WING) (C)                  
C** REQUIRES:1-TTX;2-QCXC;3-PSXC                                                
C** REQUIRES:RECFR                                                              
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      DATA NCONSN/8HFUNCTION/                                                   
.USE  FRECFKN                                                                   
      IPTTX =IPSOU(1  )  -1                                                     
      IPQCXC = IPSOU(2)-1                                                       
      IPPSXC = IPSOU(3) -1                                                      
      RECF = CONS1                                                              
      OFFSET=CONVERT                                                            
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
        TTX = DATA(IPTTX   +IX)                                                 
        QCXC = DATA(IPQCXC +IX)                                                 
        PSXC = DATA(IPPSXC +IX)                                                 
        IF(TTX.EQ.99999. .OR. QCXC.EQ.99999. .OR. PSXC.EQ.99999.)               
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        XMACH2 = 5.*((QCXC /PSXC+1.)**.28571-1.)                                
        IF(CONSN .EQ. NCONSN)                                                   
.USE  WRECFKN                                                                   
         ATX = (TTX + 273.16)/(1.0 + 0.2*RECFKN(QCXC)*XMACH2) - 273.16          
        ELSE                                                                    
         IF(RECF .EQ.99999.)                                                    
          PRINT 88,NAMVAR,CONS1                                                 
   88     FORMAT(' WARNING: SATX - ',A8,' REQUIRES A RECOVERY FACTOR',          
     1    ' BUT NOT ',F9.2)                                                     
         END IF                                                                 
         ATX = (TTX + 273.16)/(1.0 + 0.2*RECF*XMACH2) - 273.16                  
        END IF                                                                  
        DATA(INDPUT+IX) = ATX                                                   
C       DATA(INDPUT+IX) = ATX+OFFSET                                            
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SATXH                                                          
C***********************************************************  ATXH              
C** AMBIENT TEMPERATURE (HEATED-BOOM/WING/FUSELAGE)                             
C** REQUIRES:1-TTXH;2-QCXC;3-PSXC                                               
C** REQUIRES:RECFRH                                                             
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
      DATA NATBH/8HATBH    /,NATFH/8HATFH    /,NATWH/8HATWH    /                
.USE  FTFHERR                                                                   
.USE  WTFHERR                                                                   
      LOCSVH= LOCSAV(THISOP)-1                                                  
      IF(NAMVAR.EQ.NATBH) ATXH  = CON( LOCSVH+19)                               
      IF(NAMVAR.EQ.NATFH) ATXH  = CON( LOCSVH+20)                               
      IF(NAMVAR.EQ.NATWH) ATXH  = CON( LOCSVH+21)                               
      IPTTXH =IPSOU(1 )-1                                                       
      IPQCXC =IPSOU(2 )-1                                                       
      IPPSXC =IPSOU(3 )-1                                                       
      RECXH = CONS1                                                             
      INDPUT = INDPUT-1                                                         
      DO (IX=1,LDO)                                                             
        TTXH = DATA(IPTTXH +IX)                                                 
        PSXC = DATA(IPPSXC +IX)                                                 
        QCXC = DATA(IPQCXC +IX)                                                 
        IF(TTXH.EQ.99999. .OR. PSXC.EQ.99999. .OR. QCXC.EQ.99999.)              
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        XMACH2 = 5.*((QCXC /PSXC+1.)**.28571-1.)                                
        XMACH = SQRT(ABS(XMACH2))                                               
        IF (NSTAGE.EQ.4 .AND. IX.EQ.1) ATXH = TTXH                              
        ZEE = 0.2695890238*PSXC*XMACH/(ATXH+273.16)                             
.USE  ZLOG                                                                      
        TTXH = TTXH - ZFUN                                                      
        DATA(IPTTXH+IX) = TTXH                                                  
C** ATXH                                                                        
         IF(RECXH.EQ.99999.)                                                    
          PRINT 88,NAMVAR,CONS1                                                 
   88     FORMAT(' WARNING: SATXH- ',A8,' REQUIRES A RECOVERY FACTOR',          
     1    ' BUT NOT ',F9.2)                                                     
         END IF                                                                 
        ATXH = (TTXH + 273.16)/(1.0 + 0.2*RECXH*XMACH2) - 273.16                
        DATA(INDPUT+IX) = ATXH                                                  
   99   CONTINUE                                                                
      END DO                                                                    
      IF(NAMVAR.EQ.NATBH) CON( LOCSVH+19)= ATXH                                 
      IF(NAMVAR.EQ.NATFH) CON( LOCSVH+20)= ATXH                                 
      IF(NAMVAR.EQ.NATWH) CON( LOCSVH+21)= ATXH                                 
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SDIF                                                           
C***********************************************************  SDIF              
C** DIFFERENCE OF TWO VARIABLES                                                 
C** REQUIRES:1-VAR1;2-VAR2                                                      
.REPL                                                                           
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
      IPVARA  = IPSOU(1) - 1                                                    
      IPVARB  = IPSOU(2) - 1                                                    
      IRVARA  = LRTSOU(1)/LRATE                                                 
      IRVARB  = LRTSOU(2)/LRATE                                                 
      INDPUT  = INDPUT - 1                                                      
      DO (IX=1, LDO)                                                            
        ISKPVA = (IX-1)*IRVARA+1                                                
        ISKPVB = (IX-1)*IRVARB+1                                                
        VARA  = DATA(IPVARA +ISKPVA)                                            
        VARB  = DATA(IPVARB +ISKPVB)                                            
        IF(VARA.EQ.99999. .OR. VARB.EQ.99999.)                                  
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        DIFVAR= VARA - VARB                                                     
        DATA(INDPUT+IX) = DIFVAR                                                
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SDPC                                                           
C***********************************************************  SDPC              
C** DEWPOINT TEMPERATURE (THERMOELEC) (C)                                       
C** REQUIRES:1-DP                                                               
C  DPCOR EQUATION COMPUTES DIFFERENCE BETWEEN DEW POINT AND FROST POINT         
C  DERIVED FROM GOFF/GRATCH VAPOR PRESSURE EQUATIONS FOR PLANE SWATER AND       
C  ICE SURFACES. FINAL CORRECTED DEW POINT (DPC) IS WITH RESPECT TO A PLANE     
C  SWATER SURFACE.  THE ACCURACY OF CONVERSION (ONE SSIGMA) IS 0.02C OVER       
C  RANGE OF 0C TO -80 C.                                                        
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      IPDP =IPSOU(1  )  -1                                                      
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
        DP = DATA(IPDP   +IX)                                                   
        IF(DP.EQ.99999. )                                                       
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        DPC = DP                                                                
        IF (DP.LT.0.) DPC = 0.009109+DP*(1.134055+DP*0.001038)                  
        DATA(INDPUT+IX) = DPC                                                   
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SGSF                                                           
C***********************************************************  SGSF              
C** INS GROUND SPEED (PLATFORM COORDINATES) (M/S)                               
C** REQUIRES:1-XVI;2-YVI                                                        
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      IPXVI =IPSOU(1  ) -1                                                      
      IPYVI =IPSOU(2  ) -1                                                      
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
        XVI= DATA(IPXVI +IX)                                                    
        YVI= DATA(IPYVI +IX)                                                    
        IF(XVI.EQ.99999. .OR. YVI.EQ.99999.)                                    
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        DATA(INDPUT+IX) = SQRT (XVI*XVI + YVI*YVI)                              
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
C                                                                               
      SUBROUTINE SIRTBC                                                         
C**********************************************************  SPYRGC             
C** CORRECTED TOP/BOTTOM PYRGEOMTER IRRADIANCE (WATTS/M2)                       
C** REQUIRES:1-TBPGDT;2-TBPGST;3-TBPYRG                                         
C            1-TDT;2-TST;3-IRT / 1-BDT;2-BST;3-IRB                              
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
      DATA E0/0.986/, SBC/5.6686E-8/                                            
      XKTB = CONS1                                                              
      IPPGDT = IPSOU(1) - 1                                                     
      IPPGST = IPSOU(2) - 1                                                     
      IPPYRG= IPSOU(3)-1                                                        
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        PGDT=DATA(IPPGDT+IX)                                                    
        PGST=DATA(IPPGST+ IX)                                                   
        PYRG = DATA(IPPYRG+IX)                                                  
        IF(PGDT.EQ.99999. .OR. PGST.EQ.99999. .OR. PYRG.EQ.99999.)              
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
         IF(XKTB .EQ.99999.)                                                    
          PRINT 88,NAMVAR,CONS1                                                 
   88     FORMAT(' WARNING: SPYRGC ',A8,' REQUIRES CONSTANT XK,  ',             
     1    ' BUT NOT ',F9.2)                                                     
         END IF                                                                 
        DSCOR = XKTB*SBC*((PGDT +273.16)**4 - (PGST +273.16)**4)                
        TCOR = E0*SBC*((PGST +273.16)**4)                                       
        PYRGC = PYRG - DSCOR + TCOR                                             
        DATA(INDPUT + IX) = PYRGC                                               
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SLWCC                                                          
C***********************************************************  SLWCC             
C** CORRECTED J-W LIQUID WATER CONTENT (G/M3)                                   
C** REQUIRES:1-LWC;2-TASX                                                       
C** REQUIRES:REFJW                                                              
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2                                       
      IPLWC = IPSOU(1) - 1                                                      
      IPTAS = IPSOU(2) -1                                                       
      IRQC1 = LRTQC1/LRATE                                                      
      REFJW = CONS1                                                             
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        XLWC= DATA(IPLWC + IX)                                                  
        IQC1= (IX-1)*IRQC1                                                      
        QC1 = DATA(IPQC1+IQC1)                                                  
        TASX= DATA(IPTAS + IX)                                                  
        IF(XLWC.EQ.99999. .OR. TASX.EQ.99999.)                                  
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        IF(TASX.EQ.0.0) TASX=0.001                                              
        XLWCC = XLWC*REFJW*0.44704/TASX                                         
        IF(QC1 .LT. 10.)  XLWCC = XLWC                                          
        IF(XLWCC .GT. 10.0 .OR. XLWCC.LT. -10.0) XLWCC = 0.0                    
        DATA(INDPUT+IX) = XLWCC                                                 
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SMR                                                            
C************************************************************** SMR             
C** MIXING RATIO (G/KG)                                                         
C** REQUIRES:1-DPXC;2-PSXC                                                      
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
.USE  FESUBT                                                                    
      IPDPC = IPSOU(1) - 1                                                      
      IPPSXC = IPSOU(2) - 1                                                     
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        DPC = DATA(IPDPC + IX)                                                  
        PSXC = DATA(IPPSXC + IX)                                                
        IF(DPC.EQ.99999. .OR. PSXC.EQ.99999. )                                  
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C       EDPCO= ESUBT(DPC)                                                       
        CALL SEWIC(DPC,PSXC,EDPC)                                               
C       IF(NSTAGE.EQ.4) PRINT 39,IX,DPC,PSXC,EDPCO,EDPC                         
   39   FORMAT(' IX,DPC,PSXC,EDPCO,EDPC ',I4,4F9.3)                             
        RM = 622.0 * EDPC / (PSXC - EDPC)                                       
        DATA(INDPUT + IX) = RM                                                  
   99   CONTINUE                                                                
       END DO                                                                   
       RETURN                                                                   
       END                                                                      
C                                                                               
C                                                                               
C                                                                               
      SUBROUTINE SPSURF                                                         
C***********************************************************  SPSURF            
C** SURFACE PRESSURE (MB)                                                       
C** REQUIRES:1-ATX;2-RM;3-PSXC;4-HGM                                            
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      IPATX = IPSOU(1) - 1                                                      
      IPRM = IPSOU(2) - 1                                                       
      IPPSXC = IPSOU(3) - 1                                                     
      IPHGM  = IPSOU(4) -1                                                      
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        ATX = DATA(IPATX + IX)                                                  
        PSXC = DATA(IPPSXC + IX)                                                
        RM = DATA(IPRM +IX)                                                     
        HGM= DATA(IPHGM+IX)                                                     
        IF(ATX.EQ.99999. .OR. PSXC.EQ.99999. .OR. RM.EQ.99999.                  
     1     .OR. HGM.EQ.99999.)                                                  
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C       TVIR = (ATX+273.16)/(1.0-.6E-3 *RM)                                     
C** TVIR HERE SHOULD BE IN DEG K   (JUN 12, 1985)                               
        TVIR = (ATX+273.16)*((1.+1.6078E-3*RM)/(1.+.001*RM))                    
        TBARM = TVIR + 0.5 *(HGM*.0098)                                         
        SURFP = PSXC* EXP((HGM/TBARM)*.0341833194)                              
        IF( HGM .GT.750) SURFP =1000.                                           
        DATA(INDPUT+IX) = SURFP                                                 
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SPSXC                                                          
C***********************************************************  SPSXC             
C** CORRECTED STATIC PRESSURE (FUSELAGE,FUSELAGE DIGITAL,WING) (MB)             
C** REQUIRES:1-PSX;2-QCX                                                        
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      DATA NPSWC/8HPSWC    /,NPSFDC/8HPSFDC   /,NPSBC/8HPSBC    /               
      DATA NPSFC/8HPSFC    /                                                    
.USE  FPCOR                                                                     
.USE  WPCOR                                                                     
      IPPSX =IPSOU(1  ) -1                                                      
      IPQCX  =IPSOU(2  ) -1                                                     
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
       PSX   = DATA(IPPSX   +IX)                                                
       QCX   = DATA(IPQCX   +IX)                                                
       IF(PSX.EQ.99999. .OR. QCX.EQ.99999. )                                    
        DATA(INDPUT+IX) =99999.                                                 
        GO TO 99                                                                
       END IF                                                                   
       IF(NAMVAR.EQ.NPSWC.OR.NAMVAR.EQ.NPSFC) PSXC= PSX + PCORW(QCX)            
       IF(NAMVAR.EQ.NPSBC) PSXC= PSX + PCORG(QCX)                               
       IF(NAMVAR.EQ.NPSFDC) PSXC= PSX + PCORD(QCX)                              
       IF( QCX .LT. 10.)PSXC=PSX                                                
       IF (PSXC .LT.50.)PSXC = 50.                                              
       DATA(INDPUT+IX)=PSXC                                                     
C      DATA(INDPUT+IX)=PSXC+CONVERT                                             
   99 CONTINUE                                                                  
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
                                                                                
      SUBROUTINE SQCXC                                                          
C***********************************************************  SQCXC             
C** CORRECTED DYNAMIC PRESSURE (FUSELAGE/WING) (MB)                             
C** REQUIRES:1-QCX                                                              
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      DATA NQCWC/4HQCWC/,NQCFC/4HQCFC/,NQCGC/4HQCGC/,NQCBC/4HQCBC/              
      DATA NQCDC/4HQCDC/                                                        
.USE  FPCOR                                                                     
.USE  WPCOR                                                                     
      IPQCX =IPSOU(1  ) -1                                                      
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
       QCX= DATA(IPQCX +IX)                                                     
       IF(QCX.EQ.99999.)                                                        
        DATA(INDPUT+IX) =99999.                                                 
        GO TO 99                                                                
       END IF                                                                   
       IF(NAMVAR.EQ.NQCWC.OR.NAMVAR.EQ.NQCFC) QCXC= QCX- PCORW(QCX)             
       IF(NAMVAR.EQ.NQCBC) QCXC= QCX - PCORG(QCX)                               
       IF(NAMVAR.EQ.NQCGC) QCXC= QCX - PCORG(QCX)                               
C      IF(NAMVAR.EQ.NQCDC) QCXC= QCX - PCOR8(QCX)   
       IF(QCXC.LT.10. )  QCXC = QCX                                             
       IF(QCXC.LT.0.001) QCXC = 0.001                                           
       DATA(INDPUT+IX) = QCXC                                                   
   99  CONTINUE                                                                 
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SRHOTD                                                         
C***********************************************************  SRHOTD            
C** ABSOLUTE HUMIDITY (THERMOELEC) (G/M3)                                       
C   ALL MOISTURE VARIABLES ARE COMPUTED WITH RESPECT TO A PLANE WATER           
C   SURFACE.                                                                    
C** REQUIRES:1-DPC;2-ATX;3-PSXC                                                 
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
.USE  FESUBT                                                                    
      IPDPC  =IPSOU(1  ) -1                                                     
      IPATX  =IPSOU(2  ) -1                                                     
      IPPSXC =IPSOU(3)  -1                                                      
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
        DPC = DATA(IPDPC   +IX)                                                 
        ATX  = DATA(IPATX    +IX)                                               
        PSXC = DATA(IPPSXC + IX)                                                
        IF(DPC.EQ.99999. .OR. ATX .EQ.99999. .OR. PSXC.EQ.99999.)               
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C       EDPCO= ESUBT(DPC)                                                       
        CALL SEWIC(DPC,PSXC,EDPC)                                               
C        IF(NSTAGE.EQ.4) PRINT 39,IX,DPC,PSXC,EDPCO,EDPC    
   39   FORMAT(' IX,DPC,PSXC,EDPCO,EDPC ',I4,4F9.3)                             
        ATXK = ATX + 273.16                                                     
        IF(ATXK.EQ.0.0) ATXK = 0.001                                            
        RHOTD = 216.68*EDPC/ ATXK                                               
        DATA(INDPUT+IX) = RHOTD                                                 
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SRHUM                                                          
C**********************************************************  SRHUM              
C** RELATIVE HUMIDITY  (PERCENT)                                                
C** REQUIRES:1-DPXC;2-ATX;3-PSXC                                                
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
.USE  FESUBT                                                                    
      IPDPC = IPSOU(1) - 1                                                      
      IPATX =  IPSOU(2) - 1                                                     
      IPPSXC= IPSOU(3) -1                                                       
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        DPC = DATA(IPDPC + IX)                                                  
        ATX  = DATA(IPATX  + IX)                                                
        PSXC = DATA(IPPSXC +IX)                                                 
        IF(DPC.EQ.99999. .OR. ATX.EQ.99999. .OR. PSXC.EQ.99999.)                
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C       EDPCO= ESUBT(DPC)                                                       
C       EATXO= ESUBT(ATX)                                                       
        CALL SEWIC(DPC,PSXC,EDPC)                                               
        CALL SEWIC(ATX,PSXC,EATX)                                               
C       IF(NSTAGE.EQ.4) PRINT 39,IX,DPC,PSXC,EDPCO,EDPC                         
   39   FORMAT(' IX,DPC,PSXC,EDPCO,EDPC ',I4,4F9.3)                             
C       IF(NSTAGE.EQ.4) PRINT 49,IX,ATX,PSXC,EATXO,EATX                         
   49   FORMAT(' IX,ATX,PSXC,EATXO,EATX ',I4,4F9.3)                             
        IF(EATX.EQ.0.0) EATX = 0.0001                                           
        RHUM = 100. * EDPC/EATX                                                 
        DATA(INDPUT + IX) = RHUM                                                
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE SSPHUM                                                         
C**********************************************************  SSPHUM             
C** SPECIFIC HUMIDITY (THERMOELEC)  (G/KG)                                      
C** REQUIRES:1-DPXC;2-PSXC                                                      
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
.USE  FESUBT                                                                    
      IPDPC = IPSOU(1) - 1                                                      
      IPPSXC=  IPSOU(2) - 1                                                     
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        DPC = DATA(IPDPC + IX)                                                  
        PSXC = DATA(IPPSXC + IX)                                                
        IF(DPC.EQ.99999. .OR. PSXC.EQ.99999. )                                  
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C       EDPCO= ESUBT(DPC)                                                       
        CALL SEWIC(DPC,PSXC,EDPC)                                               
C       IF(NSTAGE.EQ.4) PRINT 39,IX,DPC,PSXC,EDPCO,EDPC                         
   39   FORMAT(' IX,DPC,PSXC,EDPCO,EDPC ',I4,4F9.3)                             
        SHUM=622.0*EDPC/(PSXC-0.378*EDPC)                                       
        DATA(INDPUT + IX) = SHUM                                                
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE STASX                                                          
C***********************************************************  STASX             
C** AIRCRAFT TRUE AIRSPEED (BOOM/FUSELAGE/GUST PROBE/WING) (M/S)                
C** REQUIRES:1-TTX;2-QCXC;3-PSXC                                                
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2                                       
      DATA NCONSN/8HFUNCTION/                                                   
.USE  FRECFRN                                                                   
.USE  WRECFRN                                                                   
      IPTTX =IPSOU(1  ) -1                                                      
      IPQCXC = IPSOU(2)-1                                                       
      IPPSXC = IPSOU(3)-1                                                       
      INDPUT = INDPUT -1                                                        
      IRQC1 = LRTQC1/LRATE                                                      
      IRQC2 = LRTQC2/LRATE                                                      
      OFFSET = CONVERT                                                          
      IF(NSTAGE.EQ.4 .AND. CONS1.EQ.99999. .AND. CONSN.NE.NCONSN)               
       PRINT 1449, NAMVAR                                                       
1449   FORMAT(' STASX: REC. FACT. NOT DEFINED FOR ',A8)                         
      END IF                                                                    
      DO  (IX = 1, LDO)                                                         
        IQC1= (IX-1)*IRQC1                                                      
        QC1 = DATA(IPQC1+IQC1)                                                  
        IQC2= (IX-1)*IRQC2                                                      
        QC2 = DATA(IPQC2+IQC2)                                                  
        TTX = DATA(IPTTX   +IX)                                                 
        QCXC = DATA(IPQCXC +IX)                                                 
        PSXC = DATA(IPPSXC +IX)                                                 
        IF(TTX.EQ.99999. .OR. QCXC.EQ.99999. .OR. PSXC.EQ.99999.)               
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        IF(QCXC.LE.10. .OR. QCXC.GT.200.)QCXC = 10.0                            
        IF(PSXC.LE.50. .OR. PSXC.GT.2000.)PSXC=50.0                             
        IF(TTX .LE.-50. .OR. TTX.GT.50.) TTX = 0.0001                           
        XMACH2 = 5.*((QCXC /PSXC+1.)**.28571-1.)                                
        IF(XMACH2.EQ.0.0) XMACH2=0.000001                                       
        IF(CONSN .EQ. NCONSN)                                                   
       TAS=SQRT(ABS((TTX+273.16)*(401.86/(1./XMACH2+0.2*RECFRN(QCXC)))))        
        ELSE                                                                    
         TAS=SQRT(ABS((TTX+273.16)*(401.86/(1./XMACH2+0.2*CONS1))))             
        END IF                                                                  
        IF(QC1.LT.10. .AND. QC2.LT.10.) TAS=0.0                                 
        DATA(INDPUT+IX) = TAS                                                   
        IF(OFFSET.NE.1.) DATA(INDPUT+IX) = TAS+OFFSET
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE STHETA                                                         
C***********************************************************  STHETA            
C** POTENTIAL TEMPERATURE    (K)                                                
C** REQUIRES:1-ATX;2-PSXC                                                       
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
      IPATX = IPSOU(1) - 1                                                      
      IPPSXC = IPSOU(2) - 1                                                     
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        ATX = DATA(IPATX + IX)                                                  
        PSXC = DATA(IPPSXC + IX)                                                
        IF(ATX.EQ.99999. .OR. PSXC.EQ.99999. )                                  
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        THETA = (ATX + 273.16) * (1000./PSXC) ** 0.28571                        
        DATA(INDPUT + IX) = THETA                                               
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE STHETAV                                                        
C***********************************************************  STHETAV           
C** VIRTUAL POTENTIAL TEMPERATURE (K)                                           
C** REQUIRES:1-ATX;2-RM;3-PSXC                                                  
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
      IPATX = IPSOU(1) - 1                                                      
      IPRM = IPSOU(2) - 1                                                       
      IPPSXC = IPSOU(3) - 1                                                     
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        ATX = DATA(IPATX + IX)                                                  
        PSXC = DATA(IPPSXC + IX)                                                
        RM = DATA(IPRM +IX)                                                     
        IF(ATX.EQ.99999. .OR. PSXC.EQ.99999. .OR. RM.EQ.99999.)                 
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C       TVIR = (ATX+273.16)/(1.0-.6E-3 *RM)-273.16                              
        TVIR = (ATX+273.16)*((1.+1.6078E-3*RM)/(1.+.001*RM))-273.16             
        THETAV = (TVIR+273.16)*(1000./PSXC)**0.28571                            
        DATA(INDPUT+IX) = THETAV                                                
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE STVIR                                                          
C*********************************************************** STVIR      ******  
C** VIRTUAL TEMPERATURE (K)                                                     
C** REQUIRE:1-ATX;2-MR                                                          
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
      IPATX = IPSOU(1) - 1                                                      
      IPRM = IPSOU(2) - 1                                                       
      INDPUT = INDPUT - 1                                                       
      DO (IX = 1 , LDO)                                                         
        ATX = DATA(IPATX + IX)                                                  
        RM = DATA(IPRM +IX)                                                     
        IF(ATX.EQ.99999. .OR. RM.EQ.99999.)                                     
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        TVIR = (ATX+273.16)*((1.+1.6078E-3*RM)/(1.+.001*RM))-273.16             
        DATA(INDPUT+IX) = TVIR                                                  
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C***********************************************************************        
      SUBROUTINE SEWIC(T,P,E)                                                   
C ** CORRECTION ** CORRECTION **                                                
C ** MEMO FROM RON RUTH ON 29 MAY 1990                                          
C    THIS SUBROUTINE IS TO CALCULATE VAPOR PRESSURE ONLY WITH RESPECT           
C    TO A PLANE WATER SURFACE. SINCE THE WATER-TO-ICE CORRECTION HAS            
C    ALREADY BEEN MADE.                                                         
C **                                                                            
C ** MEMO FROM ERIK M. AND RICHARD F. SEPT.10,1985                              
C    EW - WATER VAPOR PRESSURE IN MB (GOFF-GRATCH)                              
C    TK - TEMPERATURE IN DEG K (DPC/TLCL/ATX)                                   
C    FW - ENHANCEMENT FACTORS                                                   
C    P - PRESSURE IN MB                                                         
C    E= EWC - WATER VAPOR PRESSURE FOR 'MOIST' AIR                              
C                                                                               
      TK = T + 273.16                                                           
C  Check added by RLR on 19Mar1992
      IF (TK.LT.1.0) TK = 1.0
      EW =10.**(23.832241-5.02808*ALOG10(TK)-1.3816E-7                         
     1     *(10.**(11.334-.0303998*TK))+8.1328E-3                               
     2     *(10.**(3.49149-1302.8844/TK))-2949.076/TK)                          
      FW = 1.0007+(3.46E-6 * P)                                                
      E  = FW*EW                                                               
      RETURN                                                                    
      END                                                                       
.SAVE WXGRRS
C ERIK MILLER MEMO OF 10JUN1988
C FOR 308 ELECTRA RADOME PROJECTS USES CONSTANT BKRAL IN SUB SSSRD XGR 7
      BKRAL = 0.06577
      BIAS  = .0375
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,203) NAMVAR,BKRAL,BIAS
        WRITE(KPRINT,203) NAMVAR,BKRAL,BIAS
  203 FORMAT(' CALIB: ',A8,' USES BKRAL= ',F9.4,' BIAS= ',F9.4)
        ENCODE(54,203,ARAY) NAMVAR,BKRAL,BIAS
        IY = IY-5
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,54,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
.SAVE FXGRRAB
      COMMON/PWRITE/ARAY(20),IY,IXK
.END
.SAVE WXGRRA
C ERIK MILLER MEMO OF 10JUN1988
C FOR 308 RADOME PROJECTS USE CONSTANT AKRAL FOR ATK3/BETA3 IN SQCRCXGR 7
      AKRAL = 0.0715
      ABIAS = .4095
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,303) NAMVAR,AKRAL,ABIAS
        WRITE(KPRINT,303) NAMVAR,AKRAL,ABIAS
  303 FORMAT(' CALIB: ',A8,' ATK3 AKRAL= ',F9.4,', ATK3 BIAS= ',F9.4)
        ENCODE(60,303,ARAY) NAMVAR,AKRAL,ABIAS
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,60,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
.SAVE WXGRRB
C ERIK MILLER MEMO OF 10JUN1988
C FOR 308 RADOME PROJECTS USE CONSTANT AKRAL FOR ATK3/BETA3 IN SQCRCXGR 7
      BKRAL = 0.06577
      BBIAS = .0375
      IF(NSTAGE.EQ.4 )
        WRITE(KPROC,204) NAMVAR,BKRAL,BBIAS
        WRITE(KPRINT,204) NAMVAR,BKRAL,BBIAS
  204 FORMAT(' CALIB: ',A8,' BETA3 BKRAL=',F9.4,', BETA3 BIAS= ',F9.4)
        ENCODE(61,204,ARAY) NAMVAR,BKRAL
        CALL PWRIT(CPUX(10),CPUY(IY),ARAY,61,0,0,-1)                            
        IY= IY - 15
        IXK = IXK + 1
        IF(IXK.EQ.55)
         CALL FRAME
         IY= 1000
         IXK=0
        END IF
      END IF
.END
C*********************************************************************
C MODS TO SQCRC PUT IN ON 11/13/89 (A. SCHANOT'S MEMO)
C*********************************************************************
C-----------------------------------------------------------------------
C  THIS FILE CONTAINS THE FOLLOWING ELECTRA 308 RADOME CALIBRATION SUBS:
C--------------------------------------------------------------------------
C SUB NAME| REQUIRED VARIABLES    -NO|CONSTANT| DERIVED VARIABLES
C--------------------------------------------------------------------------
C SAKRD   |ADIFR;QCRC               2|        |AKRD
C--------------------------------------------------------------------------
C SATK3   |ADIFR;QCR                2|        |ATK3
C--------------------------------------------------------------------------
C SBETA3  |BDIFR;QCR                2|        |BETA3
C--------------------------------------------------------------------------
C SPSXC   |PSX;QCR                  2|        |PSFDC
C--------------------------------------------------------------------------
C SQCR    |PTR;PSXC                 2|        |QCR
C--------------------------------------------------------------------------
C SQCRC   |QCR;ADIFR;BDIFR          3|        |QCRC
C--------------------------------------------------------------------------
C SQCFC   |QCF                      3|        |QCFC
C--------------------------------------------------------------------------
C SSSRD   |BDIFR;QCRC               2|        |SSRD
C--------------------------------------------------------------------------
C SSSRD1  |BDIFR;BREFR;BREFL        2|        |SSRD1
C--------------------------------------------------------------------------
      SUBROUTINE SAKRD
C***********************************************************  SAKRD
C** RADOME ATTACK ANGLES (DEG) -- ELECTRA 308
C** REQUIRES:1-ADIFR;2-QCRC
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
.USE  FXGRRK
.USE  WXGRRK
      IRQC1 = LRTQC1/LRATE
      IPADIFR =IPSOU(1 ) -1
      IPQCRC  =IPSOU(2 ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       IQC1= (IX-1)*IRQC1
       QC1 = DATA(IPQC1+IQC1)
       ADIFR = DATA(IPADIFR +IX)
       QCRC = DATA(IPQCRC +IX)
       IF(ADIFR.EQ.99999. .OR. QCRC.EQ.99999.)
        DATA(INDPUT+IX) =99999.
        GO TO 99
       END IF
C PER E. MILLER'S MEMO OF JUN. 10,1988
       ATKR = ((ADIFR/QCRC)+BIAS) / AKRAL
       IF(CONS1.NE.99999.) ATKR = ATKR + CONS1
       IF(QC1.LE.10.) ATKR = 0.0
       DATA(INDPUT+IX) = ATKR
   99  CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SATK3
C***********************************************************  SATK3
C** ATTACK(3)  (RADOME)
C** REQUIRES:1-ADIFR;2-QCR
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRAB
.USE  WXGRRA
      IPDR =IPSOU(1  ) -1
      IPQR =IPSOU(2  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       ADIFR = DATA(IPDR +IX)
       QCR = DATA(IPQR +IX)
       IF(ADIFR.EQ.99999. .OR. QCR.EQ.99999. )
        DATA(INDPUT+IX) =99999.
        GO TO 99
       END IF
C  ERIK MILLER'S MEMO OF 10JUN1988
C the following calculation also appears in SR SQCRC and SR SQCFC
       ATK3 = ABS ((ADIFR/QCR) + ABIAS)/ AKRAL
       DATA(INDPUT+IX) = ATK3
   99  CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SBETA3
C**********************************************************  SBETA3
C** SIDESLIP(3)  (RADOME)   (MB)
C** REQUIRES:1-BDIFR;2-QCR
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRAB
.USE  WXGRRB
      IPBR =IPSOU(1  ) -1
      IPQR =IPSOU(2  ) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       BDIFR = DATA(IPBR +IX)
       QCR = DATA(IPQR +IX)
       IF(BDIFR.EQ.99999. .OR. QCR.EQ.99999. )
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
C  ERIK MILLER'S MEMO OF 10JUN1988
C the following calculation also appears in SR SQCRC and SR SQCFC
        BETA3 = ABS (( BDIFR/QCR) + BBIAS)/ BKRAL
        DATA(INDPUT+IX) = BETA3
   99   CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SSSRD
C***********************************************************  SSRD
C** RADOME SIDESLIP ANGLE (DEG) --  ELECTRA 308
C** REQUIRES:1-BDIFR;2-QCRC
C
C  ERIK MILLER'S MEMO OF 10JUN1988
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
.USE  FXGRRS
.USE  WXGRRS
      IRQC1 = LRTQC1/LRATE
      IPBR =  IPSOU(1) -1
      IPQCRC= IPSOU(2) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       IQC1= (IX-1)*IRQC1
       QC1 = DATA(IPQC1+IQC1)
       BDIFR = DATA(IPBR +IX)
       QCRC = DATA(IPQCRC+IX)
        IF(ADIFR.EQ.99999. .OR. QCRC.EQ.99999.)
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
       SSLPR = ((BDIFR/QCRC)+BIAS)/ BKRAL
       IF(CONS1.NE.99999.) SSLPR = SSLPR + CONS1
       IF(QC1 .LE. 10.0) SSLPR = 0.0
       DATA(INDPUT+IX) = SSLPR
   99   CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SSSRD1
C***********************************************************  SSRD1
C** PROJECT 8-850 PROTOTYPE
C** RADOME SIDESLIP ANGLE (DEG) --  ELECTRA 308
C** REQUIRES:1-BDIFR;2-BREFR;3-BREFL
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  ERROR
.NOREP
.USE  FXGRRS
.USE  WXGRRS
      IPBD = IPSOU(1) -1
      IPBR = IPSOU(2) -1
      IPBL = IPSOU(3) -1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       BDIFR = DATA(IPBD +IX)
       BREFR = DATA(IPBR+IX)
       BREFL = DATA(IPBL+IX)
        IF(BDIFR.EQ.99999. .OR. BREFR.EQ.99999. .OR. BREFL.EQ.99999.)
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
C SSRD1 comes out in radians; convert to degrees after calibration
       SSLPR=0.5*ATAN(0.5543 * (BDIFR/(BREFR+BREFL)))
       SSLPR=SSLPR*180.0/3.141592654
       IF(CONS1.NE.99999.) SSLPR = SSLPR + CONS1
       DATA(INDPUT+IX) = SSLPR
   99  CONTINUE
      END DO
      RETURN
      END
C--------------------------------------------------------------------------
      SUBROUTINE SGUST
C NEW VERSION FOR HONEYWELL IRS  RLR  4NOV1991
C  Revised to use ACINS instead of IVSPD from IRS
.REPL
.USE  TBLANK
.USE  TCYCVAR
.USE  TIOUNIT
.USE  TOP
.USE  BLANK
.USE  CYCVAR
.USE  IOUNIT
.USE  OP
.USE  ERROR
.USE  CALCOM
.NOREP
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
C  Note new variable order (for GENPRO's PDUD file)
      COMMON/GUSTIN/IPLAT,IPVEW,IPVNS,IPPH,IPRL,IPVSPD,IPHP,IPACZ
C     COMMON/GUSTIN/IPLAT,IPALPH,IPXVI,IPYVI,IPPH,IPRL,IPVZI,IPHP
C     COMMON/GUSTINR/IPLAT,IPALPH,IPXVI,IPYVI,IPPH,IPRL,IPVZI,IPHP
C
      DATA RAD/.0174533/, DEG/57.29578/, PI/3.1415926536/
C
C **  THESE 3RD ORDER LOOP GAIN CONSTANTS (C1,C2,C3,C4) ARE BASED
C       ON 60-SECOND TIME CONSTANT
      DATA C1,C2,C3,C4/0.31415927,0.03289866,0.00114838,0.0/
C
C  CONSTANTS:  GWH    = GRAVITY AT WOODLAND HILLS (METERS/SEC**2)
C              OMEGAE = ANGULAR VELOCITY OF EARTH (RADIANS/SEC)
C              RE     = MEAN EARTH RADIUS (METERS)
      DATA GWH/9.7959/, OMEGAE/7.292116E-5/, RE/6.371229E06/
C
      DATA OMEGA3/0.0/
C
C  Output variable names
      DATA NUI    /8HUI      /,NUI1  /8HUI1     /
      DATA NVI    /8HVI      /,NVI1  /8HVI1     /
      DATA NWI    /8HWI      /,NWI1  /8HWI1     /
      DATA NUX    /8HUX      /,NUX1  /8HUX1     /
      DATA NVY    /8HVY      /,NVY1  /8HVY1     /
      DATA NWDIR  /8HWD      /,NWSPD /8HWS      /
C     DATA NVEW   /8HVEW     /,NVNS  /8HVNS     /
      DATA NHI3   /8HHI3     /
      DATA NWP3   /8HWP3     /
C     DATA NACINS /8HACINS   /
C
C     DATA NGUSTO /8HGUSTO   /,NGUSTR /8HGUSTR   /,NGUSTH /8HGUSTH   /
C
C--------------------------------------------------------------------
C     NGUST = NAMVAR
C
C       ACCESS THE VARIABLE CONTROLS
      INDST = 2
.USE  INDEX
C     CALL CPRINT(0,6,128,8,5,DUM,0)
      IOFF01 = ICON(INDOFF+1)
      IOFF04 = ICON(INDOFF+4)
      IOFF05 = ICON(INDOFF+5)
      IOFF08 = ICON(INDOFF+8)
      DO (K=1,NUMVEC)
        IND    = INDVAL+LENCON*(K-1)
        NAMVAR = ICON(IND+IOFF01)
        INDPUT = ICON(IND+IOFF04)
C       LRATE  = ICON(IND+IOFF05)
        CONSR  = CON(IND+IOFF08)
C  Access the variable indices
        IF(NAMVAR .EQ. NUI ) IPUI  = INDPUT
        IF(NAMVAR .EQ. NUI1) IPUI1 = INDPUT
        IF(NAMVAR .EQ. NVI ) IPVI  = INDPUT
        IF(NAMVAR .EQ. NVI1) IPVI1 = INDPUT
        IF(NAMVAR .EQ. NWI )
          IPWI = INDPUT
          IF(CONSR.EQ.99999.) CONSR = 0.0
          CONWI = CONSR
        END IF
        IF(NAMVAR .EQ. NWI1)
          IPWI1 = INDPUT
          IF(CONSR.EQ.99999.) CONSR = 0.0
          CONWI1 = CONSR
        END IF
        IF(NAMVAR.EQ.NUX )   IPUX    = INDPUT
        IF(NAMVAR.EQ.NUX1)   IPUX1   = INDPUT
        IF(NAMVAR.EQ.NVY )   IPVY    = INDPUT
        IF(NAMVAR.EQ.NVY1)   IPVY1   = INDPUT
        IF(NAMVAR.EQ.NWSPD)  IPWSPD  = INDPUT
        IF(NAMVAR.EQ.NWDIR)  IPWDIR  = INDPUT
        IF(NAMVAR.EQ.NHI3)   IPHI3   = INDPUT
        IF(NAMVAR.EQ.NWP3)   IPWP3   = INDPUT
C    (These are source variables now, not output variables)
C       IF(NAMVAR.EQ.NVEW)   IPVEW   = INDPUT
C       IF(NAMVAR.EQ.NVNS)   IPVNS   = INDPUT
C       IF(NAMVAR.EQ.NACINS) IPACINS = INDPUT
      END DO
C--------------------------------------------------------------------
C
C  ***  PICK DATA OUT OF DATA ARRAY BY USING THE SAVED INDEX FOR EACH
C  ***   VARIABLE
C
C  *** INITIALIZATION
      LOCSVG = LOCSAV(THISOP)-1
C     WRITE (6,12345) LOCSVG
C12345 FORMAT(' LOCSVG IN SGUST: ',I12)
      HX     = CON(LOCSVG+1)
      HXX    = CON(LOCSVG+2)
      WP3    = CON(LOCSVG+3)
      HI3    = CON(LOCSVG+4)
      PITCH0 = CON(LOCSVG+5)
      THF0   = CON(LOCSVG+6)
C     VZIO   = CON(LOCSVG+7)
      RATE   = LRATE
      DELT   = DELIV/RATE
C     IF(NSTAGE.EQ.4) WRITE (6,900) DELIV,RATE,DELT,LRATE
  900 FORMAT('CALIB-GUSTO: DELIV,RATE,DELT,LRATE = ',3F10.3,I4)
      IF(DELT.EQ.0.0) DELT = 1.0
      BL = CONS1
      IPTHI  = IPSOU(1)
      IPTASX = IPSOU(2)
A     IPTASG = IPSOU(3)
A     IPATK  = IPSOU(4)
A     IPSLIP = IPSOU(5)
      IRQC1  = LRTQC1/LRATE
      IRQC2  = LRTQC2/LRATE
      DO  (I = 1, LDO)
        IX = I - 1
        IQC1  = IX*IRQC1
        QC1   = DATA(IPQC1+IQC1)
        IQC2  = IX*IRQC2
        QC2   = DATA(IPQC2+IQC2)
A       ATK   = DATA(IPATK +IX)
A       SSLIP = DATA(IPSLIP+IX)
A       TASGB = DATA(IPTASG+IX)
        THI   = DATA(IPTHI +IX)
        TASX  = DATA(IPTASX+IX)
C** GENERAL INPUT VARIABLES
        ALAT  = DATA(IPLAT +IX)
        VEW   = DATA(IPVEW +IX)
        VNS   = DATA(IPVNS +IX)
        PH    = DATA(IPPH  +IX)
        RL    = DATA(IPRL  +IX)
        VSPD  = DATA(IPVSPD+IX)
        ACZ   = DATA(IPACZ +IX)
        PALT  = DATA(IPHP  +IX)
C  Following variables no longer needed (unique to Litton LTN-51)
C       ALPHA = DATA(IPALPH+IX)
C       XVI   = DATA(IPXVI +IX)
C       YVI   = DATA(IPYVI +IX)
C       VZI   = DATA(IPVZI +IX)
C       IF(NSTAGE.EQ.4 .AND. IX.LE.10) WRITE (6,800)ATK,SSLIP,TASGB,THI,
C    1  TASX,ALAT,ALPHA,PALT,PH,RL,XVI,YVI,VZI,QC1,QC2
C 800   FORMAT(' CALIB-GUSTO:ATK,SSLIP,TASGB,THI,TASX,ALAT,ALPHA,PALT,',
C    1  'PITCH,ROLL,XVI,YVI,VZI,QC1,QC2',/,15(1X,F7.1))
C--------------------------------------------------------------------
C  *** INITIALIZATION
        IF(NSTAGE.EQ. 4 .AND. I.EQ.1)
          HX     = 0.
          HXX    = 0.
          WP3    = 0.
          HI3    = PALT
          PITCH0 = PH*RAD
          THF0   = THI*RAD
C         VZIO   = VZI
        END IF
C--------------------------------------------------------------------
C  *** COORDINATE TRANSFORMATION
        PITCH  = PH*RAD
        THF    = THI*RAD
A       ROLL   = RL*RAD
A       ATTACK = ATK*RAD
A       SDSLP  = SSLIP*RAD
        CS     = COS(THF)
        CH     = COS(PITCH)
A       CR     = COS(ROLL)
A       CA     = COS(ATTACK)
A       CB     = COS(SDSLP)
        SS     = SIN(THF)
        SH     = SIN(PITCH)
A       SR     = SIN(ROLL)
A       SA     = SIN(ATTACK)
A       SB     = SIN(SDSLP)
A       A =  CB*SH
A       B = -SB*CH*SR
A       C = -CH*CR
A       D =  CB*CS*CH
C------------------------------------
C  THE FOLLOWING STATEMENTS ARE ADDED/MODIFIED AS PER DICK FRIESEN'S
C  MEMO OF SEPT 26,1984
A       TA  =  TAN(ATTACK)
A       TB  =  TAN(SDSLP)
A       DAB =  1./SQRT(1. + TA*TA + TB*TB)
A       E   = -TB*(SS*CR - CS*SH*SR)
A       H   =  TB*(CS*CR +SS*SH*SR)
C-------------------------------------
C       E   = -SB*(SS*CR-CS*SH*SR)
A       F   =  CS*SH*CR+SS*SR
A       G   =  CB*SS*CH
C       H   =  SB*(CS*CR+SS*SH*SR)
A       P   =  SS*SH*CR-CS*SR
A       AB  =  A*CA+B+C*SA
C--------------------------------------------------------------------
C *** COMPUTATION OF VERTICAL COMPONENT OF CORIOLIS ACCELERATION
C (WAS)VCORAC = -2.*OMEGAE*VEW*COS(ALAT*RAD) + (VEW*VEW + VNS*VNS)/RE
C AS OF JAN. 19, 1984
        VCORAC = 2.*OMEGAE*VEW*COS(ALAT*RAD) + (VEW*VEW + VNS*VNS)/RE
C--------------------------------------------------------------------
C *** COMPUTATION OF LOCAL GRAVITY ESTIMATE, ACZE
        GFACT = 9.780356*(1.-.31391116E-6*PALT)*(1.+.0052885*SIN(ALAT*
     &  RAD)*SIN(ALAT*RAD))
C *** Gravity in Minneapolis (based upon above equation)
C       GMINN = 9.80621770635
C       DVZ   = (VZI-VZIO)/DELT
C       ACZ   = DVZ+(GWH-GFACT)+VCORAC
        ACZE  = ACZ+(GWH-GFACT)+VCORAC
C       VZIO  = VZI
C--------------------------------------------------------------------
C *** 3RD ORDER VERTICAL VELOCITY DAMPING USING PALT AS REFERENCE
C       WP3 = WP3 + (ACZ+2.*OMEGA3*OMEGA3*HI3-C2*HX-C3*HXX)*DELT
        WP3 = WP3 + (ACZE+2.*OMEGA3*OMEGA3*HI3-C2*HX-C3*HXX)*DELT
        HI3 = HI3 + (WP3-C1*HX)*DELT
        HX  = HI3-PALT-C4*WP3
        HXX = HXX+HX*DELT
C--------------------------------------------------------------------
C  COMPUTE WIND VECTOR COMPONENTS
C  TWO DIMENSIONAL , UNCORRECTED ANGLES
B       UI1 =-TASX * SS * CH + VEW
B       VI1 =-TASX * CS * CH + VNS
C--------------------------------------------------------------------
C  COMPUTE LONGITUDINAL AND LATERAL COMPONENTS
B       UX1 = UI1 * SS + VI1 * CS
B       VY1 =-UI1 * CS + VI1 * SS
C--------------------------------------------------------------------
C
C NOSE BOOM ANGULAR VELOCITY CORRECTION TERMS
C THREE DIMENSIONAL , CORRECTED ANGLES
A       DELPH = PITCH-PITCH0
A       TEST  = 22.5*RAD
A       IF(ABS(DELPH).GE.TEST)
A         IF(DELPH.GT.0.) PITCH0=PITCH0+TEST*2.
A         IF(DELPH.LT.0.) PITCH0=PITCH0-TEST*2.
A       END IF
A       THEDOT = (PITCH-PITCH0)/DELT
A       DELTH = THF-THF0
A       TEST = 180.*RAD
A       IF(ABS(DELTH).GE.TEST)
A         IF(DELTH.GT.0.) THF0=THF0+TEST*2.
A         IF(DELTH.LT.0.) THF0=THF0-TEST*2.
A       END IF
A       PSIDOT = (THF-THF0)/DELT
A       PITCH0 = PITCH
A       THF0 = THF
A       BVNS = BL*(PSIDOT*SS*CH+THEDOT*CS*SH)
A       BVEW = BL*(THEDOT*SH*SS-PSIDOT*CS*CH)
C--------------------------------------------------------------------
C  COMPUTE WIND VECTOR COMPONENTS W.R.T. GEOGRAPHIC COORDINATES
C       UI  = -TASGB*(CA*G+H+SA*P) + VEW-BVEW
C       VI  = -TASGB*(CA*D+E+SA*F) + VNS-BVNS
C       WI  = -TASGB*(CA*CB*SH-SB*CH*SR-SA*CH*CR) + WP3 +BL*THEDOT*CH
C       UI1 = -TASX*(CA*G+H+SA*P) + VEW-BVEW
C       VI1 = -TASX*(CA*D+E+SA*F) + VNS-BVNS
C       WI1 = -TASX*(CA*CB*SH-SB*CH*SR-SA*CH*CR) + WP3 +BL*THEDOT*CH
C--------------------------------------------------------------------
C  CHANGES AS PER D. FRIESEN'S MEMO OF SEPT.26,1984
A       UI  = -TASGB*DAB*(SS*CH + H + TA*P) + VEW-BVEW
A       VI  = -TASGB*DAB*(CS*CH + E + TA*F) + VNS-BVNS
A       WI  = -TASGB*DAB*(SH-TB*CH*SR-TA*CH*CR) + WP3 +BL*THEDOT*CH
A       UI1 = -TASX*DAB*(SS*CH + H + TA*P) + VEW-BVEW
A       VI1 = -TASX*DAB*(CS*CH + E + TA*F) + VNS-BVNS
A       WI1 = -TASX*DAB*(SH-TB*CH*SR-TA*CH*CR) + WP3 +BL*THEDOT*CH
C------------------------------------------------------------------
C  ROTATE UI AND VI COMPONENTS INTO LONGITUDNL AND
C  LATERAL COMPONENTS UX AND VY
A       UX  =  UI *SS + VI *CS
A       VY  = -UI *CS + VI *SS
A       UX1 =  UI1*SS + VI1*CS
A       VY1 = -UI1*CS + VI1*SS
C---------------------------------------------------------------------
C***************    STORE VALUES INTO DATA ARRAY  HERE    ********************
C*******       WIND VECTOR EAST GUST COMPONENT (M/S)                    UI
C*******       WIND VECTOR NORTH GUST COMPONENT (M/S)                   VI
C*******       WIND VECTOR VERTICAL GUST COMPONENT (M/S)                WI
C*******       WIND VECTOR LNGTDNL GUST COMPONENT (M/S)                 UX
C*******       WIND VECTOR LATERAL GUST  COMPONENT (M/S)                VY
C*******       WIND VECTOR EAST COMPONENT (M/S)                         UI1
C*******       WIND VECTOR NORTH COMPONENT (M/S)                        VI1
C*******       WIND VECTOR VERTICAL GUST COMPONENT (M/S)                WI1
C*******       WIND VECTOR LNGTDNL COMPONENT (M/S)                      UX1
C*******       WIND VECTOR LATERAL COMPONENT (M/S)                      VY1
C*******       AIRCRAFT C.G. ACCELERATION (M/S2)                        CGAC
C*******       DAMPED AIRCRAFT VERTICAL VELOCITY (M/S)                  WP3
C*******       PRESSURE-DAMPED INERTIAL ALTITUDE (M)                    HI3
C*******       HORIZONTAL WIND DIRECTION (DEG)                          WD
C*******       HORIZONTAL WIND SPEED (M/S)                              WSPD
C
        IF(QC1.LT.10. .AND. QC2.LT.10.)
          UI  = 0.0
          VI  = 0.0
          WI  = 0.0
          WI1 = 0.0
          UI1 = 0.0
          VI1 = 0.0
          UX  = 0.0
          VY  = 0.0
          UX1 = 0.0
          VY1 = 0.0
        END IF
C--------------------------------------------------------------------------
C*******       HORIZONTAL WIND SPEED (M/S)                              WSPD
        WSPD = SQRT(UI1*UI1 + VI1*VI1)
C*******       HORIZONTAL WIND DIRECTION (DEG)                            WD
        IF (UI1.EQ.0..AND.VI1.EQ.0.) VI1 = -0.0001
        WD = ATAN2(UI1,VI1)*DEG + 180.
C----------------------------------------------------------------------------
C       IF(NSTAGE.EQ.4 .AND. IX.LE.10) WRITE (6,700) UI,VI,WI,UX,VY,UI1,
C    1   VI1,WI1,UX1,VY1,ACZ,WSPD,WD,WP3,HI3
C 700   FORMAT(' CALIB-GUSTO:UI,VI,WI,UX,VY,UI1,VI1,WI1,UX1,VY1,',
C    1   'ACZ,WSPD,WD,WP3,HI3',/,15(1X,F6.2))
C
C       IF(IPVEW .GT.0)  DATA(IPVEW  +IX) = VEW
C       IF(IPVNS .GT.0)  DATA(IPVNS  +IX) = VNS
C       IF(IPACINS.GT.0) DATA(IPACINS+IX) = ACZ
        IF(IPWP3 .GT.0)  DATA(IPWP3  +IX) = WP3
        IF(IPHI3 .GT.0)  DATA(IPHI3  +IX) = HI3
A       IF(IPUI  .GT.0)  DATA(IPUI   +IX) = UI
A       IF(IPVI  .GT.0)  DATA(IPVI   +IX) = VI
A       IF(IPWI  .GT.0)  DATA(IPWI   +IX) = WI
A       IF(IPUX  .GT.0)  DATA(IPUX   +IX) = UX
A       IF(IPVY  .GT.0)  DATA(IPVY   +IX) = VY
        IF(IPUI1 .GT.0)  DATA(IPUI1  +IX) = UI1
        IF(IPVI1 .GT.0)  DATA(IPVI1  +IX) = VI1
        IF(IPWI1 .GT.0)  DATA(IPWI1  +IX) = WI1
        IF(IPUX1 .GT.0)  DATA(IPUX1  +IX) = UX1
        IF(IPVY1 .GT.0)  DATA(IPVY1  +IX) = VY1
        IF(IPWSPD.GT.0)  DATA(IPWSPD +IX) = WSPD
        IF(IPWDIR.GT.0)  DATA(IPWDIR +IX) = WD
      END DO
      CON(LOCSVG+1) = HX
      CON(LOCSVG+2) = HXX
      CON(LOCSVG+3) = WP3
      CON(LOCSVG+4) = HI3
      CON(LOCSVG+5) = PITCH0
      CON(LOCSVG+6) = THF0
C     CON(LOCSVG+7) = VZIO
C  RADOME SAVE
C     IF(NGUST.EQ.NGUSTR)
        CON(LOCSVG+11) = HX
        CON(LOCSVG+12) = HXX
        CON(LOCSVG+13) = WP3
        CON(LOCSVG+14) = HI3
        CON(LOCSVG+15) = PITCH0
        CON(LOCSVG+16) = THF0
C       CON(LOCSVG+17) = VZIO
C     END IF
      RETURN
      END
      SUBROUTINE STHETAE
C***********************************************************  STHETAE
C** EQUIVALENT POTENTIAL TEMPERATURE (K)
C** REQUIRES:1-DPC;2-ATX;3-PSXC;4-MR
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  TOP
.USE  OP
.USE  ERROR
.NOREP
      IPDPC = IPSOU(1) -1
      IPATX = IPSOU(2) -1
      IPPSXC = IPSOU(3) - 1
      IPRM = IPSOU(4) - 1
      INDPUT = INDPUT - 1
      DO (IX = 1 , LDO)
        DPC = DATA(IPDPC +IX)
        ATX = DATA(IPATX +IX)
        PSXC = DATA(IPPSXC + IX)
        RM = DATA(IPRM + IX)
        IF(DPC.EQ.99999. .OR. ATX.EQ.99999. .OR. PSXC.EQ.99999.
     1     .OR. RM.EQ.99999.)
         DATA(INDPUT+IX) =99999.
         GO TO 99
        END IF
        TK = ATX + 273.16
        IF(TK.LE.0.0) TK=0.0001
        CALL SEWIC(DPC,PSXC,EDPC)
        IF(EDPC.LE.0.0) EDPC=0.0001
        TLCL = (2840./(3.5*ALOG(TK)-ALOG(EDPC)-4.805))+55.
        THETA = TK * (1000./PSXC) ** 0.28571
C
        IF(TLCL.EQ.0.0) TLCL=0.0001
        EXPARG= ((3.376/TLCL)-.00254)*(RM*(1.+(.81E-3*RM)))
        IF(EXPARG.GT.741)
         PRINT 77,IX,ATX,DPC,PSXC,RM
  77     FORMAT(' STHETAE: IX,ATX,DPC,PSXC,MR - ',I5,4F9.3)
         EXPARG = 0.001
        END IF
        THETAE = THETA*EXP(EXPARG)
        DATA(INDPUT+IX) = THETAE
C-----------------------------------------------------------------
   99   CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SPLWCC
C***********************************************************  PLWCC
C** CORRECTED PMS/KING LIQUID WATER (G/M3)   (CPLWC)  SEPT1983
C** REQUIRES:1-PLWC;2-ATX;3-PSXC;4-TASX
C ----------------------------------------------------------
C  Revised to use probe length (L1) and wire diameter (D1) from the
C   PDUD file.  Values come in via COMMON /PLWC/ block replacing EN1
C   and CN1 which are no longer used.                  -- September 1992  RLR
C
C  Note:  All input variables in this subroutine must be at the same rate.
C
C MODS from Darrel Baumgardner  OCT. 1990   -cc
C
C   King Probe Liquid Water Content Code
C       Definitions:
C          T   = Air Temperature (C)
C          PMB = Pressure (mbar)
C          TAS = True Air Speed (m/s)
C          P1  = Power (watts)
C          TW1 = Wire Temperature (C)
C          L1  = Probe Length (cm)
C          D1  = Probe Diameter (cm)
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  CALCOM
.USE  TOP
.USE  OP
.USE  ERROR
.NOREP
      COMMON / PLWC / TWIRE, L1, D1
      REAL L1
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Execubable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
      IPPLWC = IPSOU(1) - 1
      IPATX  = IPSOU(2) - 1
      IPPSXC = IPSOU(3) - 1
      IPTASX = IPSOU(4) - 1
      INDPUT = INDPUT - 1
C
      TWK1  = TWIRE + 273.16
C
C  Start Diagnostic
C     IF (NSTAGE.EQ.4) WRITE (6,1233) TWIRE, TWK1, L1, D1
C1233 FORMAT (" SPLWCC:  TWIRE (C + K), L1, D1 =" 4G15.7)
C  End Diagnostic
      DO (IX=1,LDO)
        PLWC = DATA(IPPLWC+IX)
        ATX  = DATA(IPATX +IX)
        PSXC = DATA(IPPSXC+IX)
        TASX = DATA(IPTASX+IX)
C
        IF (PLWC.EQ.99999. .OR. ATX.EQ.99999. .OR. PSXC.EQ.99999.
     1     .OR. TASX.EQ.99999.)
          DATA(INDPUT+IX) = 99999.
          GO TO 99
        END IF
C
        TK    = ATX+273.16 
        TFLM1 = (TWK1+TK)/2. 
        IF (TFLM1.EQ.0.0) TFLM1 = 0.001
C
C       The value tfrac allows the modified film temperature to track the
C       average film temperature while in cloud.
C     CALCULATE THE THERMAL CONDUCTIVITY
        CND1  = 5.8E-5*(398./(125.+TFLM1))*(TFLM1/273.)**1.5 
        CNDW1 = 5.8E-5*(398./(125.+TWK1))*(TWK1/273.)**1.5 
C     CALCULATE THE VISCOSITY 
        VISC1 = 1.718E-4*(393./(120.+TFLM1))*(TFLM1/273.)**1.5
        VSCW1 = 1.718E-4*(393./(120.+TWK1))*(TWK1/273.)**1.5
C     CALCULATE THE DENSITY 
        DENS1 = PSXC/(2870.5*TFLM1)
        FCT1  = 3.14159*L1*CND1*(TWK1-TK)
C       VISC1 = MAX(VISC1,0.001)         \
C       CND1  = MAX(CND1 ,0.001)          }  Don't do this!
C       CNDW1 = MAX(CNDW1,0.001)         /
        IF (VISC1.EQ.0.0) VISC1 = 0.001
        IF (CND1.EQ.0.0)  CND1  = 0.001
        IF (CNDW1.EQ.0.0) CNDW1 = 0.001
        RE1   = 100.*DENS1*TASX*D1/VISC1 
        PRF1  = 0.24*VISC1/CND1
        PRW1  = 0.24*VSCW1/CNDW1
C       PRW1  = MAX(PRW1 ,0.001)         \
C       TASX  = MAX(TASX ,1.0)           /  Don't do this!
        IF (PRW1.EQ.0.0)  PRW1 = 0.001
        IF (TASX.EQ.0.0)  TASX = 1.0
        DRYP1 = 0.26*RE1**0.6*PRF1**0.37*(PRF1/PRW1)**0.25*FCT1/0.239
        FACT  = 1.238E6*0.239/(TASX*100.*(597.3+373.16-TK))
        PLWCC = (PLWC-DRYP1)*FACT
C
C       End of liquid water code
C---------
C
C  Start Diagnostic
C     IF (NSTAGE.EQ.4 .AND. MOD(IRON,20).EQ.0)
C       WRITE (6,1234)
C    &  PLWC, PLWCC, TASX, PSXC, ATX, TK, TFLM1, CND1
C1234   FORMAT("  SPLWCC:  PLWC, PLWCC, TASX, PSXC, ATX, TK, TFLM1, CND1
C    & ="/X8G15.7)
C       WRITE (6,1235)
C    &  CNDW1, VISC1, VSCW1, DENS1, FCT1, RE1, PRF1, PRW1
C1235   FORMAT("  SPLWCC:  CNDW1, VISC1, VSCW1, DENS1, FCT1, RE1, PRF1, 
C    &PRW1 ="/X8G15.7)
C       WRITE (6,1236) DRYP1, FACT
C1236   FORMAT("  SPLWCC:  DRYP1, FACT ="/  X2G15.7)
C     END IF
C     IRON = IRON + 1
C  End Diagnostic
C
        DATA(INDPUT+IX) = PLWCC
   99   CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SHGME                                                          
C************************************************************** HGME            
C** GEOMETRIC (RADAR) ALTITUDE (EXTENDED RANGE)(APM-159) (M)                    
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  TOP                                                                       
.USE  OP                                                                        
.USE  ERROR                                                                     
.NOREP                                                                          
C     COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2                                       
      IPCHGME= IPSOU(1) -1
      IPHGME = INDGET - 1                                                       
      INDPUT = INDPUT - 1                                                       
C     IRQC1 = LRTQC1/LRATE                                                      
C     IRQC2 = LRTQC2/LRATE                                                      
      DO  (IX = 1, LDO)                                                         
C       IQC1= (IX-1)*IRQC1                                                      
C       QC1 = DATA(IPQC1+IQC1)                                                  
C       IQC2= (IX-1)*IRQC2                                                      
C       QC2 = DATA(IPQC2+IQC2)                                                  
        CHGME = DATA(IPCHGME +IX)
        HGME = DATA(IPHGME + IX)               
        IF(HGME.EQ.99999. .OR. CHGME.EQ.99999. )
         DATA(IPHGME+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
C        HGME = AMOD(XHGME,360.)
c        if(nstage.eq.4) PRINT 500,IX,CHGME,HGME,QC1,QC2,CONVERT 
C 500   FORMAT(' IX,CHGME,HGME,QC1,QC2,CONVERT ',I4,5F9.3) 
c
        call angcr(hgme,chgme,14.4,0.)
c
c        if(nstage.eq.4) PRINT 501,CHGME,HGME
C 501   FORMAT(' after angcr call:CHGME,HGME ',2F9.3) 
c        IF(HGME.GT.270. .OR. HGME.LT.0.) HGME = 0.0 
C        IF(QC1.LT.10. .OR. QC2.LT.10.) HGME = 0.0 
        HGME=HGME*84.66667                                                      
C** CONVERTS METERS TO FEET IF CONVERT.GT. 1.                                   
        IF(CONVERT .GT. 1.0)                                                    
         HGME = HGME * CONVERT                                                  
        END IF                                                                  
        DATA(INDPUT + IX) = HGME                                                
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
C                                                                               
      SUBROUTINE ANGCR(A2,A1,R,AMIN)
      DATA ACYCLE/360./ 
C THIS SUBROUTINE LINKS THE SYNCRO ANGLE A2 TO THE PREVIOUS VALUE A1 BY 
C A TOLERANCE TEST ON 1/2 OF THE SYNCRO RANGE R.  ANGLE A2 IS THEN PUT
C IN THE RANGE OF AMIN TO AMIN+ACYCLE, WHERE ACYCLE IS GENERALLY 360. 
C DEGREES.  AMIN IS GENERALLY -180. OR 0. DEGREES. 
      AMAX=AMIN+ACYCLE
      TOL=.5*R
  4   D=A2-A1 
      AD=ABS(D) 
c      print 9,a2,a1,r,amin,amax,acycle,d,ad
C 9   format(' a2,a1,r,amin,amax,acycle,d,ad ',8f8.2)
      IF (AD .LE. TOL) GO TO 2
      IF(D)1,2,3
  1   A2=A2+R 
      GO TO 4 
  3   A2=A2-R 
      GO TO 4 
  2   IF(A2.GE.AMIN.AND.A2.LE.AMAX) RETURN
      IF(A2.LT.AMIN) A2=A2+ACYCLE 
      IF(A2.GT.AMAX) A2=A2-ACYCLE 
      GO TO 2 
      END 

C                                                                               
C                                                                               
      SUBROUTINE SPALT                                                          
C**********************************************************  SPALT              
C** NCAA PRESSURE ALTITUDE (M)                                                  
C** REQUIRES:1-PSXC                                                             
C** REQUIRES:ASTG                                                               
C                                                                               
.REPL                                                                           
.USE  TBLANK                                                                    
.USE  BLANK                                                                     
.USE  IOUNIT                                                                    
.USE  CALCOM                                                                    
.USE  ERROR                                                                     
.NOREP                                                                          
      IPPSXC=IPSOU(1  )  -1                                                     
      ASTG = CONS1                                                              
      INDPUT = INDPUT -1                                                        
      DO (IX=1,LDO)                                                             
        PSXC   = DATA(IPPSXC   +IX)                                             
        IF(PSXC.EQ.99999. )                                                     
         DATA(INDPUT+IX) =99999.                                                
         GO TO 99                                                               
        END IF                                                                  
        HP = PSXC/ASTG                                                          
Q       HP = 44308.*(1.0 - HP**0.190284)                                        
F       HP = 44308.*(1.0 - HP**0.190284)                                        
E       HP = 44308.*(1.0 - HP**0.190284)                                        
S       IF (HP.GE.0.2231985125)                                                 
S         HP = 44308.*(1.0 - HP**0.190284)                                      
S       OR IF (HP.LT.0.2231985125)                                              
S         HP = 11000. + 14600.*ALOG10(0.2231985125/HP)                          
S       END IF                                                                  
      DATA(INDPUT+IX) = HP                                                      
   99   CONTINUE                                                                
      END DO                                                                    
      RETURN                                                                    
      END                                                                       
       SUBROUTINE SDEI
C***********************************************************  SDEI
C** DISTANCE EAST/WEST OF START (KM)
C** REQUIRES:1-ALON;2-ALAT
C** REQUIRES:CONS1
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
      DATA RAD/.01745329/
      IPALON = IPSOU(1)-1
      IPALAT =IPSOU(2)-1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
        ALONG = DATA(IPALON+IX)
        ALAT = DATA(IPALAT+IX)
        IF(ALONG.EQ.99999. .OR. ALAT.EQ.99999. )
         DATA(INDPUT+IX) =99999.
         GO TO 99
        END IF
        IF (ALONG.GT.180.) ALONG = ALONG - 360.
        DEI= (ALONG - CONS1)*111.17 *COS(ALAT*RAD)
        DATA(INDPUT+IX) = DEI
   99   CONTINUE
      END DO
      RETURN
      END
C
      SUBROUTINE SDNI
C***********************************************************  SDNI
C** DISTANCE NORTH/SOUTH OF START  (KM)
C** REQUIRES:1-ALAT
C** REQUIRES:CONS1
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
      IPALAT = IPSOU(1)-1
      INDPUT = INDPUT -1
      DO (IX=1,LDO)
       ALAT = DATA(IPALAT+IX)
       IF(ALAT.EQ.99999. )
         DATA(INDPUT+IX) =99999.
         GO TO 99
       END IF
       IF (ALAT.GT.180) ALAT = ALAT - 360.
       DNI= (ALAT -CONS1) * 111.17
       DATA(INDPUT+IX) = DNI
   99   CONTINUE
      END DO
      RETURN
      END
      SUBROUTINE SFSSP
C ----------------------------------------------------------------------------
C    FSSP Calculations
C ----------------------------------------------------------------------------
C  PROJECT ASTEX/MAGE:  September 1992  RLR
C    This special code for ASTEX/MAGE is needed because of the new cell size
C      arrangement for the FSSP.  The "it will never change" principle has now
C      ended.  I will use the cell sizes given in the SIZEF array instead of
C      the hard-wired ones previously used.
C    This modification to the FSSP incorporates changes needed as a result of
C      implementing the new ADS header.  To make sure all data end on a 64-bit
C      boundary, all PMS channels have pads.  The FSSP now has 22 words per
C      frame instead of 21.  This required changes to the software.
C    This modification to the FSSP changes the way activity is calculated.
C    It also multiplies FRESET by 10 to account for a divide-by-ten done
C      within the probe.
C  PROJECT HaRP:  24 Oct. 1990  CC
C  This PMS-1D FSSP probe processor includes Darrel Baumgardner's newest mods 
C  to correct (fix) the accumulated raw counts before the concentrations
C  are calculated.  
C
C  Darrel's black box contains the following subroutines:
C  FXFSP
C  VBIAS
C  TWOMY
C  SIG
C  SMOOTH
C  EXTRP - FUNCTION
C
C  THE INPUT PARAMETERS REQUIRED FOR THIS PROCESSOR ARE:
C  1. TIME IN SECONDS
C  2. TAS
C  3. FSSP DATA BLOCK
C
C  This subroutine will produce the following output data set, by request
C
C  0. ACCFSPH:  A data block of raw counts at high rate if the FSSP data 
C                come in at high rate
C  1. ACCFSPL:  A data block of raw counts at low rate if the FSSP data 
C                come in at low rate
C  2. AFSP01-AFSP15:  ACCUMULATED RAW COUNTS FOR EACH CELL AT 1/SEC
C  3. CFSP01-CFSP15:  CONCENTRATIONS FROM FIXED RAW COUNTS FOR EACH CELL AT
C                      1/SEC
C  4. SUM15F:  TOTAL OF ALL COUNTS
C  5. FACT:  ACTIVITY COUNTS
C  6. FLWC:  LIQUID WATER CONTENT IN GRAMS PER CUBIC METER
C  7. FDBAR:  MEAN PARTICLE DIAMETER
C  8. FDISP:  DISPERSION 
C  9. AFSC01-AFSC15:  ACCUMULATED CORRECTED COUNTS FOR EACH CELL AT 1/SEC
C ----------------------------------------------------------------------------
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
      DIMENSION ACC(15),SMKN(15),SMCON(15),AREA(15)
C     DIMENSION ARAY1(15),ARAY2(15),ARAY3(15),ARAY4(15)
      DIMENSION IPAFSP(15),IPCFSP(15),IPAFSC(15)
      INTEGER ALABX(5),ALABY(5),CLABX(5),CLABY(5)
      COMMON/HIST/LT(5),NCELLS,SIZE(64),NSIZE
      COMMON/PFSSP/TAU1,TAU2,TAU3,CWD(4),CBIAS(4),DOF,BDIA,NCSUMF,
     1             THRESHF,KRANGE,KSTROB,KRESET,MRATEF,MWORDF,MCELLF,
     2             SIZEF(15)
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
C
C ** VARIABLE NAMES OF ACCUMULATED RAW COUNTS FOR EACH CELL
      DATA NAFSP01/8HAFSP01  /, NAFSP02/8HAFSP02  /, NAFSP03/8HAFSP03  /
      DATA NAFSP04/8HAFSP04  /, NAFSP05/8HAFSP05  /, NAFSP06/8HAFSP06  /
      DATA NAFSP07/8HAFSP07  /, NAFSP08/8HAFSP08  /, NAFSP09/8HAFSP09  /
      DATA NAFSP10/8HAFSP10  /, NAFSP11/8HAFSP11  /, NAFSP12/8HAFSP12  /
      DATA NAFSP13/8HAFSP13  /, NAFSP14/8HAFSP14  /, NAFSP15/8HAFSP15  /
C
C ** VARIABLE NAMES OF CONCENTRATION, FROM CORRECTED COUNTS, FOR EACH CELL
      DATA NCFSP01/8HCFSP01  /, NCFSP02/8HCFSP02  /, NCFSP03/8HCFSP03  /
      DATA NCFSP04/8HCFSP04  /, NCFSP05/8HCFSP05  /, NCFSP06/8HCFSP06  /
      DATA NCFSP07/8HCFSP07  /, NCFSP08/8HCFSP08  /, NCFSP09/8HCFSP09  /
      DATA NCFSP10/8HCFSP10  /, NCFSP11/8HCFSP11  /, NCFSP12/8HCFSP12  /
      DATA NCFSP13/8HCFSP13  /, NCFSP14/8HCFSP14  /, NCFSP15/8HCFSP15  /
C
      DATA NFACT  /8HFACT    /, NPLWCF /8HPLWCF   /
      DATA NCONCF /8HCONCF   /, NDBARF /8HDBARF   /, NDISPF /8HDISPF   /
      DATA NFRANGE/8HFRANGE  /, NFSTROB/8HFSTROB  /, NSUM15F/8HSUM15F  /
      DATA NFRESET/8HFRESET  /, NFBMFR /8HFBMFR   /
      DATA NACCFSPH/8HACCFSPH /, NACCFSPL/8HACCFSPL /
      DATA NACXFSPL/8HACXFSPL /
C
C ** FLAGs for histogram plots
      DATA NAFSSP /8HAFSSP   /, NCFSSP/8HCFSSP   /
C
C ** SIZE TABLES FOR RANGE 1-4  
C    Use the mid point of the size channel--nominal PMS values from 
C    Darrel's black box (the DATA Block section)   Oct. 23, 1990  
C    These values should not be changed from now on.
C    -cc
C     DATA ARAY1/ 3.5, 6.5, 9.5,12.5,15.5,18.5,21.5,24.5,27.5,30.5,
C    1           33.5,36.5,39.5,42.5,45.5/
C     DATA ARAY2/ 3.0, 5.0, 7.0, 9.0,11.0,13.0,15.0,17.0,19.0,21.0,
C    1           23.0,25.0,27.0,29.0,31.0/
C     DATA ARAY3/ 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5,10.5,
C    1           11.5,12.5,13.5,14.5,15.5/
C     DATA ARAY4/0.75,1.25,1.75,2.25,2.75,3.25,3.75,4.25,4.75,5.25,
C    1           5.75,6.25,6.75,7.25,7.75/
C  Above sizes changed for ASTEX, used only one range; using only one table
C   (the SIZEF array)   RLR  4 September 1992  (ASTEX/MAGE)
C
      IPRAW = INDGET
C--------------------------------------------------------------------
C       ACCESS THE FUNCTION CONTROLS
C DEFFUN=1-NAMFUN;2-PMS PLT NSIZE;
C        3-PMS PLT LOGLIN,4-PMS PLT MGRY;5-PMS PLT MINRY;6-PMS PLT BOT;
C        7-PMS PLT TOP; 8-PMS PLT LABX; 9-PMS PLT LABY
C
C     IF(NSTAGE.EQ.4)PRINT 90, MRATEF,MWORDF,IPRAW
      NCELLS = MCELLF
C
C Begin Diagnostic
C     IF (NSTAGE.EQ.4)
C    &  WRITE (6,1234) MRATEF,MWORDF,IPRAW,NCELLS,DOF,BDIA,
C    &                 LRATE,LRTSOU(1),LRTSOU(2),SIZEF
C1234 FORMAT ("  SFSSP:  MRATEF, MWORDF, IPRAW, NCELLS = "4I10/
C    &        "          DOF, BDIA = "2G15.7/
C    &        "          LRATE, LRTSOU(1-2) = "3I10/
C    &        "          SIZEF ARRAY:"/(X5G15.7/))
C End Diagnostic
C
      INDST =3
.USE  INDEX
C     CALL CPRINT (0,6,128,8,5,DUM,0)
      IOF01 = ICON(INDOFF+1)
      IOF02 = ICON(INDOFF+2)
      IOF03 = ICON(INDOFF+3)
      IOF04 = ICON(INDOFF+4)
      IOF05 = ICON(INDOFF+5)
      IOF06 = ICON(INDOFF+6)
      IOF07 = ICON(INDOFF+7)
      IOF08 = ICON(INDOFF+8)
      IOF09 = ICON(INDOFF+9)
C
      DO (I=1,NUMVEC)
       IND = INDVAL + LENCON*(I-1)
       NAMFUN = ICON(IND+IOF01)
       NSIZE  = ICON(IND+IOF02)
C** FSSP ACCUMULATION  ------------------------------------- AFSSP
       IF (NAMFUN.EQ.NAFSSP)
        LLA = ICON(IND+IOF03)
        IF (LLA.LT.0 .OR. LLA.GT.2) LLA = 0
        MGRYA  = ICON(IND+IOF04)
        MINRYA = ICON(IND+IOF05)
        BA     =  CON(IND+IOF06)
        TA     =  CON(IND+IOF07)
        DO (IL=1,5)
         ALABX(IL) = ICON(IND+IOF08+IL-1)
         ALABY(IL) = ICON(IND+IOF09+IL-1)
        END DO
       END IF
C** FSSP CONCENTRATION ------------------------------------- CFSSP
       IF (NAMFUN.EQ.NCFSSP)
        LLC = ICON(IND+IOF03)
        IF (LLC.LT.0 .OR. LLC.GT.2) LLC = 0
        MGRYC  = ICON(IND+IOF04)
        MINRYC = ICON(IND+IOF05)
        BC     =  CON(IND+IOF06)
        TC     =  CON(IND+IOF07)
        DO (IL=1,5)
         CLABX(IL) = ICON(IND+IOF08+IL-1)
         CLABY(IL) = ICON(IND+IOF09+IL-1)
        END DO
       END IF
      END DO
C
C       ACCESS THE VARIABLE CONTROLS
      INDST = 2
.USE  INDEX
C     CALL CPRINT(0,6,128,8,5,DUM,0)
      IOFF01 = ICON(INDOFF+1)
      IOFF02 = ICON(INDOFF+2)
      IOFF03 = ICON(INDOFF+3)
      IOFF04 = ICON(INDOFF+4)
      IOFF05 = ICON(INDOFF+5)
      DO (K=1,NUMVEC)
       IND    = INDVAL + LENCON*(K-1)
       NAMVAR = ICON(IND+IOFF01)
       INDGET = ICON(IND+IOFF02)
       INRATE = ICON(IND+IOFF03)
       INDPUT = ICON(IND+IOFF04)
       LRATE  = ICON(IND+IOFF05)
       IF (NAMVAR .EQ. NACCFSPH) IPACCH     = INDPUT-1
       IF (NAMVAR .EQ. NACCFSPL) IPACCL     = INDPUT-1
       IF (NAMVAR .EQ. NACXFSPL) IPACXL     = INDPUT-1
       IF (NAMVAR .EQ. NFRANGE)  IPFRANGE   = INDPUT-1
       IF (NAMVAR .EQ. NFRESET)  IPFRESET   = INDPUT-1
       IF (NAMVAR .EQ. NSUM15F)  IPSUMF     = INDPUT-1
       IF (NAMVAR .EQ. NFSTROB)  IPFSTROB   = INDPUT-1
       IF (NAMVAR .EQ. NCONCF)   IPFCON     = INDPUT-1
       IF (NAMVAR .EQ. NDBARF)   IPFDBA     = INDPUT-1
       IF (NAMVAR .EQ. NDISPF)   IPFDIS     = INDPUT-1
       IF (NAMVAR .EQ. NFACT)    IPFACT     = INDPUT-1
       IF (NAMVAR .EQ. NPLWCF)   IPFLWC     = INDPUT-1
       IF (NAMVAR .EQ. NFBMFR)   IPFBMFRA   = INDPUT-1
C
       IF (NAMVAR .EQ. NAFSP01)  IPAFSP( 1) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP02)  IPAFSP( 2) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP03)  IPAFSP( 3) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP04)  IPAFSP( 4) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP05)  IPAFSP( 5) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP06)  IPAFSP( 6) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP07)  IPAFSP( 7) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP08)  IPAFSP( 8) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP09)  IPAFSP( 9) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP10)  IPAFSP(10) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP11)  IPAFSP(11) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP12)  IPAFSP(12) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP13)  IPAFSP(13) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP14)  IPAFSP(14) = INDPUT-1
       IF (NAMVAR .EQ. NAFSP15)  IPAFSP(15) = INDPUT-1
C
       IF (NAMVAR .EQ. NCFSP01)  IPCFSP( 1) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP02)  IPCFSP( 2) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP03)  IPCFSP( 3) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP04)  IPCFSP( 4) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP05)  IPCFSP( 5) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP06)  IPCFSP( 6) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP07)  IPCFSP( 7) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP08)  IPCFSP( 8) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP09)  IPCFSP( 9) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP10)  IPCFSP(10) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP11)  IPCFSP(11) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP12)  IPCFSP(12) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP13)  IPCFSP(13) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP14)  IPCFSP(14) = INDPUT-1
       IF (NAMVAR .EQ. NCFSP15)  IPCFSP(15) = INDPUT-1
C
      END DO
C-----------------------------
C  ***** INITIALIZATION FOR A NEW CASE
      IF (NSTAGE.EQ.4) NUMSMP = 0
      LDO = NCDO
C
C  **********************     P M S  PROBE MODULE      **********************
C  *                                                                        *
C  **********************    FSSP PROBE           SEPT. 1983
C PMS 1-D PROBE FSSP DATA PROCESSING
C INPUT INFORMATION REQUIRED:
C   1. PMS BLOCK SIZE IN WORDS              MSIZE
C   2. PMS BLOCK SAMPLING RATE              MRATE
C   3. NO. OF WORDS PER SAMPLE              MWORD
C   4. NO. OF SIZE CELLS                    NCELLS
C   5. FIRST ADDRESS OF THE PMS BLOCK*NCDO  IPRAW
C PMS BLOCK STRUCTURE
C-----------------------------------------------------------------------
C|P |SAMPLE ONE: WD1.RANGE;WD2.SPARE;WD3.REFERENCE VOLTAGE;
C|R |            WD4.STROBE; WD5.RESET; WD6.CELL 0;
C|O |            WD7-WD21.CELL 1-15; WD22.FILL
C|B |
C|E |SAMPLE TWO:
C|1 |.
C----------------------------------------------------------------------
C ASSUMING PMS DATA COMING INTO THIS ROUTINE = (PMS BLOCK)*NCDO
C DATA() ARE THE DATA ARRAY TO PICK UP PMS BLOCK DATA
C INDGET IS THE INDEX TO PICK UP THE FIRST WORD OF PMS BLOCK FROM DATA()
C
      MSIZE = MRATEF*MWORDF
C ***  ASSUMING: 7TH WORD OF PMS FSSP BLOCK STARTS THE CELL DATA
C     KCELL = 7
C
C ############   As a test, try starting everything on the 6th position
      KCELL = 6
C
      IPTIME= IPSOU(1)-1
      IPTAS = IPSOU(2)
      SECSUM = CONS1
C     IRTAS = LRTSOU(2)/MRATEF
C     IRQC1 = LRTQC1/MRATEF
C     IRQC2 = LRTQC2/MRATEF
      IRTAS = LRTSOU(2)
      IRQC1 = LRTQC1
      IRQC2 = LRTQC2
      KTH   = 0
      KTL   = 0
      KTX   = 0
C
C LOOP OVER THE TOTAL NUMBER OF CYCLES TO PROCESS
      DO (IX=1,LDO)
C      IQC1  = (IX-1)*IRQC1
C      IQC2  = (IX-1)*IRQC2
       IQC1  = (IX-1)*IRQC1 + 1
       IQC2  = (IX-1)*IRQC2 + 1
       QC1   = DATA(IPQC1+IQC1)
       QC2   = DATA(IPQC2+IQC2)
       ITAS  = (IX-1)*IRTAS
       DIST1 = DATA(IPTAS+ITAS)
       TIME  = DATA(IPTIME+IX)
C** PRINT OUT THE RAW DATA POINTS-----------------
C      IZ1 = IPRAW + (IX-1)*MSIZE
C      IZ2 = IZ1+MSIZE-1
C      IF (NSTAGE.EQ.4) PRINT 21,TIME,IX,(DATA(IM),IM=IZ1,IZ2)
C      PRINT 21,TIME,IX,(DATA(IM),IM=IZ1,IZ2)
C  21  FORMAT(/,' FSSP:TIME,IX,CELLS ',F9.1,I8,/,(21F6.1))
C
       DO (MCELL= 1,NCELLS)
        ACC(MCELL) = 0.0
       END DO
       ASTROB = 0.0
       ARESET = 0.0
       ABMFRA = 0.0
       SUM15F = 0.0
C
C LOOP OVER THE SAMPLING RATE MRATE
       DO (IY= 1,MRATEF)
        INDEX = IPRAW + ((IX-1)*MSIZE) + ((IY-1)*MWORDF)
        IXRANG = INDEX + KRANGE-1
        IXRSET = INDEX + KRESET-1
        IXSTRO = INDEX + KSTROB-1
C**      THE RANGE VALUES SHOULD BE PROTECTED (ADS:0,1,2,3;ARIS4:1,2,3,4)
        IRANGE = DATA(IXRANG) + 0.5 + 1.0
        IF (IRANGE.LE.0 .OR. IRANGE.GT.4) IRANGE = 1
        RANGE = float(IRANGE)
C
        SUM15 = 0.0
        KNCNT = 0
C       DO (ICELL=KCELL,MWORDF)
C        INDEX7 = INDEX + ICELL - 1
        DO (ICELL=1,NCELLS)
         KTH    = KTH + 1
         KNCNT  = KNCNT + 1
         INDEX7 = INDEX + KCELL + ICELL - 1
         ICOUNT = DATA(INDEX7) + 0.5
         RCOUNT = ICOUNT
         IF (RCOUNT.LT.0.0) RCOUNT = 0.0
         IF (QC1.LT.10.0.AND.QC2.LT.10.0) RCOUNT = 0.0
         ACC(KNCNT) = ACC(KNCNT) + RCOUNT
         SUM15 = SUM15 + RCOUNT
C**       STORE RAW COUNTS FOR THE RAW DATA BLOCK AT HIGH RATE
         IF (IPACCH.GT.0) DATA(IPACCH+KTH) = RCOUNT
        END DO
C
C ** SUM15F - SUM OF ALL FSSP COUNTS OVER 15 CELLS FOR 1 SEC
        SUM15F = SUM15F + SUM15
        IF (KSTROB .GT. 0)
         ISTROB = DATA(IXSTRO)+0.5
         STROB  = FLOAT(ISTROB)
        ELSE
         STROB  = SUM15/0.4
        END IF
        ASTROB = ASTROB + STROB
C
        IF (KRESET .GT. 0)
         IRESET = DATA(IXRSET) + 0.5
C
C*******   Change from Al Schanot for ASTEX.   RLR  921013
C        RESET  = FLOAT(IRESET)
         RESET  = FLOAT(IRESET)*10.
        ELSE
         RESET = STROB*((12.-DOF)/DOF)
        END IF
        ARESET = ARESET + RESET
C
C **     FSSP BEAM FRACTION   (BMFRAC)                              BMFRAC
        IF (STROB.LT.1. .OR. SUM15.LE.0.0)
         BMFRA = 0.40
        ELSE
         BMFRA = SUM15/STROB
        END IF
        ABMFRA = ABMFRA + BMFRA
       END DO
C**  Beam fraction should be the average over the sample rate.
       ABMFRA = ABMFRA/MRATEF
C
C**       STORE RAW COUNTS FOR THE RAW DATA BLOCK AT LOW RATE
       DO (KNCNT=1,MCELLF)
        KTL = KTL + 1
        IF (IPACCL.GT.0) DATA(IPACCL+KTL) = ACC(KNCNT)
C        SUM PER CELL RAW ACCUMULATIONS FOR HISTO
C       SMKN(KNCNT) = SMKN(KNCNT) + ACC(KNCNT)
       END DO
C
       IF (IPFSTROB .GT. 0) DATA(IPFSTROB+IX) = ASTROB
       IF (IPFRESET .GT. 0) DATA(IPFRESET+IX) = ARESET
       IF (IPFBMFRA .GT. 0) DATA(IPFBMFRA+IX) = ABMFRA
       IF (IPFRANGE .GT. 0) DATA(IPFRANGE+IX) = RANGE
       IF (IPSUMF .GT. 0)   DATA(IPSUMF+IX)   = SUM15F
C
C*******    FSSP ACTIVITY CORRECTION FACTOR   (FACTIV)                 FACTIV
C           TAU1,TAU2,TAU3,DOF,BDIA - CONSTANTS
C      ACTIV = (ASTROB*TAU1+(ARESET-ASTROB)*TAU2+TAU3)*0.71
C
C*******      Revised by RLR to reflect current thinking 921013
C                tau3 is no longer used.
       ACTIV = (ASTROB*TAU1+ARESET*TAU2)*0.71
C      activ = activ/float(mratef)
       IF (IPFACT.GT.0) DATA(IPFACT+IX) = ACTIV
C
       FLWC   = 0.0
       FCONC  = 0.0
       FDBAR  = 0.0
       FDBAR2 = 0.0
C ***************************************************************************** 
C **  CALL DARREL'S BLACK BOX HERE    
C      IF (NSTAGE.EQ.4) PRINT 22,TIME,ACC
C      PRINT 22,TIME,ACC
C  22  FORMAT(/,' FSSP(before fxfsp call):TIME,CELLS ',F9.1,/,(10F9.1))
C
C  For ASTEX, DO NOT call Darrel's Black Box.
C      CALL FXFSP (ACC,ABMFRA,DIST1,IRANGE,1)
C
C      IF (NSTAGE.EQ.4) PRINT 23,TIME,ACC
C      PRINT 23,TIME,ACC
C  23  FORMAT(/,' FSSP(after fxfsp call):TIME,CELLS ',F9.1,/,(10F9.1))
C
C*******     PMS CONCENTRATIONS  (INDIVIDUAL CELLS)  (CNTS/CC)        FCN/1-15
C            AREA - SAMPLE AREA 
       DO (KNCNT=1,MCELLF)
C**       STORE FIXED COUNTS FOR THE RAW DATA BLOCK AT LOW RATE
        KTX = KTX + 1
        IF (IPACXL.GT.0) DATA(IPACXL+KTX) = ACC(KNCNT)
C  Calculate area this way if using Darrel's Black Box:
C       AREA(KNCNT) = DOF*BDIA
C  Calculate area this way if not using Darrel's Black Box:
        AREA(KNCNT) = DOF*BDIA*ABMFRA
C  Following is used if data are output at the sample rate:
C       VOL = DIST1*AREA(KNCNT)*(1./FLOAT(MRATEF))
C  Following is used if data are output at 1 sps:
        VOL = DIST1*AREA(KNCNT)
C
C       IF (ACTIV.EQ.1.0) ACTIV = .99
C  Value of ACTIV should never get to 1.0, hence I'll limit it.
        ACTIV = MIN(ACTIV,0.99)
C
C     ZERO FLWC AND FCONC BEFORE TAKEOFF
        CONC = 0.0
        IF (VOL.GT.0.) CONC = ACC(KNCNT)/VOL

C** CORRECTION TO FSSP CONCENTRATION IS APPLIED HERE
C ** Assumes 1 sec accumulation
C     Following test already taken care of above, hence ignored here.
C       if (activ.lt. 1.0) CONC = CONC/(1.0-ACTIV)
C
        CONC = CONC/(1.0-ACTIV)
C
C** STORE CORRECTED ACCUMULATIONS AND CONCENTRATIONS FOR EACH CELL
        IF (IPAFSP(KNCNT).GT.0) DATA(IPAFSP(KNCNT)+IX) = ACC(KNCNT)
        IF (IPCFSP(KNCNT).GT.0) DATA(IPCFSP(KNCNT)+IX) = CONC
C
C      SUM PER CELL ACCUMULATIONS AND CONCENTRATIONS FOR HISTO
        SMKN(KNCNT)  = SMKN(KNCNT) + ACC(KNCNT)
        SMCON(KNCNT) = SMCON(KNCNT) + CONC
C
C         D IS CELL DIAMETER IN MICROMETERS
C         FSSP RANGE IN ARIS IS 1,2,3,4
C       D = KNCNT*CWD(IRANGE) + CBIAS(IRANGE)
C** SIZE ASSIGNED TO THE 15 CHANNELS OF FSSP (JAN7,1986-D.BAUMGARDNER)
C** SIZE ASSIGNED TO THE 15 CHANNELS OF FSSP (ASTEX/MAGE 4SEP1992 - A. Schanot)
        D = SIZEF(KNCNT)
C       IF (IRANGE.EQ.1) SIZE(KNCNT)=ARAY1(KNCNT)
C       IF (IRANGE.EQ.2) SIZE(KNCNT)=ARAY2(KNCNT)
C       IF (IRANGE.EQ.3) SIZE(KNCNT)=ARAY3(KNCNT)
C       IF (IRANGE.EQ.4) SIZE(KNCNT)=ARAY4(KNCNT)
C       D = SIZE(KNCNT)
        SIZE(KNCNT) = D
C
C   CONC THE PARTICLE CONCENTRATION IN NUMBER PER CUBIC CENTIMETER (N/CC)
C    FOR 1 SECOND FOR 1 CELL. FSSP SAMPLE AREAS ARE CALCULATED.
C    AND DIST1(TASX) IS TRUE AIRSPEED IN METERS PER SECOND.
C
C  FCONC PARTICLE CONCENTRATION NUMBER PER CC (N/CC) SUMMED OVER ALL CHANNELS.
C
        FCONC = FCONC + CONC
C
C     FDBAR AND FDBAR2 INTERMEDIATE VARIABLES USED FOR COMPUTING
C     THE MEAN PARTICLE DIAMETER AND STANDARD DEVIATION.
C
        FDBAR  = FDBAR + D*CONC
        FDBAR2 = FDBAR2 + D*D*CONC
C
C   FLWC LIQUID WATER CONTENT IN GRAMS PER CUBIC METER SUMMED OVER ALL CHANNEL
C     IT ASSUMES SPHERICAL DROPLETS WITH DENSITY OF WATER (1 GRAM PER CC)
C     AND USES D IN MICROMETERS AND CONCENTRATION, AN, NUMBER PER CC.
C
        FLWC = FLWC+4./3.*3.1415927*(D*1.E-4/2)**3*CONC*1.E6
       END DO
C
C     FDBAR MEAN PARTICLE DIAMETER IN MICROMETERS COMPUTED USING THE EQUATIONS
C     FOR GROUPED DATA SUCH AS ARE FOUND IN EQ. 24 ON PAGE 164 OF SCHAUMS
C     OUTLINE OF PROBABILITY AND STATISTICS (1975) BY M. SPIEGEL
C     SIGMA IS THE STANDARD DEVIATION IN MICROMETERS OF THE DIAMETER
C     DISTRIBUTION EQUATION 28  IBID.
C
       IF (FCONC .GT. 5.0)
        FDBAR = FDBAR/FCONC
        SQRD = FDBAR2/FCONC - FDBAR*FDBAR
        SIGMA = SQRT(ABS(SQRD))
        IF (FDBAR.NE.0.) FDISP = SIGMA/FDBAR
       ELSE
        FDBAR = 0.0
        FDISP = 0.0
       END IF
C
C     FDISP RATIO OF STANDARD DEVIATION TO MEAN DIAMETER IS MEASURE OF
C     THE DISPERSION OF THE DISTRIBUTION.
       IF (IPFLWC.GT.0) DATA(IPFLWC+IX) = FLWC
       IF (IPFCON.GT.0) DATA(IPFCON+IX) = FCONC
       IF (IPFDBA.GT.0) DATA(IPFDBA+IX) = FDBAR
       IF (IPFDIS.GT.0) DATA(IPFDIS+IX) = FDISP
C******  END OF FSSP CALCULATIONS AND CORRECTIONS ****************************
C
C                  HISTOGRAM PLOTS NEXT
C
C    AFTER THE LAST PMS CELL, CHECK FOR PLOT INTERVAL (START HISTOGRAM
C     PERIODS ON AN EVEN PLOT INTERVAL)
C
        NSEC = SECSUM
        NUMSMP = NUMSMP + 1
        IF (NUMSMP.EQ.1)
         TIM1 = TIME
         NMN = MOD(INT(TIM1),NSEC)
         IF (NMN .GT. 0)
          DO (KNCNT=1,MCELLF)
           SMCON(KNCNT) = 0.
           SMKN(KNCNT) = 0.
          END DO
          NUMSMP = 0
         END IF
        END IF
        SECS = NUMSMP*DELIV
        IF (SECS.EQ.SECSUM)
        TIM2 = TIM1 + SECSUM - 1.0
C
C     AVERAGE CONCENTRATIONS OVER PERIOD SECSUM FOR HISTO
        DO (KNCNT=1,MCELLF)
C        SMCON(KNCNT) = SMCON(KNCNT)/(SECSUM*FLOAT(MRATEF))
         SMCON(KNCNT) = SMCON(KNCNT)/SECSUM
         IF (SMCON(KNCNT) .LT. 0.0001) SMCON(KNCNT) = 0.
        END DO
        SUM=0.
        DO (K=1,NCSUMF)
         SUM = SUM + SMKN(K)
        END DO
C       PRINT 29,TIME,SMKN,SMCON
C  29   FORMAT(' time,smkn,smcon ', f12.2,/,15f8.1,/,15f8.1)
C
C THE PLOT INTERVAL, SECSUM, HAS BEEN REACHED FOR THE KNOLLENBERG SUMS.
C IF THE SUM OF NCSUM CELL COUNTS EXCEED THRESH, PLOT A HISTOGRAM .
C IF THE ACCUMULATION .LT.1 THEN SET IT TO .0001,FOR LOG SCALED
C HISTOGRAM PLOT.
C
        IF (SUM.GE.THRESHF)
         IF (LLA.GT.0)
          BA = 1.
          CALL HISTO(SMKN,LLA,MGRYA,MINRYA,BA,TA,ALABX,ALABY,TIM1,TIM2)
         END IF
         IF (LLC.GT.0)
          CALL HISTO(SMCON,LLC,MGRYC,MINRYC,BC,TC,CLABX,CLABY,TIM1,TIM2)
         END IF
        END IF
C
C  BLANK THE ACCUMULATORS
        NUMSMP = 0
        DO (K=1,MCELLF)
         SMKN(K)  = 0.
         SMCON(K) = 0.
        END DO
       END IF
C
C *******************     OUTPUT PMS PARAMETERS    ***************************
C
C     ZERO FLWC AND FCONC BEFORE TAKEOFF
       IF (QC1.LT.10.0 .AND. QC2.LT.10.0)
        FCONC = 0.0
        FLWC  = 0.0
       END IF
C
      END DO
      RETURN
      END

      BLOCK DATA
      COMMON /SETUP/size(16,4),A(20,20),PHA(16,4),DOF,BDIAM,
     $TAUR,TAUSLW,TAUFST,MROW,NCOL,XDEL,YDEL
      COMMON /INVRT/RSPNS,SIZES,TRNSMN,TRNSAV,SPECM,SPECA,SPCEST,EPS,
     1BMFRC,XF,SIGMA,A0,A1,A2,NSMTH,MKSPC
      REAL RSPNS(15,15),SIZES(50,15),TRNSMN(50,15),
     1BMFRC(15),TRNSAV(15),SPECM(15),SPECA(15),SPCEST(15),
     2EPS(15),XF(15)
c set MKSPC to 0    --cc
      DATA MKSPC/0/
C THESE ARE THE INTENSITY MAP VALUES FOR THE FSSP LASER
      DATA ((A(I,J),I=1,18),J=1,4)/
     $5.,5.,5.,5.,5.,6.,6.,6.,6.,6.,6.,6.,6.,6.,5.,5.,5.,5.,
     $5.,5.,5.,6.,6.,8.,10.,15.,17.,16.,13.,10.,7.,6.,6.,6.,5.,5.,
     $5.,5.,6.,7.,11.,20.,30.,40.,42.,39.,35.,28.,18.,10.,6.,6.,5.,5.,
     $5.,6.,7.,11.,26.,44.,47.,47.,43.,49.,48.,47.,36.,23.,11.,6.,6.,5./
      DATA ((A(I,J),I=1,18),J=5,8)/
     $5.,6.,9.,25.,44.,52.,59.,57.,68.,60.,56.,58.,44.,42.,24.,9.,6.,6.,
     $6.,8.,19.,40.,51.,58.,57.,72.,61.,61.,63.,64.,50.,57.,37.,17.,7.,
     $6,
     $6.,9.,21.,43.,48.,61.,66.,69.,72.,78.,71.,68.,51.,45.,43.,23.,9.,
     $6.,
     $6.,11.,30.,50.,69.,60.,74.,59.,74.,84.,70.,65.,56.,51.,55.,31.,
     $11.,6./
      DATA ((A(I,J),I=1,18),J=9,12)/
     $6.,14.,43.,54.,51.,63.,63.,78.,76.,78.,68.,66.,70.,49.,48.,34.,
     $11.,6.,
     $6.,15.,38.,58.,56.,58.,72.,63.,85.,80.,77.,62.,69.,59.,46.,27.,
     $10.,6.,
     $6.,12.,33.,48.,52.,57.,61.,62.,74.,71.,74.,58.,60.,54.,42.,20.,
     $8.,6.,
     $6.,9.,23.,49.,54.,55.,73.,66.,70.,74.,57.,55.,51.,47.,39.,18.,
     $7.,6./
      DATA ((A(I,J),I=1,18),J=13,16)/
     $6.,7.,16.,39.,50.,57.,60.,61.,58.,72.,67.,51.,50.,43.,22.,10.,
     $6.,5.,
     $6.,6.,9.,18.,37.,49.,52.,54.,56.,52.,43.,52.,46.,30.,15.,7.,6.,5.,
     $5.,6.,6.,9.,16.,29.,48.,48.,45.,51.,52.,39.,24.,13.,7.,6.,6.,5.,
     $5.,5.,6.,6.,8.,12.,19.,23.,25.,31.,28.,17.,10.,7.,6.,6.,5.,5./
      DATA ((A(I,J),I=1,18),J=17,18)/
     $5.,5.,5.,6.,6.,6.,7.,9.,10.,10.,9.,7.,6.,6.,5.,5.,5.,5.,
     $5.,5.,5.,5.,6.,6.,6.,6.,6.,6.,6.,6.,6.,5.,5.,5.,5.,5./
C
C    THESE PHA VALUES ARE FOR THE FOUR RANGES OF THE FSSP
      DATA PHA/
     $40.,190.,350.,540.,760.,1000.,1300.,1750.,2250.,2900.,3600.,
     $4400.,5200.,6000.,7000.,7800.,
     $92.,280.,500.,740.,1020.,1300.,1650.,2000.,2400.,2950.,3500.,
     $4100.,4900.,5800.,6800.,7800.,
     $90.,380.,740.,1120.,1550.,1950.,2450.,2950.,3500.,4000.,4600.,
     $5200.,5800.,6600.,7200.,7800.,
     $50.,289.,682.,1129.,1616.,2133.,2682.,3227.,3823.,4425.,5078.,
     $5714.,5906.,6526.,7156.,7800./
C
C    THESE SIZE CHANNEL VALUES ARE NOMINAL PMS VALUES.
      DATA size/
     $2.0,5.0,8.0,11.,14.,17.,20.,23.,26.,29.,32.,35.,38.,41.,44.,47.,
     $2.,4.,6.,8.,10.,12.,14.,16.,18.,20.,22.,24.,26.,28.,30.,32.,
     $1.,2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,12.,13.,14.,15.,16.,
     $.5,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,6.5,7.,7.5,8.0/
C    BEAM DIAMETER FOR RAF FSSP
      DATA BDIAM/0.18/,DOF/2.7/
C    ELECTRONIC RESPONSE TIME OF PROBE
      DATA TAUR/0.60/
C    THESE ARE NUMBER OF ROWS,COLUMNS, AND LENGTH INCREMENTS FOR THE
C    MAPPED RAF PROBE
      DATA MROW/18/,NCOL/18/,XDEL/.01/,YDEL/.01/
C    SMOOTHING COEFFICIENTS, PRESENTLY SET FOR NO SMOOTHING
      DATA A0/0.0/,A1/.0/,A2/0.0/
C    NUMBER OF TIMES TO SMOOTH SET TO 0
      DATA NSMTH/0/
      END
C     SIZE     -  THESE ARE THE SIZE THRESHOLDS FOR THE FOUR RANGES OF
C                 THE FSSP
C     A        -  THIS ARRAY CONTAINS THE INTENSITY DISTRIBUTION OF THE
C                 FSSP LASER BEAM
C     PHA      -  THESE ARE THE PULSE HEIGHT ANALYZER VOLTAGES OF THE
C                 FOUR RANGES OF THE FSSP
C     DOF      -  THIS IS THE FSSP DEPTH-OF-FIELD (MM)
C     BDIAM    -  THIS IS THE FSSP BEAM DIAMETER
C     TAUR     -  THIS IS THE TIME RESPONSE OF THE FSSP ELECTRONICS
C     TAUSLW   -  THIS IS THE FSSP SLOW RESET DELAY TIME
C     TAUFST   -  THIS IS THE FSSP FAST RESET DELAY TIME
C     NROW     -  THIS IS THE M NUMBER OF PATHS INTENSITY-MAPPED
C                 THROUGH THE BEAM
C     NCOL     -  THIS IS THE NUMBER OF DATA POINTS ALONG EACH PATH
C     XDEL     -  THIS IS THE DISTANCE BETWEEN EACH OF THE N DATA
C                 POINTS
C     YDEL     -  THIS THE DISTANCE BETWEEN EACH OF THE M PATHS
C                 MAPPED THROUGH THE BEAM. BDIAM = (MROW)(YDEL)
C                 IS A NECCESSARY CONDITION.
C
C THE COMMON BLOCK /INVRT/ CONTAINS VARIABLES THAT ARE USED BY THE
C SUBROUTINE FXFSP AND RETURNS INFORMATION ABOUT THE CORRECTED SPECTRA.
C THESE VARIABLES AND THEIR PURPOSE ARE AS FOLLOWS:
C
C     RSPNS    -   THIS IS THE RESPONSE MATRIX GENERATED BY THE
C                  SUBROUTINE 'VBIAS' AND DESCRIBES THE WAY THE
C                  ACTUAL SPECTRA IS DISTORTED BY THE OPTICAL AND
C                  ELECTRONIC RESPONSE OF THE PROBE
C
C     SIZES    -   THIS MATRIX STORES THE VOLTAGE GENERATED AS
C                  PARTICLES OF EACH SIZE CLASS PASS THROUGH EACH
C                  OF THE MAPPED PATHS THROUGH THE BEAM.
C
C     TRNSMN   -   THIS MATRIX STORES THE CALCULATED TRANSIT TIME
C                  GENERATED AS PARTICLES OF EACH SIZE CLASS PASS
C                  THROUGH EACH OF THE MAPPED PATHS THROUGH THE
C                  BEAM
C
C     TRNSAV   -   THIS MATRIX STORES THE CALCULATED AVERAGE TRANSIT
C                  TIME FOR EACH SIZE CLASS.
C
C     SPECM    -   THIS MATRIX STORES THE ACTUAL MEASURED COUNTS IN
C                  EACH CHANNEL OF THE PROBE
C
C     SPECA    -   THIS MATRIX STORES THE ESTIMATE OF THE ACTUAL
C                  SIZE DISTRIBUTION
C
C     SPCEST   -   THIS MATRIX STORES THE ESTIMATE OF THE MEASURED
C                  DISTRIBUTION (PRODUCT OF RESPONSE MATRIX AND
C                  SPECA.
C
C     EPS      -   THIS MATRIX STORES THE VALUES OF THE ERROR
C                  WEIGHTING VALUES USED IN CALCULATING TOTAL ERROR
C                  BETWEEN SPECM AND SPCEST
C
C     BMFRC    -   THIS MATRIX STORES THE CALCULATED BEAM FRACTION
C                  VALUES FOR EACH SIZE CLASS.
C
C     XF       -   THIS MATRIX CONTAINS THE RATIO OF SPECM/SPCEST
C
C     SIGMA    -   THIS THE THE COMPUTED CHI SQUARE STATISTIC
C
C     A0,A1,A2 -   THESE ARE THE WEIGHTING COEFFICIENTS TO USE IN
C                  THE SMOOTHING ALGORITHM. PRESENTLY SET TO 1,0,0
C                  FOR NO SMOOTHING.
C
C     NSMTH    -   THIS SETS THE NUMBER OF TIMES TO CALL SMOOTHING
C                  ALGORITHM.
C
C     MKSPC    -   This is a flag that allows the correction routine
C                  to be used in reverse. When MKSPC=1, then the
C                  spectrum of input counts is assumed to be the actual
C                  spectrum, and the response matrix is used to create
C                  a hypothetical measured spectrum that will be put
C                  in the array SPECM
C
C THE FSSP CORRECTION PROCEDURE IS COMPOSED OF FIVE SUBROUTINES AND
C ONE FUNCTION
C THESE SUBROUTINES AND THEIR DESCRIPTIONS ARE AS FOLLOWS:
C     FXFSP     -   THIS IS THE PRIMARY SUBROUTINE CALLED FROM A MAIN
C                   PROGRAM. THIS PROGRAM GENERATES THE NORMALIZED
C                   INTENSITY MATRIX, CREATES THE MATRICES 'SIZES',
C                   'TRNSMN' AND 'TRNSAV' AND CALL THE REMAINING
C                   ROUTINES TO PERFORM THE DATA INVERSION.
C
C     VBIAS     -   THIS SUBROUTINE GENERATES THE RESPONSE MATRIX.
C
C     TWOMY     -   THIS SUBROUTINE ESTIMATES THE ACTUAL SIZE
C                   DISTRIBUTION USING THE MEASUREMENTS AND RESPONSE
C                   MATRIX. THE MODIFIED TWOMY METHOD IS USED AS
C                   DESCRIBED BY MARKOWSKI, 1987: "IMPROVING TWOMEY'S
C                   ALGORITHM FOR INVERSION OF AEROSOL DATA. AEROSOL
C                   SCIENCE AND TECHNOLOGY, VOL. 7, PP127-141.
C
C     SIG       -   THIS SUBROUTINE CALCULATES THE CHI SQUARE ERROR
C                   BETWEEN THE MEASURED AND ESTIMATED MEASURED SPECTRA
C
C     SMOOTH    -   THIS SUBROUTINE SMOOTHES THE ESTIMATED ACTUAL
C                   DISTRIBUTION
C
C     EXTRP     -   THIS FUNCTION EXTRAPOLATES A VALUE BETWEEN TWO
C                   POINTS USING  POWER FIT TO THE TWO POINTS.
      SUBROUTINE FXFSP(SPEC,BF,TAS,IRNG,IDELAY)
C THIS SUBROUTINE IS CALLED WITH:
C     SPEC      -   THE ARRAY CONTAINING THE 15 CHANNELS OF RAW COUNTS
C
C     BF        -   THE MEASURED BEAM FRACTION IF AVAILABLE
C
C     TAS       -   True airspeed
C
C     IRNG      -   FSSP range (1-4)
C     IDELAY    -   THIS FLAG IS SET TO 0 IF DELAY LINE OPTION NOT USED,
C                   SET TO 1 OTHERWISE.
C
      COMMON /SETUP/size(16,4),A(20,20),PHA(16,4),DOF,BDIAM,
     $TAUR,TAUSLW,TAUFST,MROW,NCOL,XDEL,YDEL
      COMMON /INVRT/RSPNS,SIZES,TRNSMN,TRNSAV,SPECM,SPECA,SPCEST,EPS,
     1BMFRC,XF,SIGMA,A0,A1,A2,NSMTH,MKSPC
      REAL RSPNS(15,15),SIZES(50,15),TRNSMN(50,15),
     1BMFRC(15),TRNSAV(15),SPECM(15),SPECA(15),SPCEST(15),
     2EPS(15),XF(15)
c      COMMON AVGTRN,SPD,LRNG,VACPT
      COMMON /NEWCOM/AVGTRN,SPD,LRNG,VACPT
      REAL SPEC(15),V(50),SPCLST(15),zmx(50)
      DATA IFRST/0/,NITER/100/
      IF (BF.LE.0.0)BF=0.62
      tot=0.0
c      print 3, spec
    3 format(' fxfsp - spec ',15f7.1)
      IF (MKSPC.EQ.0)THEN
         DO 5 I=1,15
            SPECM(I)=SPEC(I)
	    tot=tot+spec(i)
5        CONTINUE
      ELSE
         DO 6 I=1,15
            SPECA(I)=SPEC(I)
	    tot=tot+spec(i)
6        CONTINUE
      END IF
      if (tot.eq.0.0)return
      ITER=0
      SPD=TAS
      LRNG=IRNG
C
C IF THIS IS THE FIRST TIME THIS SUBROUTINE HAS BEEN CALLED, NORMALIZE
C THE INTENSITY MATRIX AND DETERMINE THE AVERAGE MAXIMUM INTENSITY
       IF (IFRST.EQ.0)THEN
          IFRST=1
          TASLST=0
          IRLST=-1
          IDLST=-1
          AMN=1.0E10
          AMX=0.0
          DO 20 I=1,MROW
             DO 10 J=1,NCOL
                AMN=AMIN1(AMN,A(J,I))
                AMX=AMAX1(AMX,A(J,I))
10           CONTINUE
20        CONTINUE
c          print 21
21        format(' print after statement no 20')
          DO 40 I=1,MROW
             DO 30 J=1,NCOL
                difmxn= amx - amn
                if(difmxn.eq.0.0) difmxn = 0.001
                A(J,I)=(A(J,I)-AMN)/difmxn
c                A(J,I)=(A(J,I)-AMN)/(AMX-AMN)
30           CONTINUE
40        CONTINUE
c          print 41
41        format(' print after statement no 40')
      END IF
C
C IF THE TRUE AIRSPEED SPECIFIED IN THE CALL TO THE SUBROUTINE
C IS MORE THAN 20% DIFFERENT THAN THE PREVIOUS CALL, OR IF THE
C RANGE HAS CHANGED SINCE THE LAST CALL, THEN COMPUTE THE
C SIZING AND TRANSIT TIME ARRAYS FOR ALL SIZE CLASSES PASSING THROUGH
C ALL PATHS THROUGH THE BEAM.
      IF (IDLST.NE.IDELAY)IRLST=LRNG+1
      IF ((IRLST.LT.0).OR.(TASLST.EQ.0)) IRLST=LRNG+1
      if(spd.eq.0.0) spd=0.001
      IF ((IRLST.NE.LRNG).OR.(ABS((SPD-TASLST)/SPD).GE.0.2))THEN
         VR=PHA(1,LRNG)
         T1=XDEL*1000/SPD
         DO 200 ICH=1,15
	    diam=(size(ich,irng)+size(ich+1,irng))/2000.
	    rad=diam/2.0
            if(xdel.eq.0.0) xdel=0.001
	    imax=mrow+int(diam/xdel+.5)
	    do 170 j=1,imax
		sizes(j,ich)=0.0
170	    continue
c          print 171
171        format(' print after statement no 170')
            TRNSAV(ICH)=0.0
	    do 175 j=1,imax
		trnsmn(j,ich)=0.0
175	    continue
c          print 176
176        format(' print after statement no 175')
            SN=0.0
C FIND THE MIDPOINT OF THIS CHANNEL AND ESTIMATE PHA VOLTAGE BY
C EXTRAPOLATING BETWEEN THE END POINTS.
            X0=ICH
            X1=ICH+1
            X2=.5*(X0+X1)
            Y0=PHA(ICH,LRNG)
            Y1=PHA(ICH+1,LRNG)
            V0MAX=EXTRP(X0,X1,Y0,Y1,X2)
	    yoff=-rad+ydel/2.0
	    joff=0
	    ytop=ydel*(mrow-.5) + rad
            xtop=xdel*(ncol-0.5)+rad
6000	    if (yoff.le.ytop)then
c          print 6001
6001        format(' print after statement no 6000')
	       joff=joff+1
	       xoff=-rad+.5*xdel
	       ioff=0
	       jfrst=0
	       xdis=0
               T=0.0
               T0=0.0
               VMX=0.0
               VLAST=.00001
5500	       if (xoff.le.xtop)then
c          print 5501
5501        format(' print after statement no 5500')
		  ioff=ioff+1
		  ixfrst=0
c Calculate the integrated intensity profile for that portion of the particle
c in the beam over all the intersected laser beam intensity points
    		  x=xoff-rad+.5*xdel
		  ia=0
		  sumi=0.0
5400  		  if ((x.lt.xoff+rad).or.(ixfrst.eq.0))then
c          print 5401
5401        format(' print after statement no 5400')
		     ixfrst=1
                     if(xdel.eq.0.0) xdel=0.001
		     ix=int(x/xdel)+1
		     if ((ix.gt.0).and.(ix.le.ncol))then
			y0=rad**2-(x-xoff)**2
			if (y0.ge.0)then
			   y1=yoff+sqrt(y0)
			   y0=yoff-sqrt(y0)
			else
			   y0=yoff
			   y1=yoff
			end if
			if (diam.lt.(2*xdel))then
				y0=yoff
				y1=yoff
			end if
                        if(ydel.eq. 0.0) ydel=0.001
			iy0=int(y0/ydel)
			iy1=int(y1/ydel)
			if (iy0.lt.1)iy0=1
			if (iy1.gt.mrow)iy1=mrow
			if (iy1.gt.1)then
			   ia=ia+iy1-iy0+1
			   do 5300 ic=iy0,iy1
				sumi=sumi+a(ic,ix)
5300			  continue
c          print 5301
5301        format(' print after statement no 5300')
			end if
		    end if
		    x=x+xdel
		    goto 5400
		  end if
c Now adjust summed up intensities by the fraction of the area of the particle
c actually in the beam
		  if (diam.gt.xdel)then
                     if(ia.eq.0) ia=1
			if (ia.gt.0)sumi=sumi/ia
		  end if
C CALCULATE THE INTENSITY AT THIS POINT, ADJUSTED WITH THE AVERAGE
C INTENSITY CALCULATED ABOVE.
5800              Z=sumi*V0MAX
                  IF (JFRST.EQ.0)THEN
                        JFRST=1
C ADJUST FOR RESPONSE TIME
                        if(taur.eq. 0.0) taur=0.001
                        VOUT=Z*(1.0-EXP(-T1/TAUR))
                        T=T1
                  ELSE
                        XDIS=XDIS+XDEL
                        if(spd.eq. 0.0) spd=0.001
                        T=XDIS*1000./SPD
                        C=Z-VLAST
                        if(taur.eq.0.0) taur = 0.001
                        VOUT=VLAST + C * (1.0-EXP(-T1/TAUR))
                  END IF
                  VLAST=VOUT
		  v(ioff)=vout
C CHECK FOR THE START OF THE TRANSIT GATE IF THE DELAY LINE IS NOT
C INSTALLED.
                  IF ((IDELAY.EQ.0).AND.(VOUT.GE.VR))THEN
                        IF (T0.EQ.0.0)T0=T
                  END IF
                  VMX=AMAX1(VMX,VOUT)
		  xoff=xoff+xdel
		  goto 5500
	      end if
              IF (VMX.LT.VR)then
		 t=0
                 SIZES(joff,ICH)=0
		 GOTO 100
	      end if
C STORE THE MAXIMUM VALUE FOUND DURING THIS PASS
                 SIZES(joff,ICH)=vmx
C AND SOLVE FOR THE END OF THE TRANSIT TIME
C IF THE DELAY LINE IF ACTIVATED, FIRST DETERMINE WHERE FULL WIDTH
C HALF MAXIMUM WAS AND CALCULATE ELAPSED TIME SINCE HALF MAXIMUM
C WAS EXCEEDED
               IF (IDELAY.EQ.1) THEN
                  if(spd.eq.0.0) spd=0.001
                  DO 80 J=1,ioff
                     IF (V(J).GE.0.5*VMX)GOTO 85
80                CONTINUE
c          print 81
81        format(' print after statement no 80')
85                T0= 1000.*J*XDEL/SPD
               END IF
                  if(vlast.eq. 0.0) vlast=0.001
                  if(vr.eq. 0.0) vr=0.1
                  if(vmx.eq.0.0) vmx=0.1
               IF (IDELAY.EQ.0)THEN
                  T2=-TAUR*ALOG(VR/VLAST) + T
               ELSE
                  T2=-TAUR*ALOG(.5*VMX/VLAST) + T
               END IF
               IF (T0.gt.0.0)then
C THE FSSP MEASURES THE TRANSIT TIME OF EACH INDIVIDUAL PARTICLE BY
C STORING THE NUMBER OF CLOCK PULSES FROM A 10 MHZ OSCILLATOR THAT
C OCCUR DURING THE TRANSIT PERIOD. THIS EFFECTIVELY ROUNDS OFF THE
C VALUE AND CAN BE IMPORTANT AT FASTER AIRSPEEDS. THIS EFFECT IS
C SIMULATED HERE
                  T=0.1+INT(.5+(T2-T0)*10)/10.
		  if (t.lt.0.5)t=0.5
                  TRNSMN(joff,ICH)=T
                  TRNSAV(ICH)=TRNSAV(ICH)+T
                  SN=SN+1
               END IF
100	       continue
c          print 101
101        format(' print after statement no 100')
c	       write(66,8830)ich,joff,yoff,sizes(joff,ich),t,sn
               yoff=yoff+ydel
8830	format(2i3,3f7.2,f4.0)
	       goto 6000
	    end if
            IF (SN.GT.0.0)THEN
               if(sn.eq.0.0) sn=0.001
               TRNSAV(ICH)=TRNSAV(ICH)/SN
            ELSE
               TRNSAV(ICH)=0.0
            END IF
200      CONTINUE
c          print 201
201        format(' print after statement no 200')
      END IF
          TASLST=TAS
          IRLST=IRNG
          IDLST=IDELAY
C IF THIS ROUTINE IS BEING CALLED IN ORDER TO CREATE AN ESTIMATED
C MEASURED DISTRIBUTION FROM AN ACTUAL DISTRIBUTION, GENERATE
C THE RESPONSE MATRIX, THEN CREATE AN ESTIMATE OF THE MEASURED
C DISTRIBUTION BEFORE CLEARING TEST FLAG AND CONTINUING NORMALLY.
      IF (MKSPC.GT.0)THEN
         DO 150 I=1,15
            DO 140 J=1,15
               RSPNS(I,J)=0.0
140         CONTINUE
150      CONTINUE
c          print 151
151        format(' print after statement no 150')
         CALL VBIAS
         CALL SIG
         DO 205 I=1,15
            SPECM(I)=SPCEST(I)
205      CONTINUE
         MKSPC=0
      ELSE
      END IF
C AS A FIRST GUESS OF THE ACTUAL DISTRIBUTION, SET THE ESTIMATED
C SPECTRUM EQUAL TO 25% of two channels smaller and 75% of one channel
c smaller, and divide by the beam fraction
      DO 210 I=15,1,-1
	 if (i.lt.3)then
		speca(i)=0.05*specm(i)
	 else
                if(bf.eq.0.0) bf=0.001
         	SPECA(I)=(0.25*SPECM(I-2)+0.75*specm(i-1))/BF
	 end if
         SPCLST(I)=SPECA(I)
210   CONTINUE
c          print 211
211        format(' print after statement no 210')
C BEGIN THE ITERATION LOOP TO DETERMINE THE REAL DISTRIBUTION
      SIGLST=1.0E32
      DO 400 ITER=1,NITER
         DO 250 I=1,15
            DO 240 J=1,15
               RSPNS(I,J)=0.0
240         CONTINUE
250      CONTINUE
C CALL THE SUBROUTINE THAT CALCULATES RESPONSE MATRIX
	tot=0.0
	do 251 i=1,15
	   tot=tot+speca(i)
251	continue
	if (tot.eq.0)goto 400
         CALL VBIAS
C THEN CALL INVERSION ROUTINE
         CALL TWOMY
C BEFORE CONTINUING FURTHER, SEE IF SOLUTION CONVERGED, IF NOT
C THEN EXIT AFTER SETTING IDELAY=-1
         IF (SIGMA.LT.0.0)THEN
            IDELAY=-1
            RETURN
         END IF
C THIS NEW ESTIMATE OF THE ACTUAL DISTRIBUTION MUST BE USED TO
C ESTIMATE A NEW AVERAGE TRANSIT TIME, HENCE NEW BEAM FRACTIONS,
C AND THUS A NEW RESPONSE MATRIX. IF THE VELOCITY ACCEPTANCE FRACTION
C DOES NOT CHANGE FROM THE PREVIOUS AMOUNT BY MORE THAN 1%, THEN
C END ITERATIONS
         if(siglst.eq. 0.0) siglst= 0.001
         DF=ABS((SIGMA-SIGLST)/SIGLST)
C IF THE ERROR THIS TIME THROUGH IS GREATER THAN PREVIOUS TIME, THEN
C EXIT SUBROUTINE AFTER RESTORING PREVIOUS SPECTRUM, ALSO EXIT IF
C SIGMA IS <.1 OR CHANGE IN SIGMA LESS THAN 1%.
         IF (SIGMA.LE.0.1)GOTO 500
         IF ((SIGMA.GE.SIGLST).OR.(DF.LE..01))THEN
            DO 260 I=1,15
               SPECA(I)=SPCLST(I)
260         CONTINUE
            GOTO 500
         ELSE
            SIGLST=SIGMA
            DO 270 I=1,15
               SPCLST(I)=SPECA(I)
270         CONTINUE
         END IF
C CONTINUE ITERATING SINCE THIS NEW ESTIMATE OF THE SPECTRUM MUST BE
C USED TO COMPUTE A NEW BEAM ACCEPTANCE FRACTION FOR EACH CHANNEL AND
C THUS A NEW RESPONSE MATRIX.
400   CONTINUE
c          print 401
401        format(' print after statement no 400')
C REPLACE THE OLD DISTRIBUTION WITH THE NEW ESTIMATE.
500   DO 510 I=1,15
         SPEC(I)=SPECA(I)
510   CONTINUE
c      print 511, spec
511   format(' end of fxfsp-spec ',15f7.1)
      RETURN
      END
C SUBROUTINE VBIAS
C THIS SUBROUTINE GENERATES THE FSSP RESPONSE MATRIX TO BE USED IN
C DETERMINING THE ACTUAL SIZE DISTRIBUTION FROM MEASURED DISTRIBUTIONS
      SUBROUTINE VBIAS
      COMMON /SETUP/size(16,4),A(20,20),PHA(16,4),DOF,BDIAM,
     $TAUR,TAUSLW,TAUFST,MROW,NCOL,XDEL,YDEL
      COMMON /INVRT/RSPNS,SIZES,TRNSMN,TRNSAV,SPECM,SPECA,SPCEST,EPS,
     1BMFRC,XF,SIGMA,A0,A1,A2,NSMTH,MKSPC
      REAL RSPNS(15,15),SIZES(50,15),TRNSMN(50,15),
     1BMFRC(15),TRNSAV(15),SPECM(15),SPECA(15),SPCEST(15),
     2EPS(15),XF(15)
      COMMON /NEWCOM/AVGTRN,SPD,LRNG,VACPT
      TOT=0.0
      VACPT=0.0
      DO 10 I=1,15
         TOT=TOT+SPECA(I)
10    CONTINUE
      if (tot.eq.0)return
C THE AVERAGE TRANSIT TIME IS GENERATED AS THE AVERAGE OF THE TRANSIT
C TIME OF EACH SIZE CHANNEL WEIGHTED BY THE NUMBER OF COUNTS IN THAT
C SIZE CHANNEL.
      AVGTRN=0.0
      DO 20 I=1,15
       if(tot.eq.0.0) tot=0.001
         AVGTRN=AVGTRN+SPECA(I)*TRNSAV(I)/TOT
20    CONTINUE
C
C USE THIS AVERAGE TO DETERMINE THE BEAM FRACTION FOR EACH SIZE,
C I.E. FIND WHAT FRACTION OF THE BEAM DIAMETER A PARTICLE OF A
C PARTICULAR SIZE WILL HAVE A TRANSIT TIME THAT IS GREATER THAN OR
C EQUAL TO THE AVERAGE.
      DO 200 ICH=1,15
	 sz=(size(ich,lrng)+size(ich+1,lrng))/2000.
         if(ydel.eq.0.0) ydel=0.001
	 imax=mrow+int(.5+sz/ydel)
         if(mrow.eq.1) mrow=2
         if(sz.eq.0.0) sz=0.001
	 frc=ydel/(ydel*(mrow-1)+sz)
         DIS=0.0
c	 write(66,8628)((sizes(i,j),j=1,15),i=1,20)
8628	 format(20(15f5.0/))
         DO 100 IC=1,imax
C FIND WHAT SIZE CHANNEL THIS PARTICLE WOULD FALL IN WHEN PASSING
C THROUGH THIS CHORD OF THE BEAM AT THE GIVEN AIRSPEED.
            DO 50 J=1,16
               IF (SIZES(IC,ICH).LT. PHA(J,LRNG))GOTO 60
50          CONTINUE
60          J=J-1
            T=TRNSMN(IC,ICH)
            IF ((T.GT.AVGTRN).and.(j.gt.0)) THEN
               DIS=DIS+YDEL
               RSPNS(J,ICH)=RSPNS(J,ICH)+frc
c	       if (ich.eq.15)write(66,8611)ic,T,j,sizes(ic,ich),
c    $pha(j+1,lrng),rspns(j,ich)
8611	format(i3,f5.2,i3,3f10.4)
            ELSE
            END IF
100      CONTINUE
C TRANSLATE ACCEPTANCE DISTANCE INTO BEAM FRACTION
         if(bdiam.eq.0.0) bdiam=0.001
         BMFRC(ICH)=DIS/BDIAM
         if(tot.eq.0.0) tot=0.001
         VACPT=VACPT+SPECA(ICH)*BMFRC(ICH)/TOT
200   CONTINUE
c	 write(66,8294)bmfrc
8294	 format(15f5.3)
c	write(66,8488)avgtrn,trnsav,bmfrc,((trnsmn(i,j),j=1,15),i=1,imax)
8488	format(f8.3/15f5.2/15f5.2/24(15f5.2/))
c	write(66,8700)speca
c	do 300 i=1,15
c		write(66,8705)(rspns(i,j),j=1,15)
8705	format(15f5.2)
300	continue
8700	format(15f5.0)
      RETURN
      END
      SUBROUTINE TWOMY
C THIS SUBROUTINE ESTIMATES THE ACTUAL DISTRIBUTION USING THE RESPONSE
C MATRIX OF THE INSTRUMENT AND THE MEASURED DISTRIBUTION
      COMMON /SETUP/size(16,4),A(20,20),PHA(16,4),DOF,BDIAM,
     $TAUR,TAUSLW,TAUFST,MROW,NCOL,XDEL,YDEL
      COMMON /INVRT/RSPNS,SIZES,TRNSMN,TRNSAV,SPECM,SPECA,SPCEST,EPS,
     1BMFRC,XF,SIGMA,A0,A1,A2,NSMTH,MKSPC
      REAL RSPNS(15,15),SIZES(50,15),TRNSMN(50,15),
     1BMFRC(15),TRNSAV(15),SPECM(15),SPECA(15),SPCEST(15),
     2EPS(15),XF(15)
      COMMON /NEWCOM/AVGTRN,SPD,LRNG,VACPT
	real spclst(15)
      SIGLST=1.0E32
      RLST=1.0E10
      IFRST=0
C COMPUTE THE CORRECTION VECTORS AND CHI SQUARE STATISTIC
      DO 500 ITER=1,100
10    CALL SIG
      if(siglst.eq.0.0) siglst=0.001
      CHK=ABS((SIGMA-SIGLST)/SIGLST)
C GENERATE THE NEW ESTIMATE OF THE ACTUAL SPECTRA USING THE CORRECTION
C VECTORS
      DO 50 I=1,15
         SPCLST(I)=SPECA(I)
         SUM=1.0
         DO 30 J=1,15
            SUM=SUM + (XF(J)-1.0)*RSPNS(J,I)
30       CONTINUE
         SPECA(I)=SPCLST(I)*SUM
50       CONTINUE
C IF THE ERROR IS GREATER THAN ONE BUT STILL DECREASING, THEN REPEAT
C THIS STEP, OTHERWISE GO TO THE SMOOTHING STEP NEXT
      IF ((SIGMA.LE..5).OR.(CHK.LE..01).OR.(SIGMA.GT.SIGLST))THEN
         IF (SIGMA.GT.SIGLST)THEN
            DO 45 I=1,15
               SPECA(I)=SPCLST(I)
45          CONTINUE
         ELSE
         END IF
         IF (NSMTH.EQ.0)RETURN
C NOW EITHER SMOOTH THE ESTIMATED SPECTRA A SPECIFIC NUMBER OF TIMES,
C OR UNTIL THE CHI SQUARE IS WORSE THAN PREVIOUS TIME
         SIGLST=SIGMA
         DO 100 I=1,NSMTH
            CALL SMOOTH(R)
            CALL SIG
            IF (SIGMA.GT.SIGLST)GOTO 120
100      CONTINUE
120      IF (IFRST.EQ.0)THEN
            IFRST=1
            RLST=R
         ELSE
            if(rlst.eq.0.0) rlst=0.001
            DIFF =ABS((R-RLST)/RLST)
            IF ((DIFF.LT. .1).OR. (R.GT.RLST))RETURN
            RLST=R
         END IF
         SIGLST=1.0E32
      ELSE
      END IF
500   SIGLST=SIGMA
C SET SIGMA TO -1 TO SIGNIFY THAT SOLUTION DID NOT CONVERGE
      SIGMA=-1
      RETURN
      END
      SUBROUTINE SMOOTH(R)
C THIS SUBROUTINE SMOOTHS THE ESTIMATED SPECTRA WITH WEIGHTING FACTORS
C CONTAINED IN A0,A1, AND A2
      COMMON /SETUP/size(16,4),A(20,20),PHA(16,4),DOF,BDIAM,
     $TAUR,TAUSLW,TAUFST,MROW,NCOL,XDEL,YDEL
      COMMON /INVRT/RSPNS,SIZES,TRNSMN,TRNSAV,SPECM,SPECA,SPCEST,EPS,
     1BMFRC,XF,SIGMA,A0,A1,A2,NSMTH,MKSPC
      REAL RSPNS(15,15),SIZES(50,15),TRNSMN(50,15),
     1BMFRC(15),TRNSAV(15),SPECM(15),SPECA(15),SPCEST(15),
     2EPS(15),XF(15)
      COMMON /NEWCOM/AVGTRN,SPD,LRNG,VACPT
      REAL SPCTMP(15)
      DO 50 I=2,14
         SPCTMP(I)=A1*SPECA(I-1)+A0*SPECA(I)+A1*SPECA(I+1)
50    CONTINUE
      SPCTMP(1)=A0*SPECA(1)+A2*SPECA(2)
      SPCTMP(15)=A0*SPECA(15)+A2*SPECA(14)
      R=0
      DO 100 I=1,15
         SPECA(I)=SPCTMP(I)
         IF ((I.GT.1).AND.(I.LT.15))THEN
            R=R+ABS(SPECA(I+1)+SPECA(I-1)-2.0*SPECA(I))
         ELSE
         END IF
100   CONTINUE
      R=R/13.0
      RETURN
      END
      SUBROUTINE SIG
C THIS SUBROUTINE CALCULATES THE CORRECTION VECTORS AND THE CHI SQUARE
C STATISTIC
      COMMON /SETUP/size(16,4),A(20,20),PHA(16,4),DOF,BDIAM,
     $TAUR,TAUSLW,TAUFST,MROW,NCOL,XDEL,YDEL
      COMMON /INVRT/RSPNS,SIZES,TRNSMN,TRNSAV,SPECM,SPECA,SPCEST,EPS,
     1BMFRC,XF,SIGMA,A0,A1,A2,NSMTH,MKSPC
      REAL RSPNS(15,15),SIZES(50,15),TRNSMN(50,15),
     1BMFRC(15),TRNSAV(15),SPECM(15),SPECA(15),SPCEST(15),
     2EPS(15),XF(15)
      COMMON /NEWCOM/AVGTRN,SPD,LRNG,VACPT
      SIGMA=0.0
      DO 100 I=1,15
         SUMY=0.0
         DO 50 J=1,15
            SUMY=SUMY+RSPNS(I,J)*SPECA(J)
50       CONTINUE
         IF (SUMY.GT.0.0)THEN
            XF(I)=SPECM(I)/SUMY
         ELSE
            XF(I)=0
         END IF
         SPCEST(I)=SUMY
C SET THE ERROR WEIGHTING FACTOR TO 10%  OF THE MEASURED RAW COUNTS
         EPS(I)=.100*SPECM(I)
         IF (EPS(I).LT.1.0)EPS(I)=1.0
         SIGMA=SIGMA+((SPECM(I)-SPCEST(I))/EPS(I))**2
100   CONTINUE
      SIGMA=SIGMA/15.
      RETURN
      END
      FUNCTION EXTRP(X0,X1,Y0,Y1,X)
C THIS FUNCTION FITS POWER CURVE TO X0,X1,Y0,Y1 AND DETERMINES VALUE
C OF FUNCTION FOR INPUT VALUE OF X
       if(y0.eq.0.0) y0=0.001
       if(x0.eq.0.0) x0=0.001
       if(y1.eq.0.0) y1=0.1
       if(x1.eq.0.0) x1=0.1
c
      SLP=ALOG(Y1/Y0)/ALOG(X1/X0)
      XINT=EXP(ALOG(Y0)-SLP*ALOG(X0))
      EXTRP=XINT*X**SLP
      RETURN
      END
C -----------------------------------------------------------
C  PROJECT 2-816 ASTEX/MAGE Mods:  October 1992  RLR
C   This change only affects some of the variable names
C      Old        New        Description
C     XSUMX6 --> SUM626:   Sum of all counts
C     XPLWC6 -->  PLWC6:   Calculated liquid water content (g/m3)
C     XCONC6 -->  CONC6:   Concentration (#/liter)
C     XDBAR6 -->  DBAR6:   Mean particle diameter
C     XDBZ6  -->   DBZ6:   Calculated radar reflectivity
C     XDISP6 -->  DISP6:   Dispersion
C
C  PROJECT 1-276 CaPE Mods:  October 1991  RLR
C   This change is cosmetic to reflect the actual data returned by the routine.
C  PROJECT 876 HaRP MODS:                    Nov. 1990  -CC
C  This PMS-1D 260X probe processor includes Darrel Baumgardner's newest mods
C  to correct (fix) the accumulated raw counts and the concentrations
C
C  Darrel's black box contains the subroutine:  FXOAP
C
C The input parameters required for this processor are:
C  1. TIME (seconds)
C  2. TAS  (m/s3)
C  3. 260X data block  (though not declared in CALIB via LETVAR statement)
C
C This subroutine will produce the following output data set, by request
C  1. ACC260H: A data block of raw counts at high rate (If the 260X data
C              come in at high rate)
C  2. ACC260L:  Data block of raw accumulated counts @ 1/s
C  3. XACC260L: Data block of corrected raw accumulated counts @ 1/s
C  4. XCON260L: Data block of concentrations from corrected raw counts @ 1/s
C  5. XSUMX6:   Sum of all counts
C  6. XPLWC6:   Calculated liquid water content (g/m3)
C  7. XCONC6:   Concentration (#/liter)
C  8. XDBAR6:   Mean particle diameter
C  9. XDBZ6:    Calculated radar reflectivity
C 10. XDISP6:   Dispersion
C ----------------------------------------------------------------------------
C
      SUBROUTINE SX260
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
      DIMENSION SMKN(64),SMCON(64),RCOUNT(64),CONC(64)
      INTEGER ALABX(5),ALABY(5),CLABX(5),CLABY(5)
      COMMON/HIST/LT(5),NCELLS,SIZE(64),NSIZE
      COMMON/PX260/NCSUM6,THRESH6,MRATE6,MWORD6,MCELL6,SIZE6
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
C     DATA NSUMX6/8HXSUMX6  /,  NACC260H /8HACC260H /
      DATA NSUMX6/8HSUM626  /,  NACC260H /8HACC260H /
      DATA NACC260L/8HACC260L /
      DATA NXCC260L/8HXACC260L/,NCON260L/8HXCON260L/
C     DATA NX6LWC /8HXPLWC6  /, NX6DBZ/8HXDBZ6   /
C     DATA NAX260 /8HAX260   /, NCX260/8HCX260   /
C     DATA NX6CONC/8HXCONC6  /,NX6DBAR/8HXDBAR6  /,NX6DISP /8HXDISP6  /
      DATA NX6LWC /8HPLWC6   /, NX6DBZ/8HDBZ6    /
      DATA NAX260 /8HAX260   /, NCX260/8HCX260   /
      DATA NX6CONC/8HCONC6   /,NX6DBAR/8HDBAR6   /,NX6DISP /8HDISP6   /
C     PRINT 1234,  NSTAGE
C1234 FORMAT (' X260 called. NSTAGE ='I23)
      IPRAW = INDGET
C--------------------------------------------------------------------
C       ACCESS THE FUNCTION CONTROLS
C DEFFUN=1-NAMFUN;                2-PMS PLT NSIZE;
C        3-PMS PLT LOGLIN,4-PMS PLT MGRY;5-PMS PLT MINRY;6-PMS PLT BOT;
C        7-PMS PLT TOP; 8-PMS PLT LABX; 9-PMS PLT LABY
      INDST =3
.USE  INDEX
C     CALL CPRINT(0,6,128,8,5,DUM,0)
      IOF01= ICON(INDOFF+ 1)
      IOF02= ICON(INDOFF+ 2)
      IOF03= ICON(INDOFF+ 3)
      IOF04= ICON(INDOFF+ 4)
      IOF05= ICON(INDOFF+ 5)
      IOF06= ICON(INDOFF+ 6)
      IOF07= ICON(INDOFF+ 7)
      IOF08= ICON(INDOFF+ 8)
      IOF09= ICON(INDOFF+ 9)
C
      DO (I=1,NUMVEC)
       IND = INDVAL+LENCON*(I-1)
       NAMFUN= ICON( IND+ IOF01)
       NSIZE = ICON( IND+ IOF02)
C AX260  ---------------------------------------------
       IF(NAMFUN.EQ.NAX260   )
        LLA   = ICON( IND +IOF03)
        IF(LLA.LT.0 .OR. LLA.GT.2) LLA=0
        MGRYA = ICON( IND+ IOF04)
        MINRYA= ICON( IND +IOF05)
        BA    =  CON( IND+ IOF06)
        TA    =  CON( IND +IOF07)
        DO(IL=1,5)
          ALABX(IL)  = ICON(IND+IOF08+IL-1)
          ALABY(IL)  = ICON(IND+IOF09+IL-1)
        END DO
       END IF
C CX260  ------------------------------------------------
       IF(NAMFUN.EQ.NCX260    )
        LLC   = ICON( IND +IOF03)
        IF(LLC.LT.0 .OR. LLC.GT.2) LLC=0
        MGRYC = ICON( IND+ IOF04)
        MINRYC= ICON( IND +IOF05)
        BC    =  CON( IND+ IOF06)
        TC    =  CON( IND +IOF07)
        DO(IL=1,5)
          CLABX(IL)  = ICON(IND+IOF08+IL-1)
          CLABY(IL)  = ICON(IND+IOF09+IL-1)
        END DO
       END IF
      END DO
C
C       ACCESS THE VARIABLE CONTROLS
      INDST =2
.USE  INDEX
C      CALL CPRINT(0,6,128,8,5,DUM,0)
      IOFF01= ICON(INDOFF+  1)
      IOFF02= ICON(INDOFF+  2)
      IOFF03= ICON(INDOFF+  3)
      IOFF04= ICON(INDOFF+  4)
      IOFF05= ICON(INDOFF+  5)
      DO (K=1,NUMVEC)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR=ICON(IND +IOFF01)
       INDGET   = ICON(IND+IOFF02)
       INRATE   = ICON(IND+IOFF03)
       INDPUT   = ICON(IND+IOFF04)
       LRATE = ICON(IND+IOFF05)
       IF(NAMVAR .EQ. NACC260H) IPACCH  = INDPUT - 1
       IF(NAMVAR .EQ. NACC260L) IPACCL  = INDPUT - 1
       IF(NAMVAR .EQ. NXCC260L) IPACCLX = INDPUT - 1
       IF(NAMVAR .EQ. NCON260L) IPCONCL = INDPUT - 1
       IF(NAMVAR .EQ. NSUMX6)   IPSUMX6 = INDPUT - 1
       IF(NAMVAR .EQ. NX6CONC)  IPX6CON = INDPUT - 1
       IF(NAMVAR .EQ. NX6DBAR)  IPX6DBA = INDPUT - 1
       IF(NAMVAR .EQ. NX6DISP)  IPX6DIS = INDPUT - 1
       IF(NAMVAR .EQ. NX6DBZ )  IPX6DBZ = INDPUT - 1
       IF(NAMVAR .EQ. NX6LWC )  IPX6LWC = INDPUT - 1
      END DO
C-----------------------------
C  ***** INITIALIZATION FOR A NEW CASE
      IPTIME= IPSOU(1) - 1
      IPTAS = IPSOU(2) - 1
      IPQC1 = IPQC1
      IPQC2 = IPQC2
      SECSUM = CONS1
      IF(NSTAGE.EQ.4) NUMSMP=0
C  Start Diagnostic
C     IF(NSTAGE.EQ.4)
C       WRITE (6,1234) IPACCH, IPACCL, IPACCLX, IPCONCL, IPSUMX6,
C    &                 IPX6CON, IPX6DBA, IPX6DIS, IPX6DBZ, IPX6LWC,
C    &                 IPTIME, IPTAS, NCSUM6, MRATE6, MWORD6, MCELL6,
C    &                 THRESH6, SECSUM, SIZE6
C1234   FORMAT (
C    &"  SX260:  IPACCH, IPACCL, IPACCLX, IPCONCL, IPSUMX6 ="5I8/
C    &"          IPX6CON, IPX6DBA, IPX6DIS, IPX6DBZ, IPX6LWC ="5I8/
C    &"          IPTIME, IPTAS, NCSUM6, MRATE6, MWORD6, MCELL6 ="6I8/
C    &"          THRESH6, SECSUM, SIZE6 ="3G15.7)
C     END IF
C  End Diagnostic
      LDO = NCDO
C
C PMS 1-D PROBE X260 DATA PROCESSING
C INPUT INFORMATION REQUIRED:
C   1. PMS BLOCK SIZE IN WORDS              MSIZE
C   2. PMS BLOCK SAMPLING RATE              MRATE
C   3. NO. OF WORDS PER SAMPLE              MWORD
C   4. NO. OF SIZE CELLS                    NCELLS
C   5. FIRST ADDRESS OF THE PMS BLOCK*NCDO  IPRAW
C PMS BLOCK STRUCTURE
C-----------------------------------------------------------------------
C|SAMPLE ONE: WD1.SPARE ;WD2.SPARE;WD3.SPARE;WD4.SPARE;WD5.SPARE;
C|            WD6.CELL 0;WD7-WD68.CELL 1-62;WD69-WD70.FILL
C----------------------------------------------------------------------
C ASSUMING PMS DATA COMING IN TO THIS ROUTINE AS (PMS BLOCK) * NCDO
C DATA() IS THE DATA ARRAY TO PICK UP PMS BLOCK DATA
C INDGET IS THE INDEX TO PICK UP THE FIRST WORD OF PMS BLOCK FROM DATA()
C
C     if(nstage.eq.4) print 11,mword6,mrate6
C  11 format(' X260: mword6,mrate6',2i8)
      MSIZE= MRATE6 * MWORD6
      KCELL = 7
      KTL = 0
      KTLX = 0
      KTH = 0
C
C LOOP OVER THE TOTAL NUMBER OF CYCLES TO PROCESS
C
      IRTAS = LRTSOU(2)
      IRQC1 = LRTQC1
      IRQC2 = LRTQC2
      DO (IX=1,LDO)
       IQC1 = (IX-1)*IRQC1
       IQC2 = (IX-1)*IRQC2
       QC1 = DATA(IPQC1+IQC1)
       QC2 = DATA(IPQC2+IQC2)
       ITAS = (IX-1)*IRTAS
       DIST1 = DATA(IPTAS+ITAS)
       IF(DIST1.EQ.0.0) DIST1 = 1.0
       TIME = DATA(IPTIME+IX)
C** PRINT OUT THE RAW DATA POINTS-----------------
C      IZ1 = IPRAW + (IX-1)*MSIZE
C      IZ2 = IZ1+MSIZE-1
C      IF(NSTAGE.EQ.4)PRINT 21,TIME,MSIZE,IX,(DATA(IM),IM=IZ1,IZ2)
C  21  FORMAT(' X260:TIME,MSIZE,IX,CELLS ',F9.1,2I8,/,(14F6.0))
C
        X6CONC = 0.0
        X6DBAR = 0.0
        X6DBAR2= 0.0
        X6DBZ = -30.
        Z = 0.0
        DI = 0.0
        X6LWC = 0.0
        ACONC = 0.0
        do (k=1,64)
         rcount(k)=0.0
         conc(k)=0.0
        end do
C
C LOOP OVER THE SAMPLING RATE MRATE
       DO(IY= 1,MRATE6)
        INDX1 = IPRAW + ((IX-1)*MSIZE) + ((IY-1)*MWORD6)
        INDEX7 = INDX1 + KCELL -1
        SUMX6 = 0.0
        IND2 = INDEX7 + 64 -1
C      IF(NSTAGE.EQ.4)PRINT 20,TIME,IX,IY,(DATA(M),M=INDEX7,IND2)
C      PRINT 20,TIME,IX,IY,(DATA(M),M=INDEX7,IND2)
C  20  FORMAT(' X260:TIME,IX,IY,CELLS ',F9.1,2I8,/,(32F4.0))
        DO(ICELL=1,MCELL6)
         INDEX = INDEX7 + ICELL - 1
         RC = DATA(INDEX)
         IF(RC.LE.0.) RC=0.0
         RCOUNT(ICELL)= RCOUNT(ICELL)+RC
         KTH = KTH + 1
         IF(IPACCH.GT.0) DATA(IPACCH + KTH) = RC
C
C** SUM UP THE RAW COUNTS FOR THE PROBE
C        SUMX6 = SUMX6 + RCOUNT(ICELL)
        END DO
       END DO
       DO(ICELL=1,MCELL6)
        KTL = KTL + 1
        IF(IPACCL .GT. 0) DATA(IPACCL+KTL) = RCOUNT(ICELL)
C** ACCUMULATE FOR HISTOGRAMS: RAW COUNTS - Jan. 11,1991 (DB)
         SMKN(ICELL) = SMKN(ICELL)+RCOUNT(ICELL)
       END DO
C
C      IF(NSTAGE.EQ.4)PRINT 22,TIME,RCOUNT
C      PRINT 22,TIME,RCOUNT
C  22  FORMAT(' X260(before fxoap call):TIME,CELLS ',F9.1,/,(10F9.1))
C
C ** Call Darrel's Black Box here
       T = 1.
       RES = 10.
       IPRB = 1
       NDIOD = 64
       CALL FXOAP(RCOUNT,CONC,DIST1,T,RES,IPRB,NDIOD,MCELL6)
C      IF(NSTAGE.EQ.4)PRINT 23,TIME,RCOUNT
C      PRINT 23,TIME,RCOUNT
C  23  FORMAT(' X260(after fxoap call):TIME,CELLS ',F9.1,/,(10F9.1))
C
        SUMX6 = 0.0
        DO(ICELL=1,MCELL6)
         KTLX = KTLX + 1
C** Summing up the corrected counts for the probe
C**  ##########  For 2-816 ASTEX/MAGE, ignore the first cell.
         IF (ICELL.NE.1) SUMX6 = SUMX6 + RCOUNT(ICELL)
         IF(IPCONCL .GT. 0) DATA(IPCONCL+KTLX) = CONC(ICELL)
         IF(IPACCLX .GT. 0) DATA(IPACCLX+KTLX) = RCOUNT(ICELL)
C
C   D IS THE CELL DIAMETER IN MICROMETERS (E-6 METERS)
C   DIST1 IS TRUE AIRSPEED (M/S)
         D = ICELL * SIZE6
C
C** ZERO CONC BEFORE TAKEOFF
         IF(QC1.LT.10.0.AND.QC2.LT.10.0) CONC(ICELL)=0.0
         ACONC = ACONC + CONC(ICELL)
C
C** ACCUMULATE FOR HISTOGRAMS CONCENTRATIONS, SIZE()
C         SMKN(ICELL) = SMKN(ICELL)+RCOUNT(ICELL)
         SMCON(ICELL)= SMCON(ICELL) + CONC(ICELL)
         SIZE(ICELL) = D
C
C** X6CONC- PARTICLE CONCENTRATION NUMBER/LITER SUMMED OVER ALL CHANNELS.
C   X6DBAR AND X6DBAR2 INTERMEDIATE VARIABLES USED FOR COMPUTING
C   THE MEAN PARTICLE DIAMETER AND STANDARD DEVIATION.
C
         X6CONC = X6CONC + CONC(ICELL)
         X6DBAR = X6DBAR + D * CONC(ICELL)
         X6DBAR2 = X6DBAR2 + D*D*CONC(ICELL)
C
C   X6LWC LIQUID WATER CONTENT IN GRAMS PER CUBIC METER SUMMED OVER ALL
C   CHANNELS.  IT ASSUMES SPHERICAL DROPLETS WITH DENSITY OF WATER
C   OF 1.0 GRAM/CC (FOR PROJECT 1-668 PER BOB KELLY, UNIV. CHICAGO)
C   AND USES D IN MICROMETERS AND CONCENTRATION IN NUMBER PER LITER.
C
         X6DSY = 1.
      X6LWC=X6LWC+X6DSY*4./3.*3.1415927*(D*1.E-4/2)**3*CONC(ICELL)*1.E3
C
C** FOR DBZ (REFLECTIVITY FACTOR) CALCULATIONS
C   CONVERT PARTICLE DIAMETER FROM MICROMETERS TO MILLIMETERS AND
C   CONCENTRATION  FROM N/LITER TO N/M3 FINAL UNITS WILL BE MM6/M3
         D = D * 0.001
         CONC(ICELL) = CONC(ICELL) * 1000.
C
C** SUM OVER ALL THE CHANNELS THE PRODUCT OF DIAMETER TO THE SIXTH POWER
C   TIMES THE CONCENTRATION IN EACH CHANNEL.  UNITS ARE MM6/M3.  THIS
C   NUMBER IS THE REFLECTIVITY FACTOR, Z, AS DEFINED BY DAVID ATLAS IN
C   EQ.3.15 PAGE 363 ADVANCES IN GEOPHSYSICS, 1964, EDITED BY LANDBERG
C   AND MIEGHEM
         Z = D **6 * CONC(ICELL) + Z
       END DO
C
C** CORRECT FOR FACT THAT PARTICLES ARE ICE, NOT WATER, AND ARE LESS
C   DENSE THAN PURE ICE.  THE EQUATION USED IS
C   EZ = (1K1**2(ICE)/1K1**2(WATER)*(YDNSTY**2/DENSH20**2)*Z
C   WHERE
C   EZ IS THE EQUIVALENT REFLECTIVITY FACTOR
C   1K1**2(ICE) = 0.197
C   1K1**2(WATER) = 0.93
C   K VALUES FROM PAGE 338 IBBID
C   DENSITY OF ICE FOR PROJECT 1-668 FROM BOB KELLY
C   ZE EQUATION FROM KELLY/CHIGAGO AND U. OF WYOMING SOFTWARE.
        ZE = 0.00212 * Z
C** CONVERT TO DBZ
        IF(ZE .GT. 0.0) X6DBZ = 10.*ALOG10(ZE)
        IF(X6DBZ .LT. -30.) X6DBZ = -30.0
C
C     X6DISP IS THE RATIO OF STANDARD DEVIATION TO MEAN DIAMETER
C      AND IS A MEASURE OF THE DISPERSION OF THE DISTRIBUTION.
C     X6DBAR IS MEAN PARTICLE DIAMETER IN MICROMETERS COMPUTED USING THE
C      EQUATIONS FOR GROUPED DATA SUCH AS ARE FOUND IN EQ. 24 ON PAGE
C      164 OF SCHAUMS OUTLINE OF PROBABILITY AND STATISTICS (1975) BY
C      M. SPIEGEL
C     SIGMA IS THE STANDARD DEVIATION IN MICROMETERS OF THE DIAMETER
C      DISTRIBUTION EQUATION 28  IBBID.
C
        IF(X6CONC .GT. 0.05)
         X6DBAR = X6DBAR  / X6CONC
         SQRD=X6DBAR2/X6CONC-X6DBAR*X6DBAR
         SIGMA = SQRT( ABS(SQRD))
         IF(X6DBAR.NE.0.) X6DISP = SIGMA/X6DBAR
        ELSE
         X6DBAR = 0.0
         X6DISP = 0.0
        END IF
C
C *******************     OUTPUT PMS PARAMETERS    ***************************
C
C     ZERO X6LWC AND X6CONC BEFORE TAKEOFF
        IF(QC1.LT.10.0.AND.QC2.LT.10.0)
         X6CONC = 0.0
         X6LWC  = 0.0
        END IF
        IF(IPSUMX6.GT.0) DATA(IPSUMX6+IX) = SUMX6
        IF(IPX6LWC.GT.0) DATA(IPX6LWC+IX) = X6LWC
        IF(IPX6CON.GT.0) DATA(IPX6CON+IX) = X6CONC
        IF(IPX6DBA.GT.0) DATA(IPX6DBA+IX) = X6DBAR
        IF(IPX6DBZ.GT.0) DATA(IPX6DBZ+IX) = X6DBZ
        IF(IPX6DIS.GT.0) DATA(IPX6DIS+IX) = X6DISP
C
C******  END OF X260 CALCULATIONS AND CORRECTIONS ****************************
C
C                  HISTOGRAM PLOTS NEXT
C    AFTER THE LAST PMS CELL, CHECK FOR PLOT INTERVAL (START HISTOGRAM
C     PERIODS ON AN EVEN PLOT INTERVAL)
       NCELLS = MCELL6
       NSEC= SECSUM
       NUMSMP=NUMSMP+1
       IF(NUMSMP.EQ.1)
       TIM1=TIME
       NMN= MOD(INT(TIM1),NSEC)
       IF(NMN .GT. 0)
        DO ( KNCNT=1,NCELLS)
         SMCON(KNCNT) = 0.
         SMKN(KNCNT) = 0.
        END DO
        NUMSMP = 0
       END IF
      END IF
      SECS = NUMSMP*DELIV
      IF(SECS.EQ.SECSUM)
       TIM2 = TIM1 + SECSUM - 1.0
C
C     AVERAGE CONCENTRATIONS OVER PERIOD SECSUM FOR HISTO
      DO ( KNCNT = 1,NCELLS )
C       SMCON(KNCNT) = SMCON(KNCNT)/(SECSUM*FLOAT(MRATE6))
       SMCON(KNCNT) = SMCON(KNCNT)/SECSUM
       IF(SMCON(KNCNT).LT..0001) SMCON(KNCNT) = 0.
      END DO
      SUM=0.
       DO (K=1,NCSUM6)
        SUM =SUM +SMKN(K)
       END DO
C      PRINT 28,TIME,SMKN
C  28  FORMAT(' X260:TIME,SMKN ',F9.1,/,(10F9.1))
C      PRINT 29,TIME,SMCON
C  29  FORMAT(' X260:TIME,SMCON ',F9.1,/,(10F9.1))
C
C THE PLOT INTERVAL, SECSUM, HAS BEEN REACHED FOR THE SUMS.
C IF THE SUM OF NCSUM CELL COUNTS EXCEED THRESH, PLOT A HISTOGRAM .
C IF THE ACCUMULATION .LT.1 THEN SET IT TO .0001,FOR LOG-SCALED
C HISTOGRAM PLOT.
       IF(SUM.GE.THRESH6 )
        IF(LLA.GT.0)
         BA=1.
         CALL HISTO(SMKN,LLA,MGRYA,MINRYA,BA,TA,ALABX,ALABY,TIM1,TIM2)
        END IF
        IF(LLC.GT.0)
         CALL HISTO(SMCON,LLC,MGRYC,MINRYC,BC,TC,CLABX,CLABY,TIM1,TIM2)
        END IF
       END IF
C
C  BLANK THE ACCUMULATORS
C
       NUMSMP=0
       DO (K=1,NCELLS)
        SMKN(K) =0.
        SMCON(K) =0.
       END DO
      END IF
C
      END DO
      RETURN
      END
C ************************************************************************
      SUBROUTINE FXOAP(SPEC,CONC,TAS,T,RES,IPRB,ndiod,NCHN)
C
C ** CONC array added to stored the concentrations
C    Nov. 1990     -- cc
C
C                   <870531.1526>
C...........THE SUBROUTINE IS ENTERED WITH THE FOLLOWING ARGUMENTS
C
C           SPEC- N CHANNELS OF COUNTS FROM THE 1D OR 2D PROBE
C*****************NOTE, MAKE SURE SPEC IS DIMENSIONED TO NCHN **************
C*****************IN CALLING ROUTINE                        **************
C           CONC- CORRECTED CONCENTRATIONS IN EACH SIZE BIN IN UNITS OF #/l
C           TAS - THE TRUE AIR SPEED (M/S)
C           T   - THE SAMPLE TIME    (SECONDS)
C           RES - THE SIZE RESOLUTION OF THE PROBE IN UM
C           IPRB- PROBE FLAG,  = 1 FOR 1D-C PROBE, 2 FOR 2D-C PROBE
C                               -1 FOR 1D-P PROBE, -2 FOR 2D-P PROBE
C           ndiod- # OF DIODES IN PROBE ARRAY
C           NCHN - # OF size channels to compute
C
	common/stats/svol
      DIMENSION SVOL(64),SPEC(1),CONC(1)
C...........THIS IS THE ASSUMED RESPONSE TIME OF THE OAP PROBES IN US
      DATA TAUR/0.80/
C..........FIRST SHIFT ALL DATA TO ONE SIZE CHANNEL HIGHER SINCE ALL THE
C..........OAP PROBES UNDERSIZE BY AT LEAST ONE CHANNEL DUE TO DIGITIZATION
C..........ERRORS AT AIRSPEEDS GREATER THAN ABOUT 50 M/S.
C       write(6,8943)(spec(j),j=1,nchn)
      DO 10 I=nchn,2,-1
      SPEC(I)=SPEC(I-1)
10    CONTINUE
      SPEC(1)=0.0
C..............CALCULATE THE CHANNEL BY CHANNEL SAMPLE VOLUMES, ADJUSTING
C..............FOR THE DECREASING DEPTH OF FIELD WITH AIRSPEED
      DO 200 I=1,NCHN
      RADIUS=I*RES/2000.
C.............multiply by the magnification factor
	rad=radius*200./res
C..............diminish this radius by an amount that accounts for the fact that
C..............the particle is not on the diode array 100% of the time 50%
C..............shadowed. This amount is approximately one diode array width
C..............wide.
	rad=rad-.35
C..............If this value is less or equal to zero, any counts in this
C..............channel should be discounted since they either come from
C..............higher channels or they have to be noise since they cannot
C.............theoretically occur due to airspeed restrictions.
	if (rad.le.0.0)then
		spec(i) = 0
		goto 200
	else
	end if
      TIMEX=(RAD*2.0)/(TAS*1000.)
      TIMEX=TIMEX*1.0E6
C..........THIS IS THE FRACTION OF TOTAL AMPLITUDE CAUSED BY RESPONSE TIME
      FRAC=1.0-EXP(-TIMEX/TAUR)
C.........HAVE TO MEET 70% OCCULTATION FOR THE 1D
      FRC=.7/FRAC
C.........50% FOR THE 2D
      IF (ABS(IPRB).EQ.2)FRC=.5/FRAC
      IF (FRC.GT.1.0)FRC=1.0
C................CAUTIONARY NOTE TO USERS OF THIS SUBROUTINE, THIS RELATIONSHIP
C................BETWEEN DOF AND Z WAS DERIVED FROM LABORATORY STUDIES WHICH
C...............ARE SOMEWHAT PRELIMINARY IN NATURE AND NEED ADDITIONAL
C...............VERIFICATION
      F=FRC*100.
      Z=30.46-.628*F+.003246*F*F
      DOF=1580.*Z*RADIUS*RADIUS
	if (res.lt.100.)then
		if (dof.gt.61)dof=61.
	else
		if (dof.gt.263.)dof=263
	end if
      IF (FRC.EQ.1.0)DOF=0.0
C..........ADJUST FOR DECREASING ARRAY WIDTH IF A 1D
C..........OR INCREASING WIDTH FOR A 2D
      IF (ABS(IPRB).EQ.2)then
		sa=RES*ndiod*1.0E-3+2.0*RADIUS
	else
      		sa=RES*1.0E-3*(ndiod-1-I)
	end if
      SVOL(I)=dof*Sa
	if (svol(i).lt.0.0)svol(i)=0.0
200   CONTINUE
C      	write(6,8943)(spec(j),j=1,nchn)
8943	format(15f8.0)
      DO 310 I=1,NCHN
      IF (SVOL(I).GT.0.0)CNC=SPEC(I)*1000./(T*tas*SVOL(I))
      IF (SVOL(I).LE.0.0)CNC=0.0
      CONC(I)=CNC
310   CONTINUE
C write(6,8944)(svol(j),j=1,nchn)
8944	format(15f8.3)
      RETURN
      END
C***********************************************************************
C LAST MODIFIED:  SEPTEMBER 1992 -RLR
C  to plot histograms with 31 cells
C LAST MODIFIED:  AUGUST 1989  -CC
C TO PLOT HISTOGRAMS FOR 15, 32 OR 62 CELLS
C CHANGES: ARRAY SIZE FOR CYCIN, SIZE
C*****************************************************************************
      SUBROUTINE HISTO(SMKN,LL,MGRY,INRY,B,T,KNLABX,KNLABY,TIM1,TIM2)
C
C THIS SUBROUTINE PLOTS THE ACCUMULATIONS AND CONCENTRATIONS IN ARRAY
C SMKN() FOR 'NCELLS' CELLS.
C
      COMMON/HIST/LT(5),NCELLS,SIZE(64),NSIZE
      COMMON/X300/SIZEX3(32)
      DIMENSION CYCIN(256),KNLAB(3),SMKN(1),KNLABX(1),KNLABY(1)
      CHARACTER*8 IFMTY(2)
      CHARACTER*8 IFMTX
C      DIMENSION IFMTY(2)
      DATA ORIG/.2/
C
C  NUMSMP    THIS NO. OF SAMPLES IS ACCUMULATED BEFORE A HISTOGRAM IS PLOTTED
C  SECSUM    THIS NO. OF SECONDS IS ACCUMULATED BEFORE A HISTOGRAM IS PLOTTED
C  TIM1,TIM2 START AND STOP TIMES FOR THE HISTOGRAM PLOT
C  SIZE()    PMS CELL SIZE
C  SIZEX()   PMS PROBE 300X CELL SIZE
C  SMKN()    ACCUMULATIONS OR CONCENTRATION DATA ARRAY TO BE PLOTTED HERE
C  KNLABX    40-CHARACTER ABSCISSA LABELS FOR HISTOGRAMS
C  KNLABY    40-CHARACTER ORDIN. LABELS FOR HISTOGRAMS
C  LL        0= NO HISTOGRAM,  1= LINEAR ORDINATE,  2= LOG ORDINATE
C  B         BOTTOM ORDINATE FIXED SCALE
C  T         TOP ORDINATE FIXED SCALE
C  RANG      ORDINATE FIXED RANGE WITH FLOATING TOP AND BOTTOM SCALES
C  NCELLS -- TOTAL NUMBER OF CELLS TO BE PLOTTED
C  LT()   -- 40-CHARACTER PROJECT TITLE
C
      IMAXPT=2*NCELLS
      DO (K=1,IMAXPT)
       KP=K+IMAXPT
       K2=K/2+1
       K3=(K-1)/2+1
       CYCIN(K)=K2
       CYCIN(KP) =SMKN(K3)
      END DO
      XB=1.
      XT=NCELLS+1.
C
      YB=0.
      YT=0.
      YMN=SMKN(1)
      YMX=SMKN(1)
      DO ( K=2,NCELLS)
      YMX =AMAX1(YMX,SMKN(K))
      IF(LL.EQ.1)  YMN =AMIN1(YMN,SMKN(K))
C
      IF(LL.EQ.2 .AND. SMKN(K).GT.0.0)
        IF( YMN.LE.0) YMN=SMKN(K)
        YMN =AMIN1(YMN,SMKN(K))
       END IF
      END DO
      YMXH=.5*YMX
      IF(YMN.GT.YMXH) YMN=YMXH
C
C   THE HISTOGRAM ORDINATE IS TO BE A LOG PLOT.
C SEE IF A CARD LIMIT IS SET, ELSE ARBITRARILY ASSIGN YB=1. AND YT=10.
C
      IF(LL.EQ. 2)
       IF(YMX.LE.0. .OR. YMN.LE.0.)
        YB=B
        YT=T
        IF(YT.LE.0.)YT=10.*YB
        IF(YB.LE.0.) YB=.1*YT
        IF(YB.NE.YT)
         CALL LGRD(YMN,YMX,YB,YT,MGRY,INRY,IFMTY,NUMY,IYOR)
        ELSE
         YB=1.0
         YT=10.
         CALL LGRD(YMN,YMX,YB,YT,MGRY,INRY,IFMTY,NUMY,IYOR)
        END IF
       ELSE
        CALL LGRD(YMN,YMX,YB,YT,MGRY,INRY,IFMTY,NUMY,IYOR)
        IF(T.GT.0.) YT=T
        IF(B.GT.0.) YB=B
        CALL LGRD(YMN,YMX,YB,YT,MGRY,INRY,IFMTY,NUMY,IYOR)
       END IF
C
C THE HISTOGRAM ORDINATE IS TO BE A LINEAR SCALE
C
      ELSE
       IF(T.LE.0.)
        CALL LINRD(YMN,YMX,YB,YT,MGRY,INRY,IFMTY,NUMY,IYOR)
       ELSE
        YT=T
        YB=B
        CALL LINRD(YMN,YMX,YB,YT,MGRY,INRY,IFMTY,NUMY,IYOR)
       END IF
      END IF
C
      CALL SET(ORIG,.97,ORIG,.97,XB,XT,YB,YT,LL)
      IFMTX = 'F4.0'
C      CALL LABMOD(6H(F4.0),IFMTY,4,NUMY,1,1,0,0,0)
      CALL LABMOD(IFMTX,IFMTY,4,NUMY,1,1,0,0,0)
      CALL GRIDAL(NCELLS,1,MGRY,INRY,0,1,5)
      NRNG=1023.*(.97-ORIG)
      NSY=ORIG*1023.+.5
      NSX=NSY+NRNG/IMAXPT
C        THE ABSCISSA SCALES
      MY=180
      NRC=NRNG/NCELLS
C
C   NSIZE = 2 -- USE THE CELL NUMBERS BUT NO HISTO VALUES PRINTED
C             -- THIS IS ADDED FOR PLOTING MORE THAN 32 CELLS
      CALL GRIDAL(NCELLS,1,MGRY,INRY,0,1,5)
      NRNG=1023.*(.97-ORIG)
      NSY=ORIG*1023.+.5
      NSX=NSY+NRNG/IMAXPT
C        THE ABSCISSA SCALES
      MY=180
      NRC=NRNG/NCELLS
C
C   NSIZE = 2 -- USE THE CELL NUMBERS BUT NO HISTO VALUES PRINTED
C             -- THIS IS ADDED FOR PLOTING MORE THAN 32 CELLS
C   NSIZE = 1 -- USE THE ACTUAL CELL SIZE
C   NSIZE = 0 -- USE THE CELL NUMBERS
C
      DO (K=1,NCELLS)
       IF(NCELLS.LE.32) MX=NSX+(K-1)*NRC+6 +(K/2)
       IF(NCELLS.GT.32) MX=NSX+(K-1)*NRC+3 +(K/2)+(K/7)
       IF(NSIZE.EQ.1)
C CHANGE FOR WRITING SIZE VERTICALLY ON HISTO PLOTS (7MAY1985 CC)
        ENCODE(8,1234,KLAB) SIZE(K)
C TEMP FIX FOR 300X PROBE CELL SIZE
        IF(NCELLS.EQ.31 .OR. NCELLS.EQ.32) ENCODE(8,1234,KLAB) SIZEX3(K)
        CALL PWRIT(CPUX(MX),CPUY(MY-50),KLAB,8,0,90,-1)
       ELSE
        ENCODE(2,8086,KLAB)K
 8086 FORMAT(I2)
        CALL PWRIT(CPUX(MX),CPUY(MY),KLAB,2,0,90,-1)
       END IF
C
C **      PRINT THE HISTO VALUES HERE
C
       IF(NSIZE.LE.1 ) THEN
        IF(SMKN(K) .LE..0001) SMKN(K)=0.0
        ENCODE(8,1234,KLAB)SMKN(K)
        CALL PWRIT(CPUX(MX),CPUY(MY+32),KLAB,8,0,90,-1)
       END IF
 1234  FORMAT(E8.3)
       END DO
C
C DEFAULT ANY VALUES LESS THAN YB TO .9*YB
C
      IMP1=IMAXPT+1
      DO (K=1,IMAXPT)
       KP=K +IMAXPT
       IF(CYCIN(KP).LT.YB)CYCIN(KP) =.99*YB
      END DO
C DO THE HISTOGRAM CURVE TWICE FOR INTENSITY
      CALL CURVE(CYCIN,CYCIN(IMAXPT+1),IMAXPT)
      CALL CURVE(CYCIN,CYCIN(IMAXPT+1),IMAXPT)
C LINE CONNECTS THE HISTOGRAM CURVE AND THE BOTTOM
      DO (K=1,IMAXPT,2)
       CALL LINE(CYCIN(K),CYCIN(IMAXPT+K),CYCIN(K),YB)
      END DO
C
      IHR1=TIM1/3600.
      IHR2=TIM2/3600.
      IMN1=(TIM1-3600.*IHR1)/60.
      IMN2=(TIM2-3600.*IHR2)/60.
      ISC1=TIM1-IHR1*3600.-IMN1*60.
      ISC2=TIM2-IHR2*3600.-IMN2*60.
      ENCODE(20,30,KNLAB)IHR1,IMN1,ISC1,IHR2,IMN2,ISC2
   30 FORMAT(I2,2I3,3H TO,3I3)
      CALL PWRIT(CPUX(200),CPUY(1012),LT,40,1,0,-1)
      CALL PWRIT(CPUX(700),CPUY(1012),KNLAB,20,0,0,-1)
      CALL PWRIT(CPUX(250),CPUY(98),KNLABX,40,2,0,-1)
      CALL PWRIT(CPUX(10),CPUY(210),KNLABY,40,2,90,-1)
      CALL FRAME
      RETURN
      END
C--------------------------------------------------------------------
      SUBROUTINE SLWCCZ
C***********************************************************  SLWCCZ
C** CORRECTED J-W LIQUID WATER CONTENT (G/M3)
C** Will now use rates of QC1, TASX, CONCF if >= LWC
C** Corrected conversion constant (mph-->m/s from 0.4704 to 0.44704)
C** REQUIRES:1-LWC;2-TASX;3-CONCF
C** REQUIRES:REFJW(CONS1)
C
C**  Modified to use actual TASX and CONCF rates rather than assuming
C    that they are related to other variables' rates.    by RLR  September 1992
C
.REPL
.USE  TBLANK
.USE  TCYCVAR
.USE  TIOUNIT
.USE  TOP
.USE  BLANK
.USE  CYCVAR
.USE  IOUNIT
.USE  OP
.USE  ERROR
.USE  CALCOM
.NOREP
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
C     SAVE AJWOFF,INCLD
      IPLWC  = IPSOU(1) -1
      IPTAS  = IPSOU(2) -1
      IPCONC = IPSOU(3) -1
      LRTLWC = LRTSOU(1)
      LRTTAS = LRTSOU(2)
      LRTCON = LRTSOU(3)
C  Warn if rates are wrong.
      IF (LRTLWC.NE.LRATE) WRITE (6,10100) LRTLWC, LRATE
10100 FORMAT ("  WARNING:  SLWCCZ:  INPUT RATE FOR LWC ("I8") DIFFERENT 
     &FROM OUTPUT RATE ("I8").")
      IF (LRATE.GT.LRTCON) WRITE (6,10200) LRATE, LRTCON
10200 FORMAT ("  WARNING:  SLWCCZ:  RATE FOR LWC ("I8")  GREATER THAN CO
     &NCF ("I8").")
      IRQC1  = LRTQC1/LRATE
      IRTTAS = LRTTAS/LRATE
      IRTCON = LRTCON/LRATE
      REFJW  = CONS1
      INDPUT = INDPUT - 1
C  *** INITIALIZATION
C
      LOCSVV= LOCSAV(THISOP)-1
      IF(NSTAGE.EQ.4 )
       INCLD = 0
       AJWOFF=0.0
C Start Diagnostic
C      WRITE (6,1234) LRTQC1,LRTCON,LRATE,IRQC1,IRTCON,IRTTAS,
C    &               LRTSOU(1), LRTSOU(2), LRTSOU(3)
C1234  FORMAT ("  NLWCCZ:  LRTQC1, LRTCON, LRATE = "3I8/
C    &        "           IRQC1, IRTCON, IRTTAS = "3I8/
C    &        "           LRTSOU(1), LRTSOU(2), LRTSOU(3) = "3I8)
C End Diagnostic
      ELSE
       INCLD=ICON(LOCSVV+34)
       AJWOFF=CON(LOCSVV+35)
      END IF
C     IXCONC=1
      DO (IX=1,LDO)
        XLWC = DATA(IPLWC + IX)
C For Winn 267, CONCF is at rate 10 and others are at rate 20,
C so do stepwise interpolation
C       IF (MOD(IX,2).NE.0) IXCONC=IXCONC + 1
C       CONCF=DATA(IPCONC+IXCONC)
C       QC1   = DATA(IPQC1+IX)
C       TASX  = DATA(IPTAS + IX)
        ITAS  = (IX-1)*IRTTAS + 1
        TASX  = DATA(IPTAS+ITAS)
        ICONF = (IX-1)*IRTCON + 1
        CONCF = DATA(IPCONC+ICONF)
        IQC1= (IX-1)*IRQC1 + 1
        QC1 = DATA(IPQC1+IQC1)
C Start Diagnostic
C     IF (NSTAGE.EQ.4)
C       WRITE (6,2345) XLWC, TASX, CONCF, QC1
C2345   FORMAT ("  LWCCZ:  XLWC, TASX, CONCF, QC1 = "/(5G15.7))
C     END IF
C End Diagnostic
        IF(XLWC.EQ.99999. .OR. TASX.EQ.99999. .OR. CONCF.EQ.99999.)
         DATA(INDPUT+IX) =99999.
C        PRINT 1234, XLWC,TASX,CONCF
C1234    FORMAT (' GAPS; XLWC,TASX,CONCF: ',3(F9.2))
         GO TO 99
        END IF
C   AL COOPER'S MEMO 9/4/87
        IF (CONCF.GT.10.0) THEN
C        PRINT 2234, CONCF
C2234    FORMAT (' RESET INCLD: CONCF = ',F9.2)
         INCLD=0
         ENDIF
        INCLD = INCLD + 1
        IF (INCLD.GT.10) THEN
         AJWOFF=0.95*AJWOFF+0.05*XLWC
C        PRINT 3234, AJWOFF
C3234    FORMAT(' INCLD > 10; AJWOFF=',F9.2)
        ENDIF
C  SET XLWCC = 0 IF TRUE AIR SPEED = 0
        IF(TASX.EQ.0.0) THEN
C        PRINT 4234
C4234    FORMAT(' TASX = 0; SET LWCCF TO 0')
         DATA(INDPUT+IX) = 0.0
         GOTO 99
        ELSE
         XLWCC = (XLWC-AJWOFF) * REFJW * 0.44704/TASX
        ENDIF
C  CORRECTION
        IF(QC1 .LT. 10.)  THEN
         XLWCC = XLWC
C        PRINT 5234, QC1,XLWC
C5234    FORMAT(' QC1 < 10: ',F9.2,' LWCCF GETS LWCC: ',F9.2)
        ENDIF
        IF(XLWCC .GT. 20.0 .OR. XLWCC.LT. -10.0) THEN
C        PRINT 6234, XLWCC
C6234    FORMAT(' ADJUST LWCCF FROM ',F9.2,' TO ZERO')
         XLWCC = 0.0
        ENDIF
C
C       DATA(INDPUT+IX) = XLWCC
C  Don't let output go below zero.
        DATA(INDPUT+IX) = MAX(0.,XLWCC)
   99   CONTINUE
      END DO
      ICON( LOCSVV+34)=INCLD
      CON( LOCSVV+35)=AJWOFF
      RETURN
      END
C
      SUBROUTINE SMRHO
C ----------------------------------------------------------------------------
C    Mixing Ratio from Absolute Humidity (g/kg)
C ----------------------------------------------------------------------------
C  Written for PROJECT ASTEX/MAGE:  September 1992  RLR
C   Equations from Allen Schanot
C
C  THE INPUT PARAMETERS REQUIRED FOR THIS SUBROUTINE ARE:
C  1.  RHO  -- Absolute Humidity (g/m3)
C  2.  ATX  -- Reference Ambient Temperature (C)
C  3.  PSXC -- Reference Static Pressure (mbar)
C
C  NO INPUT CONSTANT REQUIRED FOR THIS SUBROUTINE
C
C  This subroutine will produce the following output:
C    MRHO
C ----------------------------------------------------------------------------
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TIOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
C
C
      REAL MRHO
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
C--------------------------------------------------------------------
C
C  Get source variables (all assumed to be at the same rate)
      IPRHO  = IPSOU(1)-1
      IPATX  = IPSOU(2)-1
      IPPSXC = IPSOU(3)-1
C     CALTERM = CONS1
C
      INDPUT = INDPUT - 1
C
C LOOP OVER THE TOTAL NUMBER OF CYCLES TO PROCESS
      DO (IX=1,LDO)
        RHO  = DATA(IPRHO+IX) 
        ATX  = DATA(IPATX+IX)
        PSXC = DATA(IPPSXC+IX)
C
C Check for bogus values
        IF (RHO.EQ.99999. .OR. ATX.EQ.99999. .OR. PSXC.EQ.99999.)
          MRHO = 99999.
        ELSE
          T = ATX+273.16
          ES = RHO*T/216.685626
          DENOM = PSXC-ES
          MRHO = 99999.
          IF (DENOM.NE.0.) MRHO = 622.*ES/DENOM
        END IF
        DATA(INDPUT+IX) = MRHO
C
      END DO
      RETURN
      END
      SUBROUTINE STOWAT
C***********************************************************************
C**  Experimental Total Water Content Processing  Ron Ruth  August 1992
C**  Requires:  1-TDRY:  Dry-bulb Temperature (C)
C**             2-TWET:  Wet-bulb Temperature (C)
C**             3-DPXC:  Reference Corrected Dew Point Temperature (C)
C**             4-ATX:   Reference Ambient Temperature (C)
C**             5-PSXC:  Reference Static Pressure (mbar)
C**             6-CONC:  PMS Probe Concentration (#/cm3)
C**  Following is picked up from reference indices
C**               QCXC:  Primary Reference Dynamic Pressure (mbar)
C** 
C**  Output:    1-TOWAT:  Total liquid water content (g/m3)
C**             2-RTOT:   Total water mixing ratio (g/kg) (XMRTOW)
C** 
C**
C**  Adapted from DAP Skeleton Program of Darrel Baumgardner
C**   file:  /home/chinook/darrel/katests/totalwater.f
C**
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
      COMMON/QC/IPQC1,IPQC2,LRTQC1,LRTQC2
C
C  Define output variable names here:
      DATA NTOWAT  / 8HXTLWC   /
      DATA NRTOT   / 8HXMRTOW  /
C
C These are the thermodynamic constants needed in the calculations
      DATA ALHV0 / 2.49910E10 /, DALHV / 0.0234E10 /
      DATA CPD   / 1.005E7 /
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
C       ACCESS THE VARIABLE CONTROLS
      INDST = 2
.USE  INDEX
C      CALL CPRINT (0,6,128,8,5,DUM,0)
      IOFF01 = ICON(INDOFF+1)
      IOFF02 = ICON(INDOFF+2)
      IOFF03 = ICON(INDOFF+3)
      IOFF04 = ICON(INDOFF+4)
      IOFF05 = ICON(INDOFF+5)
      DO (K=1,NUMVEC)
        IND    = INDVAL+LENCON*(K-1)
        NAMVAR = ICON(IND+IOFF01)
C       INDGET = ICON(IND+IOFF02)
C       INRATE = ICON(IND+IOFF03)
        INDPUT = ICON(IND+IOFF04)
C       LRATE  = ICON(IND+IOFF05)
C
C  Output variables
        IF (NAMVAR .EQ. NTOWAT) IPTOWAT = INDPUT-1
        IF (NAMVAR .EQ. NRTOT)  IPRTOT  = INDPUT-1
      END DO
C-----------------------------
C
C  Source variable indicess
      IPTDRY = IPSOU(1) - 1
      IPTWET = IPSOU(2) - 1
      IPDPXC = IPSOU(3) - 1
      IPATX  = IPSOU(4) - 1
      IPPSXC = IPSOU(5) - 1
      IPCONC = IPSOU(6) - 1
      IPQC   = IPQC1 - 1
C
C  Source variable rates
      LRTDRY  = LRTSOU(1)
      LRTWET  = LRTSOU(2)
      LRTDPXC = LRTSOU(3)
      LRTATX  = LRTSOU(4)
      LRTPSXC = LRTSOU(5)
      LRTCONC = LRTSOU(6)
C      SECSUM  = CONS1
C
C  ***** INITIALIZATION FOR A NEW CASE
      IF (NSTAGE.EQ.4)
C  Check rates and warn if problems.
        IF (LRTDRY.NE.LRTWET .OR. LRTDRY.GT.LRTDPXC .OR.
     &      LRTDRY.GT.LRTATX .OR. LRTDRY.GT.LRTPSXC .OR.
     &      LRTDRY.GT.LRTCONC .OR. LRTDRY.GT.LRATE .OR.
     &      MOD(LRTWET,LRTDRY).NE.0 .OR. MOD(LRTDPXC,LRTDRY).NE.0 .OR.
     &      MOD(LRTATX,LRTDRY).NE.0 .OR. MOD(LRTPSXC,LRTDRY).NE.0 .OR. 
     &      MOD(LRTCONC,LRTDRY).NE.0 )
          WRITE (6,10100)  LRTDRY, LRTWET, LRTDPXC, LRTATX, LRTPSXC,
     &                     LRTCONC, LRATE
10100     FORMAT ("  TOTWATER:  WARNING:  RATE DIFFERENCES WILL CAUSE PR
     &OBLEMS"/
     &"            LRTDRY, LRTWET, LRTDPXC, LRTATX, LRTPSXC, LRTCONC, LR
     &ATE ="/"          "6I8)
        END IF
      END IF
      LDO = NCDO
C
C Calculate index multipliers for DPXC, ATX, PSXC, CONC and QCXC
      IRDPXC = LRTDPXC/LRATE
      IRATX  = LRTATX/LRATE
      IRPSXC = LRTPSXC/LRATE
      IRCONC = LRTCONC/LRATE
      IRQC1  = LRTQC1/LRATE
C
      DO (IX=1,LDO)
        IDPXC = (IX-1)*IRDPXC + 1
        IATX  = (IX-1)*IRATX  + 1
        IPSXC = (IX-1)*IRPSXC + 1
        ICONC = (IX-1)*IRCONC + 1
        IQC1  = (IX-1)*IRQC1  + 1
C  High-rate variables
        DPXC = DATA(IPDPXC+IDPXC)
        ATX  = DATA(IPATX +IATX)
        PSXC = DATA(IPPSXC+IPSXC)
        CONC = DATA(IPCONC+ICONC)
        QCXC = DATA(IPQC  +IQC1)
C  Low-rate variables
        TDRY = DATA(IPTDRY+IX)
        TWET = DATA(IPTWET+IX)
C
C*****************************************************************************
C   subroutine twater (tdry,twet,dpbc,atb,psfdc,qcxc,concf,towat,rtot,xmrb)
C
C  This is the code for the CSIRO total water probe used during ASTEX.
C   There are a number of extra parameters that must be included.
C   They are:  DPBC, ATB, PSFDC, QCXC and CONCF.
C              DPXC, ATX, PSXC,  QC1  and CONC  <-- local representations
C
C  Calculate the mixing ratio from the reference dew pointer (g/g)
        CALL SEWIC (DPXC,PSXC,EDPX)
        DENOM = PSXC - EDPX
        XMRB = 0.
        IF (DENOM.NE.0.) XMRB = 622.*EDPX/DENOM 
C  Calculate the saturation mixing ratio at this temperature (g/g)
        CALL SEWIC (ATX,PSXC,ESAT)
        DENOM = PSXC - ESAT
        SATMR = 0.
        IF (DENOM.NE.0.) SATMR = 622.*ESAT/DENOM
C  If in cloud, assume that the mixing ratio is that at saturation for the
C    given temperature
        IF (CONC.GT.5.) THEN
          XMR = SATMR
        ELSE
          XMR = XMRB
        END IF
C  Calculate the wet bulb mixing ratio (g/kg)
        CALL SEWIC (TWET,PSXC,ETW)
        DENOM = PSXC - ETW + QCXC
        RW = 0.
        IF (DENOM.NE.0.) RW = 0.62197*ETW/DENOM
C  Calculate the dry bulb mixing ratio
C   Ratio Cw/Cp = 4.166667
        CP = CPD*(1.+4.166667*RW)
C  Calculate latent heat for average temperature in range
        ALHV = ALHV0 + DALHV*TWET
C  Get mixing ratio inside, hence also outside
        R = 0.
        IF (ALHV.NE.0.) R = CP/ALHV*(TWET-TDRY) + RW
C  If R is bogus, use RW instead
        IF (R.LE.0.) R = RW
C  Convert from g/g to g/kg
        R = R*1000.
C
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ASTEX ONLY!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C!                THE DARREL BAUMGARDNER FUDGE FACTOR                    !
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C! This is a correction to account for things we don't understand.       !
C! This makes the out-of-cloud mixing ratio values between the bottom    !
C! dew pointer and wet bulb agree fairly well.                           !
C!        r = 0.419268 + 0.397572*r + 0.0649092*r*r                      !
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        r = 0.419268 + (0.397572 + 0.0649092*r)*r
C
C  Solve for total water (g/m3)
        IF (R.LT.XMR) R = XMRB
        ATXK  = ATX+273.16
        ATXK  = MAX(ATXK, 1.0)
        RHOD  = 0.34838*PSXC/ATXK
        TOWAT = (R-XMR)*RHOD
        IF (TOWAT.LT.0. .OR. CONC.LT.1.) TOWAT = 0.
        RTOT = R
C
C  Dump the stuff out
        IF (IPTOWAT.GT.0) DATA(IPTOWAT+IX) = TOWAT
        IF (IPRTOT.GT.0)  DATA(IPRTOT+IX)  = RTOT
C
      END DO
      RETURN
C      END
C
C      FUNCTION VAPOR(TFP)
C  For GENPRO, this function is superseded by subroutine SEWIC
C       INPUT IS IN DEGREES C.
C       ROUTINE CODES GOFF-GRATCH FORMULA
C      T=273.15+TFP
C       THIS IS WATER SATURATION VAPOR PRESSURE
C      E=-7.90298*(373.16/T-1.)+5.02808*ALOG10(373.16/T)
C     $  -1.3816E-7*(10.**(11.344*(1.-T/373.16))-1.)
C     $  +8.1328E-3*(10.**(3.49149*(1.-373.16/T))-1.)
C      VAPOR=1013.246*10.**E
C      RETURN
      END
      SUBROUTINE SXO3FSC
C
C  Note:  You don't need all the fancy searching for an output variable name.
C         Use the example in smrho.if (better test it first, though.)
C
C ----------------------------------------------------------------------------
C    Corrected Fast Ozone Concentration (ppb)
C ----------------------------------------------------------------------------
C  Written for PROJECT ASTEX/MAGE:  September 1992  RLR
C
C  THE INPUT PARAMETERS REQUIRED FOR THIS SUBROUTINE ARE:
C  1. XO3  -- Raw Ozone Signal (XO350 for ASTEX)
C  2. DPXC -- Reference Dew Point (C)
C  3. PSXC -- Reference Static Pressure (mbar)
C
C  THE INPUT CONSTANT REQUIRED FOR THIS SUBROUTINE IS:
C    C FACTOR -- Calibration factor (for each flight)
C
C  This subroutine will produce the following output:
C    XO3C
C ----------------------------------------------------------------------------
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TIOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
C--------------------------------------------------------------------
C  ***** INITIALIZATION FOR A NEW CASE
C     IF(NSTAGE.EQ.4)  do something
C
C  Get source variables (all assumed to be at the same rate)
      IPXO3  = IPSOU(1)-1
      IPDPXC = IPSOU(2)-1
      IPPSXC = IPSOU(3)-1
      FACTOR = CONS1
C
C LOOP OVER THE TOTAL NUMBER OF CYCLES TO PROCESS
      DO (IX=1,LDO)
        XO3 = DATA(IPXO3+IX) 
        DPXC = DATA(IPDPXC+IX) 
        PSXC = DATA(IPPSXC+IX) 
C
C Check for bogus values
        IF (XO3.EQ.99999. .OR. DPXC.EQ.99999. .OR. PSXC.EQ.99999.)
          XO3C = 99999.
        ELSE IF (PSXC.GT.0.)
          CALL SEWIC (DPXC,PSXC,EDPC)
          XO3C = (XO3+10.)*FACTOR*(1.0+3.43*EDPC/PSXC)
        ELSE
          XO3C = 99999.
        END IF
C
C Dump it out
        DATA(INDPUT+IX-1) = XO3C
C
      END DO
      RETURN
      END
      SUBROUTINE SXATO
C ----------------------------------------------------------------------------
C    Ophir III Temperature (C)
C ----------------------------------------------------------------------------
C  Written for PROJECT ASTEX/MAGE:  September 1992  RLR
C
C  THE INPUT PARAMETER REQUIRED FOR THIS SUBROUTINE IS:
C  1.  DETSIG -- Raw Ophir Detector Signal    (OPHIR3 for ASTEX)
C  2.  BBCTEM -- Cooled Blackbody Temperature (BBCTEM for ASTEX)
C
C  THE INPUT CONSTANT REQUIRED FOR THIS SUBROUTINE IS:
C    A1 -- Calibration factor #1 (for each flight)
C    A2 -- Calibration factor #2 (for each flight)
C
C  This subroutine will produce the following output:
C    XATO
C ----------------------------------------------------------------------------
C
.REPL
.USE  TBLANK
.USE  BLANK
.USE  IOUNIT
.USE  TIOUNIT
.USE  TCYCVAR
.USE  CYCVAR
.USE  ERROR
.USE  TOP
.USE  OP
.USE  CALCOM
.NOREP
C
C     COMMON/PY200/NCSUMY,THRESHY,MRATEY,MWORDY,MCELLY,SIZEY
C****  Pick up second OPHIR III constant using the 200Y probe data space
      COMMON/PY200/NCSUMY,  A2   ,MRATEY,MWORDY,MCELLY,SIZEY
C
      DOUBLE PRECISION DETSIG, BBCTEM, BBCRAD, OAT
C
C    Zero degrees Celsius (K)
      DATA  TZERO  / 273.16 /
C
      DATA MAXCNT / 62500 /, DFLT_OFFSET / 31515.0 /
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
C--------------------------------------------------------------------
C  ***** INITIALIZATION FOR A NEW CASE
C     IF (NSTAGE.EQ.4)  do something
C
C  Get source variable indices (both assumed to be at the same rate)
      IPDTS  = IPSOU(1)-1
      IPBBC  = IPSOU(2)-1
      A1 = CONS1
C
C LOOP OVER THE TOTAL NUMBER OF CYCLES TO PROCESS
      DO (IX=1,LDO)
C
C  Get source variables
        DETSIG = DATA(IPDTS+IX) 
        BBCTEM = DATA(IPBBC+IX)
C
C Check for bogus values
        IF (DETSIG.EQ.99999. .OR. BBCTEM.EQ.99999.)
          XATO = 99999.
        ELSE
C
C     if(sbb=='b') {                   /* Normal record with no BB cooling */
C
C**  Calculate parameters in engineering units
C          detem=therm((double) idetem)
          detsig = (detsig - DFLT_OFFSET)*10.0/MAXCNT
          IF (bbctem.gt.0.)
            bbcrad = planck_rad(bbctem)
          ELSE
            bbcrad = 0.
          END IF
C
C**  Calculate airtemp = OphirAirTem = oat
C  Begin Diagnostic
C         IF (NSTAGE.EQ.4)
C           WRITE (6,1234) bbctem, detsig, A1, A2, IPDTS, IPBBC
C1234       FORMAT ("  SXATO:  bbctem, detsig, A1, A2 = "4G15.7/
C    &              "          IPDTS, IPBBC = "2I10)
C         END IF
C  End Diagnostic
          oat = detsig*A1 + A2 + bbcrad
          IF (oat .GT. 0.0) 
            oat = planck_t(oat)
          ELSE
            oat = TZERO
          END IF
          XATO = oat - TZERO
        END IF
C
C Dump it out
          DATA(INDPUT+IX-1) = XATO
C
      END DO
      RETURN
      END
C
      double precision FUNCTION planck_rad(tk)
C  planck_rad - returns hemishperical black body radiance (W/cm^2/um)
      double precision tk
      real k, lam
C    Planck's const, J-s 
      DATA  h      / 6.626176E-34 /
C    Boltzman's const, J/K
      DATA  k      / 1.380662E-23 /
C    Wavelength, um
      DATA  lam    / 4.25E-6      /
C    Speed of light, m/s
      DATA  c      / 2.99792458E8 /
C    
      DATA  PI     / 3.1415926536 /
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
      planck_rad =
     &  ((2.0*h*c*c*PI)/((lam**5.0)*(exp(h*c/lam/k/tk)-1.0)))*1.0E-10
      RETURN
      END
C
      double precision FUNCTION planck_t(rad)
      real k, lam
C  planck_t - Returns temp in K from rad (W/cm^2/um)
C    Planck's const, J-s 
      DATA  h      / 6.626176E-34 /
C    Boltzman's const, J/K
      DATA  k      / 1.380662E-23 /
C    Wavelength, um
      DATA  lam    / 4.25E-6      /
C    Speed of light, m/s
      DATA  c      / 2.99792458E8 /
C    
      DATA  PI     / 3.1415926536 /
C
C
C     * * * * * * * * * * * * * * *
C    *                             *
C   *  Executable code starts here  *
C    *                             *
C     * * * * * * * * * * * * * * *
C
      planck_t = 
     &   h*c/(lam*k*log(2.0*h*c*c*PI/(rad*1.0e10)/(lam**5.0)+1.0))
      RETURN
C     END
C
C      double precision FUNCTION therm(counts)
CC  therm - Temp of detector thermistor (K)
C      double precision counts
C      double precision tc,rt,v
CC
CC   Define these if you ever need to use this routine.
C      DATA MAXCNT, THERM_BIAS, TZERO, THERM_RZ, THERM_COEFF
CC
CC
CC     * * * * * * * * * * * * * * *
CC    *                             *
CC   *  Executable code starts here  *
CC    *                             *
CC     * * * * * * * * * * * * * * *
CC
C      v = (-5.0+counts/MAXCNT*10.0)/(1.0+50.0/18.2)
C      IF (v .GT. -THERM_BIAS/21.0)
C        rt = 200.0/(1.0/(1.0/21.0+v/THERM_BIAS)-1.0)
C      ELSE
C        rt = 1.0
C      END IF
C      therm = 1.0/(1.0/(TZERO-50.0)-log(rt/THERM_RZ)/THERM_COEFF)
C      RETURN
      END
      SUBROUTINE SDLA
C*********************************************************************
C  LAST UPDATE:     
C  Added second test to recouple procedure                  8DEC1992  RLR
C  Negative THRSH means never to reset (RFLAG === 0)       19OCT1992  RLR
C  Isolate output from RHOLA calculation loop              31JUL1992  RLR
C  Force all RHOLA values to fall between 0.001 and 50.    29JUL1992  RLR
C  Temporary:  Delete everything but RHOLA/1 and RFLAG/1   24JUL1992  RLR
C  Added QCXC threshold test                               10APR1992  RLR
C  MOD ADDED TO PREVENT RHOLA CALCULATION FROM BLOWING UP  31MAR1992  RLR
C  MODS ADDED TO PREVENT DIVIDING BY ZERO VALUES OF        18MAY1990
C  RXPR1 (ZERO SLOPE) AND RHOX
C  MODS ADDED FOR THRSHOLD RESET                           18MAY1990
C  SAFETY CHECK: RESET THRESH WHEN RHOLA.LT.0.3            30NOV1989
C                TOOK OUT RHOLA.LT.0.0 CHECK               06DEC1989
C
C****************************************** 25AUG1987 ******  SDLA
C** LYMAN ALPHA ABSOLUTE HUMIDITY   (G/M3)
C** RHOLA REQUIRES:1-VLA;2-ATX;3-PSXC;4-RHOX;5-QCXC
C
C   OUTPUT: RHOLA, RFLAG
C
C   LYMAN-ALPHA LOOSE COUPLE PROCESSING (ALLEN SCHANOT 21APRIL1987)
C   DEFINITIONS:
C   VLA   - RAW LYMAN-ALPHA VOLTAGE (VDC) (CAL FACTORS: 0.0,-1.0,0.0)
C   RHOX  - ABSOLUTE HUMIDITY FROM REFERENCE HYGROMETER (G/M3)
C   XC    - PATHLENGTH OF LYMAN-ALPHA (CM) (SPECIFIED IN INITIAL SETUP)
C   N1    - COUPLING COUNTER FOR CORRECTION ALGORITHM
C   STPT  - TEMPERATURE AT STP (DEG K)
C   STPP  - PRESSURE AT STP (MB)
C   CKO2  - COEFFICIENT OF ABSORPTION OF O2
C   CO2P  - FRACTIONAL COMPONENT OF O2 IN AIR
C   CAMP  - AMPLIFICATION FACTOR FOR L-A LOG AMP
C   ERRLR - MEAN ERROR BETWEEN REF & L-A DATA (%) (USE AS QA PARAMETER
C           FOR RESTART OF COUPLING)
C   ATX   - AMBIENT TEMPERATURE (C)
C   PSXC  - CORRECTED STATIC PRESSURE (MB)
C   QCXC  - CORRECTED DYNAMIC PRESSURE (mbar)
C   RHOTA - ESTIMATED L-A ABSOLUTE HUMIDITY (G/M3)
C   RHOLA - FINAL CORRECTED L-A ABSOLUTE HUMIDITY (G/M3)
C   CX(4) - ARRAY OF 4 COEFFICIENTS FROM EMPIRICAL FIT
C   SPS   - L-A DATA SAMPLING RATE (SAMPLE PER SECOND) (USE GENPRO DATA
C           PROCESSING RATE)
C   GL1   - COUPLING CONSTANT
C   CORC1 - L-A CORRECTION ADJUSTMENT (VDC)
C   RFLAG - STATUS FLAG FOR RECOUPLE PROCEDURE
C   THRSH - ERROR THRESHOLD FOR RECOUPLING (%) (SPECIFIED IN INI. SETUP)
C
.REPL
.USE  TBLANK
.USE  TCYCVAR
.USE  TIOUNIT
.USE  TOP
.USE  BLANK
.USE  CYCVAR
.USE  IOUNIT
.USE  OP
.USE  ERROR
.USE  CALCOM
.NOREP
      COMMON/DLA/CX(4),XC,CX1(4),XC1
C   INITIAL CONDITIONS:
      DATA STPT/273./, CKO2/0.34/, CO2P/.2315/, STPP/1013./
      DATA CAMP/.463/, GL1/0.05/
      DATA NHGM    /8HHGM     /
      DATA NDLA    /8HDLA     /,NDLA1   /8HDLA1    /
      DATA NDPLA   /8HDPLA    /,NDPLA1  /8HDPLA1   /
      DATA NRHOLA  /8HRHOLA   /,NRHOLA1 /8HRHOLA1  /
      DATA NMRLA   /8HMRLA    /,NMRLA1  /8HMRLA1   /
      DATA NRFLAG  /8HRFLAG   /,NRFLAG1 /8HRFLAG1  /
      DATA NRHUMLA /8HRHUMLA  /,NRHUMLA1/8HRHUMLA1 /
      DATA NSPHULA /8HSPHUMLA /,NSPHULA1/8HSPHUMLA1/
      DATA NTHEELA /8HTHETELA /,NTHEELA1/8HTHETELA1/
      DATA NTHEVLA /8HTHETVLA /,NTHEVLA1/8HTHETVLA1/
      DATA NTVIRLA /8HTVIRLA  /,NTVIRLA1/8HTVIRLA1 /
C
      NAMVLA = NAMVAR
      THRSH = CONS1
C--------------------------------------------------------------------
C       ACCESS THE VARIABLE CONTROLS
      INDST =2
.USE  INDEX
C      CALL CPRINT(0,6,128,8,5,DUM,0)
      IOFF01= ICON(INDOFF+  1)
      IOFF04= ICON(INDOFF+  4)
      IOFF05= ICON(INDOFF+  5)
      DO (K=1,NUMVEC)
       IND = INDVAL+LENCON*(K-1)
       NAMVAR = ICON(IND +IOFF01)
       INDPUT = ICON(IND+IOFF04)
C      IF(NAMVAR .EQ. NHGM) IPHGM = INDPUT -1
       IF(NAMVLA .EQ. NDLA)
        IF(NAMVAR .EQ. NRHOLA) IPRHOLA = INDPUT -1
        IF(NAMVAR .EQ. NRFLAG) IPFLAG = INDPUT -1
C       IF(NAMVAR .EQ. NDPLA) IPDPLA = INDPUT -1
C       IF(NAMVAR .EQ. NMRLA) IPMRLA = INDPUT -1
C       IF(NAMVAR .EQ. NRHUMLA) IPRHUMLA = INDPUT -1
C       IF(NAMVAR .EQ. NSPHULA) IPSPHULA = INDPUT -1
C       IF(NAMVAR .EQ. NTVIRLA) IPTVIRLA = INDPUT -1
C       IF(NAMVAR .EQ. NTHEELA) IPTHEELA = INDPUT -1
C       IF(NAMVAR .EQ. NTHEVLA) IPTHEVLA = INDPUT -1
       OR IF(NAMVLA .EQ. NDLA1)
        IF(NAMVAR .EQ. NRHOLA1) IPRHOLA1= INDPUT -1
        IF(NAMVAR .EQ. NRFLAG1) IPFLAG1 = INDPUT -1
C       IF(NAMVAR .EQ. NDPLA1) IPDPLA1 = INDPUT -1
C       IF(NAMVAR .EQ. NMRLA1) IPMRLA1 = INDPUT -1
C       IF(NAMVAR .EQ. NRHUMLA1) IPRHUML1 = INDPUT -1
C       IF(NAMVAR .EQ. NSPHULA1) IPSPHUL1 = INDPUT -1
C       IF(NAMVAR .EQ. NTVIRLA1) IPTVIRL1 = INDPUT -1
C       IF(NAMVAR .EQ. NTHEELA1) IPTHEEL1 = INDPUT -1
C       IF(NAMVAR .EQ. NTHEVLA1) IPTHEVL1 = INDPUT -1
       END IF
      END DO
C--------------------------------------------------------------------
C
C  *** INITIALIZATION
C
      LOCSVV= LOCSAV(THISOP)-1
C     PRINT 12345, LOCSVV
C12345 FORMAT(' LOCSVV IN SDLA: ',I12)

      IF(NSTAGE.EQ.4 )
C  Debug
C      WRITE (6,123) CX, XC
C 123  FORMAT (' SDLA:  CX(4), XC ='5G13.5)
C  Debug
       N1 = 0
       RHOLA = 0.0
       CORC1 = 0.0
      ELSE
       IF(NAMVLA .EQ. NDLA )
        N1 = ICON( LOCSVV+31)
        RHOLA= CON( LOCSVV+32)
        CORC1= CON( LOCSVV+33)
       OR IF (NAMVLA .EQ. NDLA1 )
        N1 = ICON( LOCSVV+41)
        RHOLA= CON( LOCSVV+42)
        CORC1= CON( LOCSVV+43)
       END IF
      END IF
      IF(NAMVLA.EQ.NDLA1)
       DO (IC=1,4)
        CX(IC) = CX1(IC)
       END DO
       XC= XC1
      END IF
C
      IPVLA =IPSOU(1) -1
      IPATX =IPSOU(2) -1
      IPPSXC=IPSOU(3) -1
      IPRHOX=IPSOU(4) -1
      IPQCXC=IPSOU(5) -1
      INDPUT = INDPUT -1
      SPS = LRATE
      PROD1 = CKO2*CO2P*XC*STPT
      PROD2 = STPP*CAMP
      RMAXER=0
      DO (IX=1,LDO)
       VLA = DATA(IPVLA  +IX)
       ATX = DATA(IPATX  +IX)
       PSXC= DATA(IPPSXC +IX)
       RHOX= DATA(IPRHOX +IX)
       QCXC= DATA(IPQCXC +IX)
       IF(VLA.EQ.99999. .OR. ATX.EQ.99999. .OR. PSXC.EQ.99999.
     1   .OR. RHOX.EQ.99999. .OR. QCXC.EQ.99999.)  THEN
C  Debug
C       WRITE (6,1234) VLA, ATX, PSXC, RHOX, QCXC
C1234   FORMAT (' SDLA:  VLA, ATX, PSXC, RHOX ,QCXC ='5G13.5)
C  Debug
        DPLA=99999.
        RHOLA= 99999.
        RM= 99999.
        RFLAG= 0.0
        RHUM= 99999.
        SHUM= 99999.
        TVIR= 99999.
        THETAE= 99999.
        THETAV= 99999.
        GOTO 98
       ENDIF
C
C** RUN THRU ENTIRE SECTION FOR EACH TIME STEP (DATA POINT)
C
C** CALCULATE OXYGEN CORRECTION TO VLA
       ATXK = ATX + 273.15
       IF(ATXK.EQ.0.0) ATXK = 0.00001
       VO2 = (PROD1/PROD2)*PSXC/ATXK
       VH2O = VLA - VO2
       IF(N1 .LT. 300) N1 = N1 + 1
C** ESTIMATE L-A HUMIDITY USING EMPIRICAL 3RD ORDER FIT
       RHOTA = (CX(1)+VH2O*(CX(2)+VH2O*(CX(3)+VH2O*CX(4))))/XC
C** TAKE DERIVATIVE OF RHOTA WITH XC A CONSTANT
       RXPR1 = (CX(2)+VH2O*(2.*CX(3)+VH2O*(3.*CX(4))))/XC
C** SET RECOUPLE CONDITIONS
       IF(N1 .EQ. 1)
C  RECOUPLE 
        RHOLA = RHOTA
        CORC1 = 0.
       END IF
C** COUPLE SYSTEM AND DETERMINE THE CORRECTION FOR EACH TIME STEP
       DFDLA = RHOLA - RHOX
       IF(DFDLA .EQ. 0.)
        DEL = 0.
       ELSE
        TDEL = 1.0/SPS
        COUP = EXP(-GL1*N1)
C  New limit for slope (0.5 instead of 0.1) from Allen Schanot  4 August 1992
        RXPR1 = MAX(RXPR1, 0.5)
C       IF(RXPR1 .LT. 0.1) RXPR1=0.1
        DEL = (1.0/RXPR1)*ABS(DFDLA)*(COUP+0.001*TDEL)
       END IF
       CINC = SIGN(DEL,DFDLA)
       CORC1 = CORC1 + CINC
       VH2O = VH2O-CORC1
C** CALCULATE CORRECTED L-A ABSOLUTE HUMIDITY
       RHOLA =(CX(1)+VH2O*(CX(2)+VH2O*(CX(3)+VH2O*CX(4))))/XC
C  Debug
C      IF (RHOLA .GT. 99999. .OR. RHOLA .LT. 0.) THEN
C        WRITE (6,1235) RHOLA
C1235    FORMAT (' SDLA:  RHOLA = 'G13.5)
C        WRITE (6,1234) VLA, ATX, PSXC, RHOX
C  Debug
C**** Following lines added to keep routine from blowing up.   RLR  920331
C      IF (RHOLA .GT. 99999.) RHOLA = 99999.
C      IF (RHOLA .LT.     0.) RHOLA = 0.
C**** Same thing but in different form                         920803
C  Removed after check for mininum slope was increased
C    from 0.1 to 0.5                                           RLR  920805
C      RHOLA = MIN(RHOLA, 99999.0)
C      RHOLA = MAX(RHOLA, 0.0)
C** CALCULATE MEAN ERROR AND TEST FOR RECOUPLE
       RFLAG = 0.
       IF(RHOX .LT. 0.1) RHOX=0.1
C  Changed sense of ERRLR calculation (per Schanot)  12/10/92  RLR
       ERRLR = 100. * (RHOX-RHOLA)/RHOX
       ERTST = ABS(ERRLR)
       IF (ERTST.GT.RMAXER) RMAXER=ERTST
C Allen Schanot's safety check, 7/5/88
C      IF(N1.LT.10) ERTST = 0.0
C Allen Schanot's safety check, 4/10/92
C      IF (N1.LT.10) ERTST = 5.0
C    Updated with another test, 12/8/92
C      IF (N1.LT.10 .OR. RHOX.LT.0.1) ERTST = 5.0
C    Updated with a different test, 12/10/92
       IF (N1.LT.10 .OR. ERRLR.LT. -THRSH) ERTST = 5.0
       IF (RHOLA.GE.0.3) THEN
        THS=THRSH
       ELSE
        THS=10. *THRSH
       ENDIF
C Another Allen Schanot safety check,  4/10/92
C  Revised to ignore test if THS is negative; by RLR  19Oct1992
       IF( ((ERTST.GT.THS).AND.(THS.GE.0)) .OR. (QCXC.LT.15))
        N1= 0
        RFLAG =-1.
       END IF
C  Prevent "runaway" values of RHOLA (Limit values to between 0. and 50.) for
C   output and display by defining a special output variable name (RHOLAO)
C    RLR  920729
       RHOLAO = MIN(RHOLA, 50.0)
       RHOLAO = MAX(RHOLAO, 0.001)
C
CC     IF(RHOLA.LE.0.0) THEN
CC Debug
CC      WRITE (6,1234) VLA, ATX, PSXC, RHOX
CC      WRITE (6,2345) RHOLA
C2345   FORMAT (' SDLA:  RHOLA ='G13.5'  Set all output variables to 999
CC   &99.')
CC Debug
CC      DPLA=99999.
CC      RHOLA= 99999.
CC      RM= 99999.
CC      RFLAG= 0.0
CC      RHUM= 99999.
CC      SHUM= 99999.
CC      TVIR= 99999.
CC      THETAE= 99999.
CC      THETAV= 99999.
CC      GOTO 98
CC     ENDIF
C----------------------------------------------------------------------
C** LYMAN ALPHA RELATED VARIABLES
C
C** DPLA - DEW POINT CALCULATION  (C)
C    Following Cooper's code line caused problems, hence deleted.
C      IF(RHOLA.GT.20.) RHOLA= 0.000001
C      ELA = ( ATXK* RHOLAO)/1322.3
C      IF(ELA.GT.0.0)
C       Z = ALOG(ELA)
C      ELSE
C       Z = 0.0
C      END IF
C      DPLA = (237.3*Z)/(17.27-Z)
C      IF(ATX.LT.0.0) DPLA = (273.0*Z)/(22.51-Z)
C** MRLA - MIXING RATIO CALCULATION (G/KG)
C      CALL SEWIC(DPLA,PSXC,EDPC)
C      RM = 622.0 * EDPC / (PSXC - EDPC)
C** PSURFLA - SURFACE PRESSURE CALCULATION (MB)
C** TVIRLA - VIRTUAL TEMPERATURE (K)
C      TVIR = ATXK *((1.+1.6078E-3*RM)/(1.+.001*RM))
C      IF (IPHGM.GT.0) THEN
C       HGM = DATA(IPHGM +IX)
C       TBARM = TVIR + 0.5 *(HGM*.0098)
C       SURFP = PSXC* EXP((HGM/TBARM)*.0341833194)
C       IF( HGM .GT.750.0) SURFP =1000.
C      ENDIF
C** RHUMLA - RELATIVE HUMIDITY CALCULATION (PERCENT)
C      CALL SEWIC(DPLA,PSXC,EDPC)
C      CALL SEWIC(ATX,PSXC,EATX)
C      IF(EATX.EQ.0.0) EATX = 0.0001
C      RHUM = 100. * EDPC/EATX
C
C** SHUMLA - SPECIFIC HUMIDITY CALCULATION (G/KG)
C      CALL SEWIC(DPLA,PSXC,EDPC)
C      SHUM=622.0*EDPC/(PSXC-0.378*EDPC)
C** THETAELA EQUIVALENT POTENTIAL TEMPERATURE (K)
C      CALL SEWIC(DPLA,PSXC,EDPC)
C      IF(EDPC.LE.0.0) EDPC=0.0001
C** TEMPERATURE AT THE LIFTING CONDENSATION LEVEL (K) (BOLTON) FEB.1986
C      IF(ATXK .LE. 0.0) ATXK = 0.0001
C      IF(EDPC .LE. 0.0) EDPC = 0.0001
C      TLCL = (2840./(3.5*ALOG(ATXK)-ALOG(EDPC)-4.805))+55.
C      THETA = ATXK * (1000./PSXC) ** 0.28571
C
C      IF(TLCL.EQ.0.0) TLCL=0.0001
C      EXPARG= ((3.376/TLCL)-.00254)*(RM*(1.+(.81*10E-3*RM)))
C      IF(EXPARG.GT.741)
C       PRINT 77,IX,ATX,DPLA,PSXC,RM
C 77    FORMAT(' SDLA:EXPARG.GT.741: IX,ATX,DPC,PSXC,MR-',I5,4F9.3)
C       EXPARG = 0.001
C      END IF
C      THETAE = THETA*EXP(EXPARG)
C** THETAVLA - VIRTUAL POTENTIAL TEMPERATURE (K)
C      THETAV = TVIR  *(1000./PSXC)**0.28571
C  Finish up
   98  CONTINUE
       IF(NAMVLA.EQ.NDLA)
        IF(IPRHOLA .GT. 0 ) DATA(IPRHOLA+IX) = RHOLAO
        IF(IPFLAG  .GT. 0 ) DATA(IPFLAG +IX) = RFLAG
C        IF (RFLAG.NE.0.0) PRINT 12634,RFLAG,IX
C       IF(IPDPLA .GT. 0) DATA(IPDPLA +IX) = DPLA
C       IF(IPMRLA .GT. 0 ) DATA(IPMRLA +IX) = RM
C       IF(IPRHUMLA .GT.0) DATA(IPRHUMLA+IX) = RHUM
C       IF(IPSPHULA .GT.0) DATA(IPSPHULA+IX) = SHUM
C       IF(IPTVIRLA .GT.0) DATA(IPTVIRLA+IX) = TVIR-273.15
C       IF(IPTHEELA .GT.0) DATA(IPTHEELA+IX) = THETAE
C       IF(IPTHEVLA .GT.0) DATA(IPTHEVLA+IX) = THETAV
       OR IF(NAMVLA.EQ.NDLA1)
        IF(IPRHOLA1 .GT. 0) DATA(IPRHOLA1+IX) = RHOLAO
        IF(IPFLAG1 .GT. 0) DATA(IPFLAG1 +IX) = RFLAG
C       IF(IPDPLA1 .GT. 0) DATA(IPDPLA1 +IX) = DPLA
C       IF(IPMRLA1 .GT. 0) DATA(IPMRLA1 +IX) = RM
C        IF (RFLAG.NE.0.0) PRINT 12634,RFLAG,IX
C12634   FORMAT(' SDLA WARN: RFLAG = ',G13.5,' AT IX=',I5)
C       IF(IPRHUML1 .GT. 0) DATA(IPRHUML1+IX) = RHUM
C       IF(IPSPHUL1 .GT. 0) DATA(IPSPHUL1+IX) = SHUM
C       IF(IPTVIRL1 .GT. 0) DATA(IPTVIRL1+IX) = TVIR-273.15
C       IF(IPTHEEL1 .GT. 0) DATA(IPTHEEL1+IX) = THETAE
C       IF(IPTHEVL1 .GT. 0) DATA(IPTHEVL1+IX) = THETAV
       END IF
   99  CONTINUE
      END DO
      IF (NAMVLA .EQ. NDLA)
       ICON(LOCSVV+31) = N1
       CON(LOCSVV+32) = RHOLA
       CON(LOCSVV+33) = CORC1
      OR IF (NAMVLA .EQ. NDLA1)
       ICON(LOCSVV+41) = N1
       CON(LOCSVV+42) = RHOLA
       CON(LOCSVV+43) = CORC1
      END IF
      RETURN
      END
