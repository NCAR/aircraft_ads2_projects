#! /bin/csh -f
###############  <-- string to search for changes or needed code
#
#  Script to handle remote processing of RAF Aircraft Data
#   using hot-swappable disk drives
#
#  Usage:
#    gndproc <proj#> [configuration_file_name] [-v] [-d]
#
#    required argument:
#      <proj#> -- 3-digit project number
#    optional command-line arguments:
#      configuration_file_name -- name of configuration file (which must end
#                                  with the extent "conf").
#      -v -- Sets verbose mode (not quiet mode which suppresses most terminal
#              messages except user instructions)
#      -d -- Sets debug mode (verbose output of progress) and Verbose mode
#
#   The configuration file, unique to each project is required for the
#   script to work.  It typically exists in the project's Production/gndproc
#   subdirectory.  Its name will be set in the following order:
#    1) from the second argument on the command line
#    2) from the environment variable "GNDPROC_CONF"
#    3) assumed to be "gndproc.conf" in the project's Production/gndproc
#        subdirectory
#
#
#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#  *  Copyright 2002, 2003                                                   *
#  *  University Corporation for Atmospheric Research, All Rights Reserved.  *
#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#
#  Written by Ronald L. Ruth  17 May 2002
#  Revision  0 by RLR on 21 May 2002 (original code)
#  Revision  1 by RLR on 26 Jul 2002 (rewrite to modularize each job)
#  Revision  2 by RLR on 17 Apr 2003 (minor corrections)
#
#  Dependencies:
#     command line:  required:  Project number
#                    optional:  config file name, debug and verbose flags
#     stdin:  one entry to continue a paused script (after drive mount)
#     Environment variables:  PROJ_DIR, DISPLAY,
#                              (may use GNDPROC_CONF, if extant)
#     Hard wires:  job types ($j_type), file types ($f_type)
#     Directories:   <project>/Production/gndproc/
#     Files:  req.:  gndproc.conf, $mbufr (gndproc_log)
#             opt.:  Instructions_1, Instructions_2,
#                    job files with names of the form <[a-z]*_[a-z]*_[a-z]*>
#     UNIX files/variables:  stdin, /dev/null, $status
#     UNIX commands:  grep, awk, mount, umount, ls, cp, df, sed, rm, wc
#     Job commands:  nimbus, n2asc, scp, ftp, gzip, gunzip
#
#  Notes:  - If a program name (e.g., nimbus) is not found in the config
#             file, its generic name will be used instead.  This method
#             allows this script to use customized versions of programs,
#             if needed (e.g., a development version of nimbus).
#          - In "test" mode, nothing is done.  Every operation is echoed.
#             (At least that was the original plan; it hasn't been fully
#             implemented.)
#          - In "debug" mode, verbose output logs progress through the script.
#          - In "notquiet" mode, logfile messages are output to the terminal
#             as the script is executing.
#          - Need to check code that should exit this script gracefully if
#             the user doesn't want it to complete (i.e., ^C interrupt).
#          - For bug-report lines, search for the string " -- line "
#
#  ToDo:  - Add sftp job processing
#
#
#      * * * * * * * * * * * * * * *
#     *                             *
#    *  Executable code starts here  *
#     *                             *
#      * * * * * * * * * * * * * * *
#
onintr abort
#
#
#  Process command-line arguments
foreach arg ($argv)
#
#   Check for project number
  @ chars = `echo $arg | wc -m` - 1
  if ($chars == 3) then
    @ chars = `echo  $arg | grep -c "[0-9][0-9][0-9]"`
    if ($chars != 1) then
      echo "   Illegal project ($proj)"
      echo "   $0 requires a 3-digit project number on the command line."
      goto nostart
    else
      set proj = $arg
      continue
    endif
  endif
#   Check for configuration file name (must have string "conf")
  set chars = `echo  $arg | grep -c "conf"`
  if ($chars == 1) then
    set conf = $arg
    continue
  endif
#   Check for verbose (not quiet) mode
  @ chars = `echo $arg | wc -m` - 1
  if ($chars == 2) then
    set chars = `echo $arg | grep -e '-v'`
    if ($status == 0) then
      set nqt = 1
      continue
    endif
  endif
#   Check for debug mode
  @ chars = `echo $arg | wc -m` - 1
  if ($chars == 2) then
    set chars = `echo $arg | grep -e '-d'`
    if ($status == 0) then
      set dbg = 1
      continue
    endif
  endif
end
#
if (! $?proj) then
  echo ""
  echo "   $0 requires a 3-digit project number on the command line."
  goto nostart
endif
#
#  Check for needed project subdirectories
if (! $?PROJ_DIR) then
  echo "  $0 -- no PROJ_DIR environment variable set."
  goto nostart
endif
set projdir = "$PROJ_DIR/$proj/Production"
if (! -e $projdir) then
  echo "  $0 $projdir directory doesn't exist."
  goto nostart
endif
set projdir = "$projdir/gndproc"
if (! -e $projdir) then
  echo "  $0 $projdir directory doesn't exist."
  goto nostart
endif
#
#
#  Set configuration file
#if ($#argv > 1) then
if ($?conf) then
#   from run string
  set conf_f = $argv[2]
else if ($?GNDPROC_CONF) then
#   from environment variable
  set conf_f = $GNDPROC_CONF
else
#   using default name (most likely)
  set conf_f = "$projdir/gndproc.conf"
endif
#
###############  Why did I make this decision?  It can override 
###############   a requested file name.
#   I want the file somewhere in the project's directory structure
if (`echo $conf_f | grep -c $proj` == 0) then
  set conf_f = "$projdir/$conf_f"
endif
#
#  Does configuration file exist?
if (! -e $conf_f) then
  echo "   ${0}:  Configuration file ($conf_f) does not exist."
  goto nostart
endif
#
#  Can I read the configuration file?
if (! -r $conf_f) then
  echo "   $0 cannot read configuration file ($conf_f)."
  goto nostart
endif
#
#
#  Initialize some variables
#   Make sure display environment is set (for nimbus)
setenv DISPLAY :0.0
#   Messages
set ns_msg1 = "Setting for"
set ns_msg2 = "missing from configuration file $conf_f"
set ns_msg3 = "Could not find"
set ns_msg4 = "in configuration file $conf_f"
#   OK flag
set OK_flag = "yes"
#
#  Set up scratch message file (and test config file)
#   Get path name for message file
set c_name = "msg_f"
set input = `grep "^$c_name *=" $conf_f`
set result = $status
if ($result == 0) then
  set temp = `echo $input | awk -F= '{print $2}'`
  if ($#temp > 0) then
    set $c_name = $temp
  else
    echo '   '$ns_msg1' "'$c_name'" '$ns_msg2
    goto nostart2
  endif
else
  echo '   '$ns_msg3' "'$c_name'" '$ns_msg4
  goto nostart2
endif
#
#  Set and test message file name
set $c_name = $msg_f.$$
echo "  Status messages for $0 script (created on `date`)" >! $msg_f
set result = $status
if ($result != 0) then
  echo "  Error $result when trying to write messages into message file $msg_f"
  goto nostart2
endif
#
#
#  Read list of configuration variable names
#   Note:  Order is important; "debug" should come first
set c_name = "c_vars"
set input = `grep "^$c_name *=" $conf_f`
set result = $status
if ($result == 0) then
  set temp = `echo $input | awk -F= '{print $2}'`
  if ($#temp > 0) then
    if ($?dbg) then
      echo "  Got setting for ${c_name}:  $temp"
    endif
    set $c_name = ($temp)
  else
#   If I cannot get my configuration variables, I'm done
    echo '   '$ns_msg1' "'$c_name'" '$ns_msg2
    set OK_flag = "no"
  endif
else
#   If I cannot get my configuration variables, I'm done
  echo '   '$ns_msg3' "'$c_name'" '$ns_msg4
  set OK_flag = "no"
endif
#
if ($OK_flag == "no") goto nostart3
#
#
#  Set all configuration variable values ("debug" should be first in list)
foreach c_name ($c_vars)
  set input = `grep "^$c_name *=" $conf_f`
  set result = $status
  if ($result == 0) then
    set temp = `echo $input | awk -F= '{print $2}'`
    if ($#temp > 0) then
      set $c_name = ($temp)
      if ($c_name == "debug") then
#   Command line option overrides configuration file debug setting
        if ($?dbg) then
          set debug = "yes"
          echo "  Debug setting (below) has been overridden by command-line option."
        endif
      endif
      if ($?debug) then
        if ($debug == "yes") echo "  Got setting for ${c_name}:  $temp"
      endif
    else
      echo '   '$ns_msg1' "'$c_name'" '$ns_msg2 >> $msg_f
      set OK_flag = "no"
    endif
  else
    echo '   '$ns_msg3' "'$c_name'" '$ns_msg4 >> $msg_f
    set OK_flag = "no"
  endif
end
#
#
#  Command-line "turn-on" settings override other setting methods
#
#   Set final debug mode (I had to play games with it above.)
if ($?dbg) then
#    from command line
  set debug = 1
else if ($?debug) then
#    from configuration file
#     Change debug from string to logical
  if ($debug == "yes") then
    set debug = 1
  else
    set debug = 0
  endif
else
  set debug = 0
endif
#
#   Set verbose mode
if ($debug) then
  set notquiet = 1
else if ($?nqt) then
  set notquiet = 1
#  Default "quiet" setting
else if ($?quiet) then
#    Change "quiet" from string to logical
  if ($quiet == "no") then
    set notquiet = 1
  else
    set notquiet = 0
  endif
else
  set notquiet = 0
endif
#
if ($notquiet) then
  echo " $0 -- automaticaly copy and process"
  echo "  raw aircraft data and send it wherever"
  echo "   Revision  2  RLR   9 May 2003"
  echo " Report bugs or give questions about MSS bitfile names to Ron Ruth"
  echo "     (ron@raf.atd.ucar.edu)"
  echo ""
endif
#  (End of command-line processing)
#
#
#  Read list of file extensions to be used in this script
#
set c_name = "extensions"
set $c_name = ""
set input = `grep "^$c_name *=" $conf_f`
set result = $status
if ($result == 0) then
  set temp = `echo $input | awk -F= '{print $2}'`
  if ($#temp > 0) then
    set $c_name = ($temp)
    if ($debug) echo "  Got setting for ${c_name}:  $temp"
  else
    if ($debug) echo '   '$ns_msg1' "'$c_name'" '$ns_msg2
  endif
else
  if ($debug) echo '   '$ns_msg3' "'$c_name'" '$ns_msg4
endif
#
if ($debug) echo "  $#extensions extensions = $extensions"
#
#    (following "noglob" is done because, at time of writing, the
#      raw MCR extension is of the form rawMCR?, where ? = a, b, etc.)
set noglob
#  Set all the file extensions
foreach c_name ($extensions)
  set input = `grep "^$c_name *=" $conf_f`
  set result = $status
  if ($result == 0) then
    set temp = `echo $input | awk -F= '{print $2}'`
    if ($#temp > 0) then
      set $c_name = ($temp)
    else
      echo '   '$ns_msg1' "'$c_name'" '$ns_msg2 >> $msg_f
      set OK_flag = "no"
    endif
  else
    echo '   '$ns_msg3' "'$c_name'" '$ns_msg4 >> $msg_f
    set OK_flag = "no"
  endif
end
unset noglob
#
#
#  Read the types of new, raw-data files I need to copy
set c_name = "raw_file_types"
set $c_name = ""
set input = `grep "^$c_name *=" $conf_f`
set result = $status
if ($result == 0) then
  set temp = `echo $input | awk -F= '{print $2}'`
  if ($#temp > 0) then
    set $c_name = ($temp)
    if ($debug) echo "  Got setting for ${c_name}:  $temp"
  else
    echo '   '$ns_msg1' "'$c_name'" '$ns_msg2 >> $msg_f
    set OK_flag = "no"
  endif
else
  echo '   '$ns_msg3' "'$c_name'" '$ns_msg4 >> $msg_f
  set OK_flag = "no"
endif
#
if ($debug) echo "  $#raw_file_types raw_file_types = $raw_file_types"
#
if ($#raw_file_types < 1) then
  echo "  No raw data file types have been specified to copy.  This is probably due " >> $msg_f
  echo '   to incorrect or missing "raw_file_types" entries in the $conf_f file.' >> $msg_f
  set OK_flag = "no"
endif
#
#
#  Read the types of jobs I can do
set c_name = "job_types"
set $c_name = ""
set input = `grep "^$c_name *=" $conf_f`
set result = $status
if ($result == 0) then
  set temp = `echo $input | awk -F= '{print $2}'`
  if ($#temp > 0) then
    set $c_name = ($temp)
    if ($debug) echo "  Got setting for ${c_name}:  $temp"
  else
    echo '   '$ns_msg1' "'$c_name'" '$ns_msg2 >> $msg_f
    set OK_flag = "no"
  endif
else
  echo '   '$ns_msg3' "'$c_name'" '$ns_msg4 >> $msg_f
  set OK_flag = "no"
endif
#
if ($debug) then
  echo "  $#job_types job_types = $job_types"
  echo "  OK_flag = $OK_flag"
endif
#
#  Did I get all the configuration values I need?
if ($OK_flag != "yes") goto nostart3
#
#  No need for status message buffer any more
\rm $msg_f >& /dev/null
#
#
#  Read list of program-name variables
set c_name = "p_vars"
set $c_name = ""
set input = `grep "^$c_name *=" $conf_f`
set result = $status
if ($result == 0) then
  set temp = `echo $input | awk -F= '{print $2}'`
  if ($#temp > 0) then
    set $c_name = ($temp)
    if ($debug) echo "  Got setting for ${c_name}:  $temp"
  else
    if ($debug) echo '   '$ns_msg1' "'$c_name'" '$ns_msg2
  endif
else
  if ($debug) echo '   '$ns_msg3' "'$c_name'" '$ns_msg4
endif
#
if ($debug) echo "  $#p_vars p_vars = $p_vars"
#
#  Set all program names
foreach c_name ($p_vars)
  set $c_name = $c_name
  set input = `grep "^$c_name *=" $conf_f`
  set result = $status
  if ($result == 0) then
    set temp = `echo $input | awk -F= '{print $2}'`
    if ($#temp > 0) then
      set $c_name = ($temp)
      if ($debug) echo "  Got setting for ${c_name}:  $temp"
    else
      if ($debug) echo "   ${c_name} set to default = ${c_name}"
    endif
  else
    if ($debug) echo "   ${c_name} set to default = ${c_name}"
  endif
end
#
#  Default any needed program names that didn't get set
if (! $?grep) then
  set grep = "grep"
  if ($debug) echo "  grep set to default = $grep"
endif
if (! $?awk) then
  set awk = "awk"
  if ($debug) echo "  awk set to default = $awk"
endif
if (! $?mount) then
  set mount = "mount"
  if ($debug) echo "  mount set to default = $mount"
endif
if (! $?umount) then
  set umount = "umount"
  if ($debug) echo "  umount set to default = $umount"
endif
if (! $?ls) then
  set ls = "ls"
  if ($debug) echo "  ls set to default = $ls"
endif
if (! $?cp) then
  set cp = "cp -p"
  if ($debug) echo "  cp set to default = $cp"
endif
if (! $?df) then
  set df = "df -k"
  if ($debug) echo "  df set to default = $df"
endif
if (! $?gzip) then
  set gzip = "gzip -f"
  if ($debug) echo "  gzip set to default = $gzip"
endif
if (! $?gunzip) then
  set gunzip = "gunzip"
  if ($debug) echo "  gunzip set to default = $gunzip"
endif
if (! $?sed) then
  set sed = "sed"
  if ($debug) echo "  sed set to default = $sed"
endif
if (! $?rm) then
  set rm = "rm"
  if ($debug) echo "  rm set to default = $rm"
endif
if (! $?wc) then
  set wc = "wc"
  if ($debug) echo "  rm set to default = $rm"
endif
#
#
#  I don't have a log message buffer yet
set mok = "no"
#
#   Set startup messages
set mseparator = " --------------- "`date`" ---------------"
set mbegin = "  $0 script started  "`date`
set mbegan = "  $0 script restarted  "`date`
#
if ($debug) then
  echo "debug:  mseparator = $mseparator"
  echo "debug:  mbegin = $mbegin"
  echo "debug:  mbegan = $mbegan"
endif
#
#  Set up email/log message buffer and tell people that I have begun
set mbufr = $D/$mbufr.$$
if ($debug) then
  echo "debug:  mbufr = $mbufr"
  echo $mbegin
endif
#  Test write to log file
echo "----------------------------------------------------" >! $mbufr
set result = $status
if ($status != 0) then
  if ($debug) then
    echo "   Could not write to log buffer $mbufr"
  else
    $mp -s "$0 email error 1 -- line 534" $elist < /dev/null >& /dev/null
  endif
  set mbufr = /dev/null     #              Writing to bit bucket instead <--
endif
#
#
#  Get started
#
#   Is this code being tested?
if (! $?test) set test = "no"
if ($debug) echo " Test mode = $test"
#
#   Make sure removable disk isn't mounted
if ($test == "no") then
  $umount $S >& /dev/null
else
  echo "test:  'umount $S >& /dev/null' would have been done here"
endif
#
#   Give the user disk-mounting instructions
if (! -e $projdir/Instructions_1) then
#  Simple default "install" message
  echo ""
  echo ""
  echo "  Insert removable disk drive with new data into proper chassis slot."
  echo "  When drive is ready, hit [ENTER] key to continue."
  echo ""
else
  cat $projdir/Instructions_1
endif
set input = "$<"
#
#   Mount removable drive
if ($test == "yes") then
  echo -n  "test:  mount $S (y, n, [r]=y)? "
  set input = "$<"
  if ($input == "") set input = "y"
  set t1 = $input
  if ($t1 == "y") then
    $mount $S >& /dev/null
    set result = $status
  else
    echo -n  "test:  set successful mount flag (y, n, [r]=y)? "
    set input = "$<"
    if ($input == "") set input = "y"
    if ($input == "y") then
      set result = 0
    else
      set result = 1
    endif
  endif
else
  $mount $S >& /dev/null
  set result = $status
endif
if ($result != 0) then
  set mesg = "   Could not mount removable drive.  Error code = ${result}"
  echo $mesg
  echo $mesg >> $mbufr
  echo '  This can happen if the LED display did not indicate "1".'
  echo "  Otherwise try removing and remounting the drive, then run ${0} again."
  goto quit
endif
#
#   See if it has files
set files = (`$ls $S`)
if ($#files < 1) then
  $umount $S
  set mesg = "   Removable drive doesn't seem to be mounted (couldn't find any files)."
  echo $mesg
  echo $mesg >> $mbufr
  echo "   Try removing and remounting the drive then run $0 again."
  echo $mesg
  echo $mesg >> $mbufr
  goto quit
endif
#
#   Read files from removable media
pushd $S >& /dev/null
if ($debug) echo "   Changed directory to `pwd`"
#
#   Initialize "files-to-do" list
set f2do = ""
#
#   Find all requested new raw files
foreach type ($raw_file_types)
#                        It would be nice if I didn't have to hard-wire these
#  set noglob
  switch ($type)
    case rads
      set ext = $rads
      breaksw
    case r2d
      set ext = $r2d
      breaksw
    case rmcr
      set ext = "$rmcr"
      breaksw
    default
      set mesg = "   Skipping unrecognized file type ($type)."
      if ($notquiet) echo $mesg
      echo $mesg >> $mbufr
      continue
  endsw
#
###############  Delete or uncomment next line?
#  unset noglob
#
  if ($debug) echo "  Searching for files with extension: $ext"
#
#   Get list of all raw data files of this type on removable drive
  $ls ${proj}[frt]f*.$ext >& /dev/null
  set result = $status
  if ($status == 0) then
    set afiles = (`$ls ${proj}[frt]f*.$ext`) >& /dev/null
  else 
    set afiles = ""
  endif
  if ($debug) then
    echo "$S $ext files = $afiles"
    echo "number of $ext files = $#afiles"
  endif
#
#   See if files are new
  if ($#afiles < 1) then
    set mesg = "   No new raw $ext data files found to copy"
    if ($notquiet) echo $mesg
    echo $mesg >> $mbufr
  else
    foreach afile ($afiles)
      $ls $D/$afile >& /dev/null
      set result = $status
      if ($result == 0) then
#   Check file lengths to see if the removable file is larger
        @ t1_len = `$ls -l $S/$afile | $awk '{print $5}'`
        @ t2_len = `$ls -l $D/$afile | $awk '{print $5}'`
        if ($t1_len <= $t2_len) continue
      endif
      set f2do = ($f2do $afile)
      set mesg = "Copying $afile to $D"
      if ($notquiet) echo $mesg
      echo $mesg >> $mbufr
#   Copy new file
      $cp $afile $D/. 
      set result = $status
      if ($result != 0) then
        set mesg = "   File copy failed from $S/$afile to $D/$afile"
        if ($notquiet) echo $mesg
        echo $mesg >> $mbufr
        $df $D >> $mbufr
###############    need to add code here to analyze copy failure
###############     disk full??
      else
        set mesg = "   Copied file from $S/$afile to $D/$afile"
        if ($notquiet) echo $mesg
        echo $mesg >> $mbufr
      endif
    end
  endif
end
#
#   Finished copying raw data files
popd >& /dev/null
$umount $S
set mesg = "  Removable drive (file path $S) unmounted."
if ($notquiet) then
  echo $mesg
  echo ""
endif
echo $mesg >> $mbufr
set mesg = "   New local raw-data file-copy job completed on "`date`
if ($notquiet) then
  echo $mesg
  echo ""
endif
echo $mesg >> $mbufr
#
#  Give the user disk-removal instructions
if (! -e $projdir/Instructions_2) then
#  Simple default "remove" message
  echo ""
  echo ""
  echo "  Remove the removable disk drive from its chassis slot."
  echo "  $0 script will now proceed to do its work automatically."
  echo ""
  echo ""
else
  cat $projdir/Instructions_2
endif
#
#  Set up email addressee(s)
set input = `grep "^e_names *=" $conf_f`
if ($#input > 2) then
  set elist = `echo $input | $awk -F= '{print $2}'`
  if ($debug) then
    echo "   elist = $elist"
    echo '   $#elist = '$#elist
  endif
  set mok = "yes"
else
  if ($debug) then
    echo "   Cannot read email addressee list from config file $conf_f"
  else
    $mp -s "$0 email error 2 -- line 737" $elist < /dev/null >& /dev/null
  endif
endif
#
#  Check to see if I have any files to process
@ nf2do = `echo $f2do | wc -m`
if ($nf2do > 0) @ nf2do = $#f2do
if ($nf2do < 1) goto nofiles
#
if ($debug) then
  echo "$nf2do files to process after copying"
  echo "File(s):  $f2do"
  echo ""
endif
#
#  Get the job list (file names in the .../Production/gndproc directory)
pushd $projdir >& /dev/null
set jobs = (`$ls *_*_*`)
popd >& /dev/null
#
if ($debug) echo "  $#jobs job(s) = $jobs"
#
if ($#jobs < 1) then
  set mesg = "  No job files found in $projdir."
  if ($notquiet) echo $mesg
  echo $mesg >> $mbufr
  goto nojobs
endif
#
#  Keep only recognized job types
set ujobs
foreach job ($jobs)
  set notfound = 1
  foreach job_type ($job_types)
    if (`echo $job | grep -c $job_type` > 0) then
#   Compose unordered job list
      set ujobs = ($ujobs $job)
      set notfound = 0
      break
    endif
  end
  if ($notfound) then
    set mesg = "  Unrecognized job type.  Skipping job: $job."
    if ($notquiet) echo $mesg
    echo $mesg >> $mbufr
  endif
end
#
if ($debug) echo "   Unordered job list: $ujobs"
#
#  Make sure jobs get done in the right order
#   (The order is actually set in the configuration file.)
#    process jobs
#      1) nimbus
#      2) n2asc
#    transfer jobs
#      3) copy
#
#  Sort the job list according to the above criterion
set jobs
foreach job_type ($job_types)
  foreach job ($ujobs)
    if (`echo $job | grep -c $job_type` > 0) then
      set jobs = ($jobs $job)
    endif
  end
end
#
#
if ($debug) echo "   Ordered job list: $jobs"
#
cd $D
#
#  Process the job list
foreach job ($jobs)
#
#   Log job start to log file
  set mesg = "  Starting job $job @ `date`."
  if ($notquiet) echo $mesg
  echo $mesg >> $mbufr
#
#   Parse job string
  set parse = (`echo $job | $awk -F_ '{print $1} {print $2} {print $3}'`)
  if ($#parse != 3) then
    set mesg = "  Cannot decode job.  Skipping job: $job."
    if ($notquiet) echo $mesg
    echo $mesg >> $mbufr
    continue
  endif
#   Set job type
  set j_type = $parse[1]
#   Set job source-file type
  set f_type = $parse[2]
#   Set job user name
  set user = $parse[3]
#
  if ($debug) then
    echo "  j_type = $j_type"
    echo "  f_type = $f_type"
    echo "  user = $user"
  endif
#
#   Check source-file type
  switch ($f_type)
    case ads
      breaksw
    case 2d
      breaksw
    case mcr
      breaksw
    case rdma
      breaksw
    case cdf
      breaksw
    case asc
      breaksw
    default
#    Unrecognized file type
      set mesg = "  Unrecognized source-file type.  Skipping job: $job."
      if ($notquiet) echo $mesg
      echo $mesg >> $mbufr
      continue
  endsw
#
#   (No need to check user)
#
  if ($debug) then
    echo "  Job $job passed initial tests."
    echo ""
  endif
#
#   Do the job
#
  foreach afile ($f2do)
#
#    Parse source file name for later, e.g., 301rf03a.ads --> (301rf03a ads)
  set pf = (`echo $afile | $awk -F. '{print $1} {print $2}'`)
#
#    Job types recognized as of 27 Jul 2002:  nimbus, n2asc, copy
#    (The type list is actually set in the configuration file.)
    switch ($j_type)
#
#
#    +---------------------------------------------------+
#    |  nimbus -- Process raw data; produce netCDF file  |
#    +---------------------------------------------------+
#
      case nimbus
#
#     Check for a raw ADS file
        switch ($f_type)
          case ads
            if ($pf[2] != $rads) continue
            breaksw
          default
            continue
          endsw
#
#     Get list of settings from job file
        set c_name = "nimbus_set"
        set $c_name = ""
        set input = `grep "^$c_name *=" $projdir/$job`
        set result = $status
        if ($result == 0) then
          set temp = `echo $input | awk -F= '{print $2}'`
          if ($#temp > 0) then
            set $c_name = ($temp)
            if ($debug) echo "  Got setting for ${c_name}:  $temp"
          else
            set mesg = "   $ns_msg1 $c_name missing from file $job"
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            set mesg = '   Skipping to next job.'
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            break
          endif
        else
          set mesg = "   $ns_msg3 $c_name in file $job"
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          set mesg = '   Skipping to next job.'
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          break
        endif
#
        if ($debug) echo "  $#nimbus_set nimbus_set = $nimbus_set"
#
#     Set optional settings to default values
        set nimbus_sf = ""
        set pr = 1
        set nimbus_p = "nimbus"
        set next = "nc"
        set fmod = ""
#
#     Get the settings for this job
        set gotem = "yes"
        foreach c_name ($nimbus_set)
          set input = `grep "^$c_name *=" $projdir/$job`
          set result = $status
          if ($result == 0) then 
            set temp = `echo $input | awk -F= '{print $2}'`
            if ($#temp > 0) then
              set $c_name = ($temp)
              if ($debug) echo "  Got setting for ${c_name}:  $temp"
            else
              set mesg = "   $ns_msg1 $c_name missing from file $job"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              set gotem = "no"
            endif
          else
            set mesg = "   $ns_msg3 $c_name in file $job"
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            set gotem = "no"
          endif
        end
#
#     Check for all settings
        if ($gotem == "no") then
          set mesg = "   Skipping to next job."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          break
        endif
#
#     Create nimbus batch file
        if (`echo $fmod | $wc -m` > 0) then
          set bfile = "${pf[1]}_$fmod.batch"
          set ofile = "${pf[1]}_$fmod.$next"
        else
          set bfile = "${pf[1]}.batch"
          set ofile = "${pf[1]}.$next"
        endif
        set mesg = "   Creating nimbus batch file $bfile"
        if ($notquiet) echo $mesg
        echo $mesg >> $mbufr
        echo "pr=$pr" >! $bfile
        set result = $status
        if ($result == 0) then
          echo "if=$D/$afile" >> $bfile
          echo "of=$D/$ofile" >> $bfile
          if ($nimbus_sf != "") then
            echo "sf=$nimbus_sf" >> $bfile
          endif
          if ($debug) then
            echo "  Batch file follows"
            cat $bfile
            echo "  End of batch file"
          endif
#     Run nimbus with batch file
          set mesg = "   Running nimbus for $user with command: $nimbus_p -b $bfile"
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          $nimbus_p -b $bfile >& /dev/null
          set result = $status
          if ($result != 0) then
            set mesg = "   Error $result running nimbus in batch mode on $afile for $user."
          else
            set mesg = "   Nimbus completed successfully and created file $ofile for $user"
          endif
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          $rm $bfile >& /dev/null
        else
          set mesg = "   Could not create nimbus batch file $bfile for $user"
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          set mesg = "   Skipping to next job."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
        endif
#
#     Skip to next file, if one
        breaksw
#
#
#    +----------------------------------------------------+
#    |  n2asc -- Create ASCII data file from netCDF file  |
#    +----------------------------------------------------+
#
      case n2asc
#
#     Get list of settings from job file
        set c_name = "n2asc_set"
        set $c_name = ""
        set input = `grep "^$c_name *=" $projdir/$job`
        set result = $status
        if ($result == 0) then
          set temp = `echo $input | awk -F= '{print $2}'`
          if ($#temp > 0) then
            set $c_name = ($temp)
            if ($debug) echo "  Got setting for ${c_name}:  $temp"
          else
            set mesg = "   $ns_msg1 $c_name missing from file $job"
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            set mesg = '   Skipping to next job.'
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            break
          endif
        else
          set mesg = "   $ns_msg3 $c_name in file $job"
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          set mesg = '   Skipping to next job.'
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          break
        endif
#
        if ($debug) echo "  $#n2asc_set n2asc_set = $n2asc_set"
#
#     Set optional settings to default values
        set n2asc_p = "n2asc"
        set varlist = ""
        set fmod = ""
        set nasa = "no"
#
#     Get the settings for this job
        set gotem = "yes"
        foreach c_name ($n2asc_set)
          set input = `grep "^$c_name *=" $projdir/$job`
          set result = $status
          if ($result == 0) then 
            set temp = `echo $input | awk -F= '{print $2}'`
            if ($#temp > 0) then
              set $c_name = ($temp)
              if ($debug) echo "  Got setting for ${c_name}:  $temp"
            else
              set mesg = "   $ns_msg1 $c_name missing from file $job"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              set gotem = "no"
            endif
          else
            set mesg = "   $ns_msg3 $c_name in file $job"
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            set gotem = "no"
          endif
        end
#
#     Check for all settings
        if ($gotem == "no") then
          set mesg = "   Skipping to next job."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          break
        endif
#
#     I key off the ADS file name to avoid duplicating this job
        if ($pf[2] != $rads) continue
#
#     Create n2asc processing-file names (netCDF, batch, ASCII)
        if (`echo $fmod | $wc -m` > 0) then
#       With user file-name modifier
          set ifile = "${pf[1]}_$fmod.$next"
          set bfile = "${pf[1]}_$fmod.batch"
          set ofile = "${pf[1]}_$fmod.$aext"
        else
#       Without user file-name modifier
          set ifile = "${pf[1]}.$next"
          set bfile = "${pf[1]}.batch"
          set ofile = "${pf[1]}.$aext"
        endif
#
#     Check for netCDF file
        $ls $ifile >& /dev/null
        set result = $status
        if ($result != 0) then
          set mesg = "   netCDF file ($ifile) not found.  Cannot run n2asc for $user."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          set mesg = "   Skipping to next job."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          breaksw
        endif
#
#     Create n2asc batch file
        set mesg = "   Creating n2asc batch file $bfile"
        if ($notquiet) echo $mesg
        echo $mesg >> $mbufr
        echo "if=$D/$ifile" >! $bfile
        set result = $status
        if ($result == 0) then
          echo "of=$D/$ofile" >> $bfile
#      Check for variable list
          if (`echo $varlist | $wc -m` > 0) then
            foreach var ($varlist)
              echo "var=$var" >> $bfile
            end
          endif
        endif
        if ($debug) then
          echo "  Batch file follows"
          cat $bfile
          echo "  End of batch file"
        endif
#
#     Compose command-line options
#      NASA output format
        if ($?nasa) then
          if ($nasa == "yes") then
            set dasha = "-a"
          else
            set dasha = ""
          endif
        else
          set dasha = ""
        endif
#      Number format (default is %10.3f)
        if ($?format) then
          set dashf = "-f $format"
        else
          set dashf = ""
        endif
#
#     Run n2asc with batch file
          set mesg = "   Running n2asc for $user with command: $n2asc_p $dasha $dashf -b $bfile"
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          $n2asc_p $dasha $dashf -b $bfile >& /dev/null
          set result = $status
          if ($result != 0) then
            set mesg = "   Error $result running n2asc in batch mode on $ifile for $user."
          else
            set mesg = "   n2asc completed successfully and created file $ofile for $user"
          endif
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          $rm $bfile >& /dev/null
        else
          set mesg = "   Could not create n2asc batch file $bfile for $user."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          set mesg = "   Skipping to next job."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
        endif
#
#     Skip to next file, if one
        breaksw
#
#
#    +---------------+
#    |  Copy a File  |
#    +---------------+
#
      case copy
#
###############          It would be nice if I didn't have to hard-wire these.
#     Is the job for this file type?
        set raw = 1
        switch ($f_type)
          case ads
            if ($pf[2] != $rads) continue
            breaksw
          case 2d
            if ($pf[2] != $r2d) continue
            breaksw
          case mcr
#      This is a special case because of the unique extent-naming convention.
            set noglob
            if (`echo $rmcr | grep -c ?` == 1) then
              set t1 = `echo $rmcr | $sed -e "s/?//"`
              if (`echo $pf[2] | $grep -c $t1` != 1) then
                unset noglob
                continue
              endif
            else if (`echo $rmcr | grep -c *` == 1) then
              set t1 = `echo $rmcr | $sed -e "s/*//"`
              if (`echo $pf[2] | $grep -c $t1` != 1) then
                unset noglob
                continue
              endif
              unset noglob
              if ($pf[2] != $rmcr) continue
            else
              unset noglob
            endif
            breaksw
          case rdma
            set raw = 0
            if ($pf[2] != $rrdma) continue
            breaksw
          case cdf
          case asc
            set raw = 0
            if ($pf[2] != $rads) continue
            breaksw
        endsw
#
#     Get list of settings from job file
        set c_name = "copy_set"
        set $c_name = ""
        set input = `grep "^$c_name *=" $projdir/$job`
        set result = $status
        if ($result == 0) then
          set temp = `echo $input | awk -F= '{print $2}'`
          if ($#temp > 0) then
            set $c_name = ($temp)
            if ($debug) echo "  Got setting for ${c_name}:  $temp"
          else
            set mesg = "   $ns_msg1 $c_name missing from file $job"
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            set mesg = '   Skipping to next job.'
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            break
          endif
        else
          set mesg = "   $ns_msg3 $c_name in file $job"
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          set mesg = '   Skipping to next job.'
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          break
        endif
#
        if ($debug) echo "  $#copy_set copy_set = $copy_set"
#
#     Set optional settings to default values
        set zip = "no"
        set fmod = ""
#
#     Get the settings for this job
        set gotem = "yes"
        foreach c_name ($copy_set)
          set input = `grep "^$c_name *=" $projdir/$job`
          set result = $status
          if ($result == 0) then 
            set temp = `echo $input | awk -F= '{print $2}'`
            if ($#temp > 0) then
              set $c_name = ($temp)
              if ($debug) echo "  Got setting for ${c_name}:  $temp"
            else
              set mesg = "   $ns_msg1 $c_name missing from file $job"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              set gotem = "no"
            endif
          else
            set mesg = "   $ns_msg3 $c_name in file $job"
            if ($notquiet) echo $mesg
            echo $mesg >> $mbufr
            set gotem = "no"
          endif
        end
#
#      Check for all settings
        if ($gotem == "no") then
          set mesg = "   Skipping to next job."
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
          break
        endif
#
#     (For processed files, $pf is the corresponding ADS file.)
#
#     Does special file-name modifier match (raw files don't count)?
        if ($raw) then
          set cfile = $afile
        else if ($f_type == "cdf") then
          if (`echo $fmod | $wc -m` > 0) then
            set cfile = `$ls ${pf[1]}_$fmod.$next`
            set result = $status
            if ($result != 0) then
              set mesg = "   Cannot find file ${pf[1]}_$fmod.$next for $user.  Skipping to next job."
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              continue
            endif
          else
            set cfile = `$ls ${pf[1]}.$next`
            set result = $status
            if ($result != 0) then
              set mesg = "   Cannot find file ${pf[1]}.$next for $user.  Skipping to next job."
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              continue
            endif
          endif
        else if ($f_type == "asc") then
          if (`echo $fmod | $wc -m` > 0) then
            set cfile = `$ls ${pf[1]}_$fmod.$aext`
            set result = $status
            if ($result != 0) then
              set mesg = "   Cannot find file ${pf[1]}_$fmod.$aext for $user.  Skipping to next job."
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              continue
            endif
          else
            set cfile = `$ls ${pf[1]}.$aext`
            set result = $status
            if ($result != 0) then
              set mesg = "   Cannot find file ${pf[1]}.$aext for $user.  Skipping to next job."
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              continue
            endif
          endif
        else
#     I should never get here
          set mesg = "  $0 -- bug in program -- line 1348"
          echo $mesg
          echo $mesg >> $mbufr
          continue
        endif
#
#      Make sure I got the type of copy from the job file
        if ($?copy_type) then
#
#     Gzip the file, if needed
          if ($zip == "yes") then
            if ($debug) echo "   gzipping $D/$cfile"
            $gzip $cfile
            set result = $status
            if ($result != 0) then
              set ext = ""
              set mesg = "   Gzip failed on file $cfile with error $result"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
            else
              set ext = ".$gext"
              if ($debug) echo "   gzipped $D/$cfile"
            endif
          endif
          switch ($copy_type)
#
#           +-------------------------------------------+
#           |  scp -- Copy File Using Secure File Copy  |
#           +-------------------------------------------+
            case scp
#     Copy file to destination
              set mesg = "   Beginning $copy_type $D/$cfile$ext to $user"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              if ($debug) echo "   $copy_p $D/$cfile$ext ${login}@${dest}:$ddp/$cfile$ext"
              $copy_p $D/$cfile$ext ${login}@${dest}:$ddp/$cfile$ext >& /dev/null
              set result = $status
              breaksw
#
#           +-------------------------------------------------+
#           |  ftp -- Copy File Using File Transfer Protocol  |
#           +-------------------------------------------------+
            case ftp
#     Compose ftp command file
              set bfile = "$HOME/.netrc"
              set mesg = "   Creating ftp command file $bfile"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              echo "machine $dest" >! $bfile
              set result = $status
              if ($result != 0) then
###############  handle problem with ftp command file here
              else
###############  set password (email address)
                echo "login ftp" >> $bfile
                echo "password user@renegade.bamex.rdp" >> $bfile
                echo "macdef init" >> $bfile
                echo "bi" >> $bfile
                echo "cd $ddp" >> $bfile
                echo "put $cfile$ext" >> $bfile
                echo "quit" >> $bfile
                echo "" >> $bfile
                set s = `chmod 600 $bfile`
              endif
              if ($debug) then
                echo "  ftp command file follows"
                cat $bfile
                echo "  End of command file"
              endif
              if ($debug) echo "Running ftp $dest "
#     Execute the ftp command file
              set s = `ftp $dest`
              if ($debug) echo "Removing $bfile file"
              set s = `rm $bfile`
              set result = $status
            if ($result != 0) then
              set mesg = "   ftp failed on file $cfile with error $result"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
            endif
              breaksw
#
#           +---------------------------------------------------------+
#           |  sftp -- Copy File Using Secure File Transfer Protocol  |
#           +---------------------------------------------------------+
            case sftp
              set mesg = "  This copy type ($copy_type) isn't ready yet."
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
              breaksw
          endsw
          if ($result != 0) then
            set mesg = "   $copy_type failed on file $cfile$ext with error $result."
          else
            set mesg = "   Copied file $cfile$ext to $user via $copy_type"
          endif
          if ($notquiet) echo $mesg
          echo $mesg >> $mbufr
#     Gunzip the file, if zipped
          if ($ext == ".$gext") then
            $gunzip $cfile$ext
            set result = $status
            if ($result != 0) then
              set mesg = "   Could not gunzip file $cfile$ext"
              if ($notquiet) echo $mesg
              echo $mesg >> $mbufr
            else
              if ($debug) echo "   Gunzipped file $cfile$ext"
            endif
          endif
        else
          set mesg = "   Did not get needed information from job file $afile; skipping job"
          echo $mesg >> $mbufr
        endif
        breaksw
#
#
#    +----------+
#    |  Oops !  |
#    +----------+
#
      default
        set mesg = "  Unrecognized job type: $j_type"
        if ($notquiet) echo $mesg
        echo $mesg >> $mbufr
        breaksw
    endsw
#
###############                           Make rudimentary entries in RAFDIS ??
#
  end
#
end
#
#  Finished
set mesg = "   Finished processing all jobs"
goto done
#
quit:
set mesg = "   $0 script quit with a drive-mount error."
goto done
#
nofiles:
set mesg = "   $0 script found no new files on the removable drive."
set f2do = (`echo $mbufr | sed -e "s:$D/::"` "dummy")
goto done
#
nojobs:
set mesg = "   $0 script found no jobs to process."
#
done:
echo $mesg
echo $mesg >> $mbufr
echo ""
#
#  Compose "real" name for log file
set logname = `echo $D/$f2do[1] | $sed -e "s/\..*//"`.$lext
if ($debug) echo "  Logfile name is $logname"
if (-e $logname) then
#    Add separator to logfile to separate runs
  if (-w $logname) then
    echo $mseparator >> $logname
#    Append new log file to "real" name
    set result = $status
    if ($result != 0) then
      set mesg = "   Could not add this log file ($mbufr) to extant one ($logname)"
      if ($notquiet) echo $mesg
      echo $mesg >> $mbufr
      set mesg = "   $mbufr will remain in $D."
      if ($notquiet) echo $mesg
      echo $mesg >> $mbufr
      set logname = $mbufr
    else
      echo $mbegan >> $logname
      cat $mbufr >> $logname
      $rm $mbufr >& /dev/null
    endif
  endif
else
  echo $mbegin >! $logname
  set result = $status
#  Copy new log file to "real" name
  if ($result != 0) then
    set mesg = "   Could not copy this log file from ($mbufr) to ($logname)"
    if ($notquiet) echo $mesg
    echo $mesg >> $mbufr
    set mesg = "   $mbufr will remain in $D."
    if ($notquiet) echo $mesg
    echo $mesg >> $mbufr
    set logname = $mbufr
  else
    cat $mbufr >> $logname
    $rm $mbufr >& /dev/null
  endif
endif
#
set mesg = "   Log file for this job is $logname"
echo $mesg
echo $mesg >> $logname
set mesg = "   $0 script completed @ `date`"
echo $mesg
echo $mesg >> $logname
#
#  Send $logname as email message to "recipients"
if ($mok == "yes") $mp -s "$0 job completed" $elist < $logname
#
set mok = "no"
#
abort:
onintr -
if (! -e $msg_f) then
#  Do nothing  (eliminates error message if this test's logic is reversed)
  echo "" >& /dev/null
else
  cat $msg_f
  \rm $msg_f
  exit
endif
if (! -e $mbufr) then
#  Do nothing  (eliminates error message if this test's logic is reversed)
  echo "" >& /dev/null
else
  set mesg = "  Job aborted by user" >> $mbufr
  echo $mesg >> $mbufr
endif
if ($mok == "yes") goto done
#
if ($?bfile) then
  if (! -e $bfile) then
#  Do nothing  (eliminates error message if this test's logic is reversed)
    echo "" >& /dev/null
  else
    \rm $bfile >& /dev/null
  endif
endif
if (! -e $mbufr) then
#  Do nothing  (eliminates error message if this test's logic is reversed)
  echo "" >& /dev/null
else
  cat $mbufr
  \rm $mbufr >& /dev/null
endif
#
exit
#
nostart:
echo ""
echo "   Make sure the configuration file exists and is set up for this"
echo "    project before running this script."
echo "" 
echo "   Usage:"
echo "     $0 <project_number> [configuration file name] [-v] [-d]"
echo "              or"
echo "     setenv GNDPROC_CONF <configuration file name>"
echo "     $0 <project_number> [-v] [-d]"
echo "       where:  -v -- optional setting for verbose output of script's progress"
echo "               -d -- optional setting for debug mode"
nostart2:
echo ""
echo "   Quitting."
exit
#
#  I'm missing configuration settings
nostart3:
#  Echo messages to user
if ($?msg_f) then
  cat $msg_f
  \rm $msg_f >& /dev/null
endif
#
exit
